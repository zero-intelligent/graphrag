[
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineFileCacheConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineFileReportingConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineFileStorageConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineTextInputConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "create_pipeline_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "create_pipeline_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "create_pipeline_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "load_pipeline_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "create_pipeline_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "create_pipeline_config",
        "importPath": "graphrag.index",
        "description": "graphrag.index",
        "isExtraImport": true,
        "detail": "graphrag.index",
        "documentation": {}
    },
    {
        "label": "TableContainer",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopWorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopVerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopWorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopWorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "WorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopWorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "ExecutionNode",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopWorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "TableContainer",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "FieldAggregateOperation",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "aggregate_operation_mapping",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "ProgressTicker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_ticker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "ProgressTicker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "ProgressTicker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "derive_from_rows",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "ProgressTicker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_ticker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "ProgressTicker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_ticker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "derive_from_rows",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "derive_from_rows",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_callback",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_iterable",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_iterable",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopVerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "derive_from_rows",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_ticker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "ProgressTicker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_ticker",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_iterable",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "progress_iterable",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INPUT_NAME",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "WorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "MemoryProfile",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "WorkflowRunResult",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "WorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "WorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INPUT_NAME",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "WorkflowCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "WorkflowCallbacksManager",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "TableContainer",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "VerbInput",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "verb",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INPUT_NAME",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INPUT_NAME",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "AsyncType",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "TableContainer",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopVerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "NoopVerbCallbacks",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "Workflow",
        "importPath": "datashaper",
        "description": "datashaper",
        "isExtraImport": true,
        "detail": "datashaper",
        "documentation": {}
    },
    {
        "label": "custom_verbs",
        "importPath": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "description": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "isExtraImport": true,
        "detail": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineBlobReportingConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineFileReportingConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineReportingConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineConfig",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config",
        "description": "graphrag.index.config",
        "isExtraImport": true,
        "detail": "graphrag.index.config",
        "documentation": {}
    },
    {
        "label": "WorkflowDefinitions",
        "importPath": "graphrag.index.workflows",
        "description": "graphrag.index.workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows",
        "documentation": {}
    },
    {
        "label": "VerbDefinitions",
        "importPath": "graphrag.index.workflows",
        "description": "graphrag.index.workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows",
        "documentation": {}
    },
    {
        "label": "WorkflowDefinitions",
        "importPath": "graphrag.index.workflows",
        "description": "graphrag.index.workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows",
        "documentation": {}
    },
    {
        "label": "load_workflows",
        "importPath": "graphrag.index.workflows",
        "description": "graphrag.index.workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows",
        "documentation": {}
    },
    {
        "label": "custom_workflows",
        "importPath": "examples.custom_set_of_available_workflows.custom_workflow_definitions",
        "description": "examples.custom_set_of_available_workflows.custom_workflow_definitions",
        "isExtraImport": true,
        "detail": "examples.custom_set_of_available_workflows.custom_workflow_definitions",
        "documentation": {}
    },
    {
        "label": "load_input",
        "importPath": "graphrag.index.input",
        "description": "graphrag.index.input",
        "isExtraImport": true,
        "detail": "graphrag.index.input",
        "documentation": {}
    },
    {
        "label": "load_input",
        "importPath": "graphrag.index.input",
        "description": "graphrag.index.input",
        "isExtraImport": true,
        "detail": "graphrag.index.input",
        "documentation": {}
    },
    {
        "label": "load_input",
        "importPath": "graphrag.index.input",
        "description": "graphrag.index.input",
        "isExtraImport": true,
        "detail": "graphrag.index.input",
        "documentation": {}
    },
    {
        "label": "load_input",
        "importPath": "graphrag.index.input",
        "description": "graphrag.index.input",
        "isExtraImport": true,
        "detail": "graphrag.index.input",
        "documentation": {}
    },
    {
        "label": "load_input",
        "importPath": "graphrag.index.input",
        "description": "graphrag.index.input",
        "isExtraImport": true,
        "detail": "graphrag.index.input",
        "documentation": {}
    },
    {
        "label": "load_input",
        "importPath": "graphrag.index.input",
        "description": "graphrag.index.input",
        "isExtraImport": true,
        "detail": "graphrag.index.input",
        "documentation": {}
    },
    {
        "label": "load_input",
        "importPath": "graphrag.index.input",
        "description": "graphrag.index.input",
        "isExtraImport": true,
        "detail": "graphrag.index.input",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "InMemoryCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "load_cache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "JsonPipelineCache",
        "importPath": "graphrag.index.cache",
        "description": "graphrag.index.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache",
        "documentation": {}
    },
    {
        "label": "MemoryPipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "BlobPipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "FilePipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "BlobPipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "FilePipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "load_storage",
        "importPath": "graphrag.index.storage",
        "description": "graphrag.index.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ReportingType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "InputConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "InputType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "StorageType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "enable_logging_with_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "resolve_paths",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "create_graphrag_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "read_dotenv",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "resolve_paths",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ApiKeyMissingError",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "AzureApiBaseMissingError",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "AzureDeploymentNameMissingError",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "CacheConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "CacheConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ChunkingConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ChunkingConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ClaimExtractionConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ClaimExtractionConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ClusterGraphConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ClusterGraphConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "CommunityReportsConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "CommunityReportsConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "EmbedGraphConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "EmbedGraphConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "EntityExtractionConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "EntityExtractionConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "GlobalSearchConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "InputConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "InputConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "InputFileType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "InputType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "LLMParameters",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "LLMParametersInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "LocalSearchConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ParallelizationParameters",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ReportingConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ReportingConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "ReportingType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "SnapshotsConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "SnapshotsConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "StorageConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "StorageConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "StorageType",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "SummarizeDescriptionsConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "SummarizeDescriptionsConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "UmapConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "UmapConfigInput",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "create_graphrag_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "create_graphrag_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "create_graphrag_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "create_graphrag_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "create_graphrag_config",
        "importPath": "graphrag.config",
        "description": "graphrag.config",
        "isExtraImport": true,
        "detail": "graphrag.config",
        "documentation": {}
    },
    {
        "label": "NoopPipelineCache",
        "importPath": "graphrag.index.cache.noop_pipeline_cache",
        "description": "graphrag.index.cache.noop_pipeline_cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache.noop_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "create_pipeline_config",
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "isExtraImport": true,
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "create_pipeline_config",
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "isExtraImport": true,
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "TableEmitterType",
        "importPath": "graphrag.index.emit.types",
        "description": "graphrag.index.emit.types",
        "isExtraImport": true,
        "detail": "graphrag.index.emit.types",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index.run",
        "description": "graphrag.index.run",
        "isExtraImport": true,
        "detail": "graphrag.index.run",
        "documentation": {}
    },
    {
        "label": "run_pipeline_with_config",
        "importPath": "graphrag.index.run",
        "description": "graphrag.index.run",
        "isExtraImport": true,
        "detail": "graphrag.index.run",
        "documentation": {}
    },
    {
        "label": "PipelineRunResult",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "PipelineRunResult",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "PipelineRunResult",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "PipelineRunResult",
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "PrintProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "PrintProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "NullProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "NullProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ReporterType",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "create_progress_reporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "PrintProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "ConsoleReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "StatusLogger",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "StatusLogger",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "StatusLogger",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "PrintProgressReporter",
        "importPath": "graphrag.logging",
        "description": "graphrag.logging",
        "isExtraImport": true,
        "detail": "graphrag.logging",
        "documentation": {}
    },
    {
        "label": "PositiveInt",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validate_call",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validate_call",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "TypeAdapter",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config.models.graph_rag_config",
        "description": "graphrag.config.models.graph_rag_config",
        "isExtraImport": true,
        "detail": "graphrag.config.models.graph_rag_config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config.models.graph_rag_config",
        "description": "graphrag.config.models.graph_rag_config",
        "isExtraImport": true,
        "detail": "graphrag.config.models.graph_rag_config",
        "documentation": {}
    },
    {
        "label": "load_llm",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "load_llm_embeddings",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "load_llm",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "load_llm",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "load_llm",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "load_llm",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "load_llm",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "load_llm_embeddings",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "load_llm_embeddings",
        "importPath": "graphrag.index.llm",
        "description": "graphrag.index.llm",
        "isExtraImport": true,
        "detail": "graphrag.index.llm",
        "documentation": {}
    },
    {
        "label": "MAX_TOKEN_COUNT",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "create_community_summarization_prompt",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "create_entity_extraction_prompt",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "create_entity_summarization_prompt",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "detect_language",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "generate_community_report_rating",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "generate_community_reporter_role",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "generate_domain",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "generate_entity_relationship_examples",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "generate_entity_types",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "generate_persona",
        "importPath": "graphrag.prompt_tune.generator",
        "description": "graphrag.prompt_tune.generator",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator",
        "documentation": {}
    },
    {
        "label": "MIN_CHUNK_SIZE",
        "importPath": "graphrag.prompt_tune.loader",
        "description": "graphrag.prompt_tune.loader",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.loader",
        "documentation": {}
    },
    {
        "label": "load_docs_in_chunks",
        "importPath": "graphrag.prompt_tune.loader",
        "description": "graphrag.prompt_tune.loader",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.loader",
        "documentation": {}
    },
    {
        "label": "DocSelectionType",
        "importPath": "graphrag.prompt_tune.types",
        "description": "graphrag.prompt_tune.types",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.types",
        "documentation": {}
    },
    {
        "label": "DocSelectionType",
        "importPath": "graphrag.prompt_tune.types",
        "description": "graphrag.prompt_tune.types",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.types",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Collection",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Hashable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model.entity",
        "description": "graphrag.model.entity",
        "isExtraImport": true,
        "detail": "graphrag.model.entity",
        "documentation": {}
    },
    {
        "label": "get_global_search_engine",
        "importPath": "graphrag.query.factories",
        "description": "graphrag.query.factories",
        "isExtraImport": true,
        "detail": "graphrag.query.factories",
        "documentation": {}
    },
    {
        "label": "get_local_search_engine",
        "importPath": "graphrag.query.factories",
        "description": "graphrag.query.factories",
        "isExtraImport": true,
        "detail": "graphrag.query.factories",
        "documentation": {}
    },
    {
        "label": "read_indexer_covariates",
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "isExtraImport": true,
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "read_indexer_entities",
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "isExtraImport": true,
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "read_indexer_relationships",
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "isExtraImport": true,
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "read_indexer_reports",
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "isExtraImport": true,
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "read_indexer_text_units",
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "isExtraImport": true,
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "store_entity_semantic_embeddings",
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_community_reports",
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_covariates",
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_entities",
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_relationships",
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_text_units",
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "SearchResult",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "SearchResult",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "GlobalContextBuilder",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "BaseSearch",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "SearchResult",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "LocalContextBuilder",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "BaseSearch",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "SearchResult",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "BaseSearch",
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "LanceDBVectorStore",
        "importPath": "graphrag.vector_stores.lancedb",
        "description": "graphrag.vector_stores.lancedb",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores.lancedb",
        "documentation": {}
    },
    {
        "label": "VectorStoreFactory",
        "importPath": "graphrag.vector_stores.typing",
        "description": "graphrag.vector_stores.typing",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores.typing",
        "documentation": {}
    },
    {
        "label": "VectorStoreType",
        "importPath": "graphrag.vector_stores.typing",
        "description": "graphrag.vector_stores.typing",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores.typing",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "DefaultAzureCredential",
        "importPath": "azure.identity",
        "description": "azure.identity",
        "isExtraImport": true,
        "detail": "azure.identity",
        "documentation": {}
    },
    {
        "label": "DefaultAzureCredential",
        "importPath": "azure.identity",
        "description": "azure.identity",
        "isExtraImport": true,
        "detail": "azure.identity",
        "documentation": {}
    },
    {
        "label": "DefaultAzureCredential",
        "importPath": "azure.identity",
        "description": "azure.identity",
        "isExtraImport": true,
        "detail": "azure.identity",
        "documentation": {}
    },
    {
        "label": "get_bearer_token_provider",
        "importPath": "azure.identity",
        "description": "azure.identity",
        "isExtraImport": true,
        "detail": "azure.identity",
        "documentation": {}
    },
    {
        "label": "DefaultAzureCredential",
        "importPath": "azure.identity",
        "description": "azure.identity",
        "isExtraImport": true,
        "detail": "azure.identity",
        "documentation": {}
    },
    {
        "label": "get_bearer_token_provider",
        "importPath": "azure.identity",
        "description": "azure.identity",
        "isExtraImport": true,
        "detail": "azure.identity",
        "documentation": {}
    },
    {
        "label": "DefaultAzureCredential",
        "importPath": "azure.identity",
        "description": "azure.identity",
        "isExtraImport": true,
        "detail": "azure.identity",
        "documentation": {}
    },
    {
        "label": "BlobServiceClient",
        "importPath": "azure.storage.blob",
        "description": "azure.storage.blob",
        "isExtraImport": true,
        "detail": "azure.storage.blob",
        "documentation": {}
    },
    {
        "label": "BlobServiceClient",
        "importPath": "azure.storage.blob",
        "description": "azure.storage.blob",
        "isExtraImport": true,
        "detail": "azure.storage.blob",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Unpack",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "NotRequired",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputFileType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "ReportingType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "StorageType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingTarget",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputFileType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "ReportingType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "StorageType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingTarget",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputFileType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "ReportingType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "StorageType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputFileType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "ReportingType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "StorageType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingTarget",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "isExtraImport": true,
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "graphrag.config.defaults",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "pformat",
        "importPath": "devtools",
        "description": "devtools",
        "isExtraImport": true,
        "detail": "devtools",
        "documentation": {}
    },
    {
        "label": "pformat",
        "importPath": "devtools",
        "description": "devtools",
        "isExtraImport": true,
        "detail": "devtools",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "environs",
        "description": "environs",
        "isExtraImport": true,
        "detail": "environs",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "environs",
        "description": "environs",
        "isExtraImport": true,
        "detail": "environs",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "dotenv_values",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "PipelineBlobCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineFileCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCacheConfigTypes",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineMemoryCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineBlobCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineFileCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineBlobCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCacheConfigTypes",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineFileCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineMemoryCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineNoneCacheConfig",
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "ArrowInvalid",
        "importPath": "pyarrow.lib",
        "description": "pyarrow.lib",
        "isExtraImport": true,
        "detail": "pyarrow.lib",
        "documentation": {}
    },
    {
        "label": "ArrowTypeError",
        "importPath": "pyarrow.lib",
        "description": "pyarrow.lib",
        "isExtraImport": true,
        "detail": "pyarrow.lib",
        "documentation": {}
    },
    {
        "label": "cluster_graph",
        "importPath": "graphrag.index.operations.cluster_graph",
        "description": "graphrag.index.operations.cluster_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.cluster_graph",
        "documentation": {}
    },
    {
        "label": "embed_graph",
        "importPath": "graphrag.index.operations.embed_graph",
        "description": "graphrag.index.operations.embed_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.embed_graph",
        "documentation": {}
    },
    {
        "label": "NodeEmbeddings",
        "importPath": "graphrag.index.operations.embed_graph",
        "description": "graphrag.index.operations.embed_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.embed_graph",
        "documentation": {}
    },
    {
        "label": "NodeEmbeddings",
        "importPath": "graphrag.index.operations.embed_graph",
        "description": "graphrag.index.operations.embed_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.embed_graph",
        "documentation": {}
    },
    {
        "label": "snapshot_rows",
        "importPath": "graphrag.index.operations.snapshot_rows",
        "description": "graphrag.index.operations.snapshot_rows",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.snapshot_rows",
        "documentation": {}
    },
    {
        "label": "snapshot_rows",
        "importPath": "graphrag.index.operations.snapshot_rows",
        "description": "graphrag.index.operations.snapshot_rows",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.snapshot_rows",
        "documentation": {}
    },
    {
        "label": "snapshot_rows",
        "importPath": "graphrag.index.operations.snapshot_rows",
        "description": "graphrag.index.operations.snapshot_rows",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.snapshot_rows",
        "documentation": {}
    },
    {
        "label": "extract_entities",
        "importPath": "graphrag.index.operations.extract_entities",
        "description": "graphrag.index.operations.extract_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.extract_entities",
        "documentation": {}
    },
    {
        "label": "merge_graphs",
        "importPath": "graphrag.index.operations.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.merge_graphs",
        "documentation": {}
    },
    {
        "label": "snapshot",
        "importPath": "graphrag.index.operations.snapshot",
        "description": "graphrag.index.operations.snapshot",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.snapshot",
        "documentation": {}
    },
    {
        "label": "snapshot",
        "importPath": "graphrag.index.operations.snapshot",
        "description": "graphrag.index.operations.snapshot",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.snapshot",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "chunk_text",
        "importPath": "graphrag.index.operations.chunk_text",
        "description": "graphrag.index.operations.chunk_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.chunk_text",
        "documentation": {}
    },
    {
        "label": "chunk_text",
        "importPath": "graphrag.index.operations.chunk_text",
        "description": "graphrag.index.operations.chunk_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.chunk_text",
        "documentation": {}
    },
    {
        "label": "gen_md5_hash",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "dict_has_keys_with_types",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "clean_str",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "gen_md5_hash",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "gen_md5_hash",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "load_graph",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "is_null",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "load_graph",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "load_graph",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "load_graph",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "gen_uuid",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "load_graph",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "load_graph",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "num_tokens_from_string",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "topological_sort",
        "importPath": "graphrag.index.utils",
        "description": "graphrag.index.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.utils",
        "documentation": {}
    },
    {
        "label": "unpack_graph",
        "importPath": "graphrag.index.operations.unpack_graph",
        "description": "graphrag.index.operations.unpack_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.unpack_graph",
        "documentation": {}
    },
    {
        "label": "unpack_graph",
        "importPath": "graphrag.index.operations.unpack_graph",
        "description": "graphrag.index.operations.unpack_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.unpack_graph",
        "documentation": {}
    },
    {
        "label": "unpack_graph",
        "importPath": "graphrag.index.operations.unpack_graph",
        "description": "graphrag.index.operations.unpack_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.unpack_graph",
        "documentation": {}
    },
    {
        "label": "unpack_graph",
        "importPath": "graphrag.index.operations.unpack_graph",
        "description": "graphrag.index.operations.unpack_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.unpack_graph",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "uuid4",
        "importPath": "uuid",
        "description": "uuid",
        "isExtraImport": true,
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "uuid4",
        "importPath": "uuid",
        "description": "uuid",
        "isExtraImport": true,
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "graphrag.index.graph.extractors.community_reports.schemas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_DESCRIPTION",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_DETAILS",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_ID",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_STATUS",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_SUBJECT",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_TYPE",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_DEGREE",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_DESCRIPTION",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_DETAILS",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_ID",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_SOURCE",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_TARGET",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_DEGREE",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_DESCRIPTION",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_DETAILS",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_ID",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_NAME",
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "embed_text",
        "importPath": "graphrag.index.operations.embed_text",
        "description": "graphrag.index.operations.embed_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.embed_text",
        "documentation": {}
    },
    {
        "label": "embed_text",
        "importPath": "graphrag.index.operations.embed_text",
        "description": "graphrag.index.operations.embed_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.embed_text",
        "documentation": {}
    },
    {
        "label": "embed_text",
        "importPath": "graphrag.index.operations.embed_text",
        "description": "graphrag.index.operations.embed_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.embed_text",
        "documentation": {}
    },
    {
        "label": "embed_text",
        "importPath": "graphrag.index.operations.embed_text",
        "description": "graphrag.index.operations.embed_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.embed_text",
        "documentation": {}
    },
    {
        "label": "embed_text",
        "importPath": "graphrag.index.operations.embed_text",
        "description": "graphrag.index.operations.embed_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.embed_text",
        "documentation": {}
    },
    {
        "label": "prepare_community_reports",
        "importPath": "graphrag.index.operations.summarize_communities",
        "description": "graphrag.index.operations.summarize_communities",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.summarize_communities",
        "documentation": {}
    },
    {
        "label": "restore_community_hierarchy",
        "importPath": "graphrag.index.operations.summarize_communities",
        "description": "graphrag.index.operations.summarize_communities",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.summarize_communities",
        "documentation": {}
    },
    {
        "label": "summarize_communities",
        "importPath": "graphrag.index.operations.summarize_communities",
        "description": "graphrag.index.operations.summarize_communities",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.summarize_communities",
        "documentation": {}
    },
    {
        "label": "extract_covariates",
        "importPath": "graphrag.index.operations.extract_covariates",
        "description": "graphrag.index.operations.extract_covariates",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.extract_covariates",
        "documentation": {}
    },
    {
        "label": "split_text",
        "importPath": "graphrag.index.operations.split_text",
        "description": "graphrag.index.operations.split_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.split_text",
        "documentation": {}
    },
    {
        "label": "split_text",
        "importPath": "graphrag.index.operations.split_text",
        "description": "graphrag.index.operations.split_text",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.split_text",
        "documentation": {}
    },
    {
        "label": "layout_graph",
        "importPath": "graphrag.index.operations.layout_graph",
        "description": "graphrag.index.operations.layout_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.layout_graph",
        "documentation": {}
    },
    {
        "label": "compute_edge_combined_degree",
        "importPath": "graphrag.index.operations.compute_edge_combined_degree",
        "description": "graphrag.index.operations.compute_edge_combined_degree",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.compute_edge_combined_degree",
        "documentation": {}
    },
    {
        "label": "summarize_descriptions",
        "importPath": "graphrag.index.operations.summarize_descriptions",
        "description": "graphrag.index.operations.summarize_descriptions",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.summarize_descriptions",
        "documentation": {}
    },
    {
        "label": "graspologic",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "graspologic",
        "description": "graspologic",
        "detail": "graspologic",
        "documentation": {}
    },
    {
        "label": "networkx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "networkx",
        "description": "networkx",
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "tiktoken",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tiktoken",
        "description": "tiktoken",
        "detail": "tiktoken",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "EmbeddingLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "LLMCache",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "LLMLimiter",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "MockCompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "OpenAIConfiguration",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "create_openai_chat_llm",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "create_openai_client",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "create_openai_completion_llm",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "create_openai_embedding_llm",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "create_tpm_rpm_limiters",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "EmbeddingLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "OpenAIConfiguration",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "MockChatLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm",
        "description": "graphrag.llm",
        "isExtraImport": true,
        "detail": "graphrag.llm",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "chunk_text",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "antijoin",
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "drop_columns",
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "transform_series",
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "union",
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "where_column_equals",
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "num_tokens_from_string",
        "importPath": "graphrag.index.utils.tokens",
        "description": "graphrag.index.utils.tokens",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.tokens",
        "documentation": {}
    },
    {
        "label": "num_tokens_from_string",
        "importPath": "graphrag.index.utils.tokens",
        "description": "graphrag.index.utils.tokens",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.tokens",
        "documentation": {}
    },
    {
        "label": "html",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "html",
        "description": "html",
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "largest_connected_component",
        "importPath": "graspologic.utils",
        "description": "graspologic.utils",
        "isExtraImport": true,
        "detail": "graspologic.utils",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "umap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "umap",
        "description": "umap",
        "detail": "umap",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "Tokenizer",
        "importPath": "graphrag.index.text_splitting",
        "description": "graphrag.index.text_splitting",
        "isExtraImport": true,
        "detail": "graphrag.index.text_splitting",
        "documentation": {}
    },
    {
        "label": "TokenTextSplitter",
        "importPath": "graphrag.index.text_splitting",
        "description": "graphrag.index.text_splitting",
        "isExtraImport": true,
        "detail": "graphrag.index.text_splitting",
        "documentation": {}
    },
    {
        "label": "NoopTextSplitter",
        "importPath": "graphrag.index.text_splitting",
        "description": "graphrag.index.text_splitting",
        "isExtraImport": true,
        "detail": "graphrag.index.text_splitting",
        "documentation": {}
    },
    {
        "label": "TextSplitter",
        "importPath": "graphrag.index.text_splitting",
        "description": "graphrag.index.text_splitting",
        "isExtraImport": true,
        "detail": "graphrag.index.text_splitting",
        "documentation": {}
    },
    {
        "label": "TokenTextSplitter",
        "importPath": "graphrag.index.text_splitting",
        "description": "graphrag.index.text_splitting",
        "isExtraImport": true,
        "detail": "graphrag.index.text_splitting",
        "documentation": {}
    },
    {
        "label": "embed_nod2vec",
        "importPath": "graphrag.index.graph.embedding",
        "description": "graphrag.index.graph.embedding",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.embedding",
        "documentation": {}
    },
    {
        "label": "stable_largest_connected_component",
        "importPath": "graphrag.index.graph.utils",
        "description": "graphrag.index.graph.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.utils",
        "documentation": {}
    },
    {
        "label": "stable_largest_connected_component",
        "importPath": "graphrag.index.graph.utils",
        "description": "graphrag.index.graph.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.utils",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Random",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Random",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "getrandbits",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "BaseVectorStore",
        "importPath": "graphrag.vector_stores",
        "description": "graphrag.vector_stores",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores",
        "documentation": {}
    },
    {
        "label": "VectorStoreDocument",
        "importPath": "graphrag.vector_stores",
        "description": "graphrag.vector_stores",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores",
        "documentation": {}
    },
    {
        "label": "VectorStoreFactory",
        "importPath": "graphrag.vector_stores",
        "description": "graphrag.vector_stores",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores",
        "documentation": {}
    },
    {
        "label": "BaseVectorStore",
        "importPath": "graphrag.vector_stores",
        "description": "graphrag.vector_stores",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores",
        "documentation": {}
    },
    {
        "label": "BaseVectorStore",
        "importPath": "graphrag.vector_stores",
        "description": "graphrag.vector_stores",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores",
        "documentation": {}
    },
    {
        "label": "VectorStoreDocument",
        "importPath": "graphrag.vector_stores",
        "description": "graphrag.vector_stores",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores",
        "documentation": {}
    },
    {
        "label": "BaseVectorStore",
        "importPath": "graphrag.vector_stores",
        "description": "graphrag.vector_stores",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores",
        "documentation": {}
    },
    {
        "label": "BaseVectorStore",
        "importPath": "graphrag.vector_stores",
        "description": "graphrag.vector_stores",
        "isExtraImport": true,
        "detail": "graphrag.vector_stores",
        "documentation": {}
    },
    {
        "label": "ClaimExtractor",
        "importPath": "graphrag.index.graph.extractors.claims",
        "description": "graphrag.index.graph.extractors.claims",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.claims",
        "documentation": {}
    },
    {
        "label": "GraphExtractor",
        "importPath": "graphrag.index.graph.extractors",
        "description": "graphrag.index.graph.extractors",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors",
        "documentation": {}
    },
    {
        "label": "words",
        "importPath": "nltk.corpus",
        "description": "nltk.corpus",
        "isExtraImport": true,
        "detail": "nltk.corpus",
        "documentation": {}
    },
    {
        "label": "bootstrap",
        "importPath": "graphrag.index.bootstrap",
        "description": "graphrag.index.bootstrap",
        "isExtraImport": true,
        "detail": "graphrag.index.bootstrap",
        "documentation": {}
    },
    {
        "label": "GraphLayout",
        "importPath": "graphrag.index.graph.visualization",
        "description": "graphrag.index.graph.visualization",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.visualization",
        "documentation": {}
    },
    {
        "label": "NodePosition",
        "importPath": "graphrag.index.graph.visualization",
        "description": "graphrag.index.graph.visualization",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.visualization",
        "documentation": {}
    },
    {
        "label": "compute_umap_positions",
        "importPath": "graphrag.index.graph.visualization",
        "description": "graphrag.index.graph.visualization",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.visualization",
        "documentation": {}
    },
    {
        "label": "GraphLayout",
        "importPath": "graphrag.index.graph.visualization",
        "description": "graphrag.index.graph.visualization",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.visualization",
        "documentation": {}
    },
    {
        "label": "NodePosition",
        "importPath": "graphrag.index.graph.visualization",
        "description": "graphrag.index.graph.visualization",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.visualization",
        "documentation": {}
    },
    {
        "label": "get_zero_positions",
        "importPath": "graphrag.index.graph.visualization",
        "description": "graphrag.index.graph.visualization",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.visualization",
        "documentation": {}
    },
    {
        "label": "GraphLayout",
        "importPath": "graphrag.index.graph.visualization",
        "description": "graphrag.index.graph.visualization",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.visualization",
        "documentation": {}
    },
    {
        "label": "filter_claims_to_nodes",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "filter_edges_to_nodes",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "filter_nodes_to_level",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "get_levels",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "set_context_exceeds_flag",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "set_context_size",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "sort_context",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "CommunityReportsExtractor",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "get_levels",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "prep_community_report_context",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "sort_context",
        "importPath": "graphrag.index.graph.extractors.community_reports",
        "description": "graphrag.index.graph.extractors.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.community_reports",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "importPath": "graphrag.index.utils.rate_limiter",
        "description": "graphrag.index.utils.rate_limiter",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.rate_limiter",
        "documentation": {}
    },
    {
        "label": "SummarizeExtractor",
        "importPath": "graphrag.index.graph.extractors.summarize",
        "description": "graphrag.index.graph.extractors.summarize",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.extractors.summarize",
        "documentation": {}
    },
    {
        "label": "hierarchical_leiden",
        "importPath": "graspologic.partition",
        "description": "graspologic.partition",
        "isExtraImport": true,
        "detail": "graspologic.partition",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache.pipeline_cache",
        "description": "graphrag.index.cache.pipeline_cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache.pipeline_cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "importPath": "graphrag.index.cache.pipeline_cache",
        "description": "graphrag.index.cache.pipeline_cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache.pipeline_cache",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfigTypes",
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "isExtraImport": true,
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfigTypes",
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "isExtraImport": true,
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "isExtraImport": true,
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfigTypes",
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "isExtraImport": true,
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineTextInputConfig",
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "isExtraImport": true,
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "importPath": "graphrag.index.config.workflow",
        "description": "graphrag.index.config.workflow",
        "isExtraImport": true,
        "detail": "graphrag.index.config.workflow",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "importPath": "graphrag.index.config.workflow",
        "description": "graphrag.index.config.workflow",
        "isExtraImport": true,
        "detail": "graphrag.index.config.workflow",
        "documentation": {}
    },
    {
        "label": "PipelineRunContext",
        "importPath": "graphrag.index.context",
        "description": "graphrag.index.context",
        "isExtraImport": true,
        "detail": "graphrag.index.context",
        "documentation": {}
    },
    {
        "label": "PipelineRunStats",
        "importPath": "graphrag.index.context",
        "description": "graphrag.index.context",
        "isExtraImport": true,
        "detail": "graphrag.index.context",
        "documentation": {}
    },
    {
        "label": "PipelineRunContext",
        "importPath": "graphrag.index.context",
        "description": "graphrag.index.context",
        "isExtraImport": true,
        "detail": "graphrag.index.context",
        "documentation": {}
    },
    {
        "label": "PipelineRunStats",
        "importPath": "graphrag.index.context",
        "description": "graphrag.index.context",
        "isExtraImport": true,
        "detail": "graphrag.index.context",
        "documentation": {}
    },
    {
        "label": "PipelineRunContext",
        "importPath": "graphrag.index.context",
        "description": "graphrag.index.context",
        "isExtraImport": true,
        "detail": "graphrag.index.context",
        "documentation": {}
    },
    {
        "label": "create_workflow",
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "create_workflow",
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "load_workflows",
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage.typing",
        "description": "graphrag.index.storage.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.typing",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage.typing",
        "description": "graphrag.index.storage.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.typing",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage.typing",
        "description": "graphrag.index.storage.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.typing",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage.typing",
        "description": "graphrag.index.storage.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.typing",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage.typing",
        "description": "graphrag.index.storage.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.typing",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "importPath": "graphrag.index.storage.typing",
        "description": "graphrag.index.storage.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.typing",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "ConsoleWorkflowCallbacks",
        "importPath": "graphrag.callbacks.console_workflow_callbacks",
        "description": "graphrag.callbacks.console_workflow_callbacks",
        "isExtraImport": true,
        "detail": "graphrag.callbacks.console_workflow_callbacks",
        "documentation": {}
    },
    {
        "label": "TableEmitterType",
        "importPath": "graphrag.index.emit",
        "description": "graphrag.index.emit",
        "isExtraImport": true,
        "detail": "graphrag.index.emit",
        "documentation": {}
    },
    {
        "label": "create_table_emitters",
        "importPath": "graphrag.index.emit",
        "description": "graphrag.index.emit",
        "isExtraImport": true,
        "detail": "graphrag.index.emit",
        "documentation": {}
    },
    {
        "label": "load_pipeline_config",
        "importPath": "graphrag.index.load_pipeline_config",
        "description": "graphrag.index.load_pipeline_config",
        "isExtraImport": true,
        "detail": "graphrag.index.load_pipeline_config",
        "documentation": {}
    },
    {
        "label": "_create_cache",
        "importPath": "graphrag.index.run.cache",
        "description": "graphrag.index.run.cache",
        "isExtraImport": true,
        "detail": "graphrag.index.run.cache",
        "documentation": {}
    },
    {
        "label": "_create_postprocess_steps",
        "importPath": "graphrag.index.run.postprocess",
        "description": "graphrag.index.run.postprocess",
        "isExtraImport": true,
        "detail": "graphrag.index.run.postprocess",
        "documentation": {}
    },
    {
        "label": "_run_post_process_steps",
        "importPath": "graphrag.index.run.postprocess",
        "description": "graphrag.index.run.postprocess",
        "isExtraImport": true,
        "detail": "graphrag.index.run.postprocess",
        "documentation": {}
    },
    {
        "label": "_dump_stats",
        "importPath": "graphrag.index.run.profiling",
        "description": "graphrag.index.run.profiling",
        "isExtraImport": true,
        "detail": "graphrag.index.run.profiling",
        "documentation": {}
    },
    {
        "label": "_write_workflow_stats",
        "importPath": "graphrag.index.run.profiling",
        "description": "graphrag.index.run.profiling",
        "isExtraImport": true,
        "detail": "graphrag.index.run.profiling",
        "documentation": {}
    },
    {
        "label": "_apply_substitutions",
        "importPath": "graphrag.index.run.utils",
        "description": "graphrag.index.run.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.run.utils",
        "documentation": {}
    },
    {
        "label": "_create_input",
        "importPath": "graphrag.index.run.utils",
        "description": "graphrag.index.run.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.run.utils",
        "documentation": {}
    },
    {
        "label": "_create_reporter",
        "importPath": "graphrag.index.run.utils",
        "description": "graphrag.index.run.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.run.utils",
        "documentation": {}
    },
    {
        "label": "_create_run_context",
        "importPath": "graphrag.index.run.utils",
        "description": "graphrag.index.run.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.run.utils",
        "documentation": {}
    },
    {
        "label": "_validate_dataset",
        "importPath": "graphrag.index.run.utils",
        "description": "graphrag.index.run.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.run.utils",
        "documentation": {}
    },
    {
        "label": "_create_run_context",
        "importPath": "graphrag.index.run.utils",
        "description": "graphrag.index.run.utils",
        "isExtraImport": true,
        "detail": "graphrag.index.run.utils",
        "documentation": {}
    },
    {
        "label": "_create_callback_chain",
        "importPath": "graphrag.index.run.workflow",
        "description": "graphrag.index.run.workflow",
        "isExtraImport": true,
        "detail": "graphrag.index.run.workflow",
        "documentation": {}
    },
    {
        "label": "_process_workflow",
        "importPath": "graphrag.index.run.workflow",
        "description": "graphrag.index.run.workflow",
        "isExtraImport": true,
        "detail": "graphrag.index.run.workflow",
        "documentation": {}
    },
    {
        "label": "get_delta_docs",
        "importPath": "graphrag.index.update.dataframes",
        "description": "graphrag.index.update.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.update.dataframes",
        "documentation": {}
    },
    {
        "label": "update_dataframe_outputs",
        "importPath": "graphrag.index.update.dataframes",
        "description": "graphrag.index.update.dataframes",
        "isExtraImport": true,
        "detail": "graphrag.index.update.dataframes",
        "documentation": {}
    },
    {
        "label": "_create_storage",
        "importPath": "graphrag.utils.storage",
        "description": "graphrag.utils.storage",
        "isExtraImport": true,
        "detail": "graphrag.utils.storage",
        "documentation": {}
    },
    {
        "label": "_load_table_from_storage",
        "importPath": "graphrag.utils.storage",
        "description": "graphrag.utils.storage",
        "isExtraImport": true,
        "detail": "graphrag.utils.storage",
        "documentation": {}
    },
    {
        "label": "_load_table_from_storage",
        "importPath": "graphrag.utils.storage",
        "description": "graphrag.utils.storage",
        "isExtraImport": true,
        "detail": "graphrag.utils.storage",
        "documentation": {}
    },
    {
        "label": "_create_storage",
        "importPath": "graphrag.utils.storage",
        "description": "graphrag.utils.storage",
        "isExtraImport": true,
        "detail": "graphrag.utils.storage",
        "documentation": {}
    },
    {
        "label": "_load_table_from_storage",
        "importPath": "graphrag.utils.storage",
        "description": "graphrag.utils.storage",
        "isExtraImport": true,
        "detail": "graphrag.utils.storage",
        "documentation": {}
    },
    {
        "label": "create_pipeline_reporter",
        "importPath": "graphrag.callbacks.factories",
        "description": "graphrag.callbacks.factories",
        "isExtraImport": true,
        "detail": "graphrag.callbacks.factories",
        "documentation": {}
    },
    {
        "label": "InMemoryCache",
        "importPath": "graphrag.index.cache.memory_pipeline_cache",
        "description": "graphrag.index.cache.memory_pipeline_cache",
        "isExtraImport": true,
        "detail": "graphrag.index.cache.memory_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "PipelineConfig",
        "importPath": "graphrag.index.config.pipeline",
        "description": "graphrag.index.config.pipeline",
        "isExtraImport": true,
        "detail": "graphrag.index.config.pipeline",
        "documentation": {}
    },
    {
        "label": "PipelineConfig",
        "importPath": "graphrag.index.config.pipeline",
        "description": "graphrag.index.config.pipeline",
        "isExtraImport": true,
        "detail": "graphrag.index.config.pipeline",
        "documentation": {}
    },
    {
        "label": "PipelineBlobReportingConfig",
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "isExtraImport": true,
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineFileReportingConfig",
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "isExtraImport": true,
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineReportingConfigTypes",
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "isExtraImport": true,
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineBlobReportingConfig",
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "isExtraImport": true,
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineConsoleReportingConfig",
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "isExtraImport": true,
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineFileReportingConfig",
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "isExtraImport": true,
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineReportingConfigTypes",
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "isExtraImport": true,
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineBlobStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineFileStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineBlobStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineFileStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineBlobStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineFileStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineMemoryStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorageConfigTypes",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineFileStorageConfig",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorageConfigTypes",
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "isExtraImport": true,
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "MemoryPipelineStorage",
        "importPath": "graphrag.index.storage.memory_pipeline_storage",
        "description": "graphrag.index.storage.memory_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.memory_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "MemoryPipelineStorage",
        "importPath": "graphrag.index.storage.memory_pipeline_storage",
        "description": "graphrag.index.storage.memory_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.memory_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "MemoryPipelineStorage",
        "importPath": "graphrag.index.storage.memory_pipeline_storage",
        "description": "graphrag.index.storage.memory_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.memory_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "MemoryPipelineStorage",
        "importPath": "graphrag.index.storage.memory_pipeline_storage",
        "description": "graphrag.index.storage.memory_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.memory_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "MemoryPipelineStorage",
        "importPath": "graphrag.index.storage.memory_pipeline_storage",
        "description": "graphrag.index.storage.memory_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.memory_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "ProgressWorkflowCallbacks",
        "importPath": "graphrag.callbacks.progress_workflow_callbacks",
        "description": "graphrag.callbacks.progress_workflow_callbacks",
        "isExtraImport": true,
        "detail": "graphrag.callbacks.progress_workflow_callbacks",
        "documentation": {}
    },
    {
        "label": "TableEmitter",
        "importPath": "graphrag.index.emit.table_emitter",
        "description": "graphrag.index.emit.table_emitter",
        "isExtraImport": true,
        "detail": "graphrag.index.emit.table_emitter",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "aiofiles",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiofiles",
        "description": "aiofiles",
        "detail": "aiofiles",
        "documentation": {}
    },
    {
        "label": "remove",
        "importPath": "aiofiles.os",
        "description": "aiofiles.os",
        "isExtraImport": true,
        "detail": "aiofiles.os",
        "documentation": {}
    },
    {
        "label": "exists",
        "importPath": "aiofiles.ospath",
        "description": "aiofiles.ospath",
        "isExtraImport": true,
        "detail": "aiofiles.ospath",
        "documentation": {}
    },
    {
        "label": "MergeHow",
        "importPath": "pandas._typing",
        "description": "pandas._typing",
        "isExtraImport": true,
        "detail": "pandas._typing",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "md5",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "TopologicalSorter",
        "importPath": "graphlib",
        "description": "graphlib",
        "isExtraImport": true,
        "detail": "graphlib",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "VerbResult",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_verb_result",
        "importPath": "datashaper.table_store.types",
        "description": "datashaper.table_store.types",
        "isExtraImport": true,
        "detail": "datashaper.table_store.types",
        "documentation": {}
    },
    {
        "label": "create_base_documents",
        "importPath": "graphrag.index.flows.create_base_documents",
        "description": "graphrag.index.flows.create_base_documents",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_base_documents",
        "documentation": {}
    },
    {
        "label": "get_required_input_table",
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "get_named_input_table",
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "get_required_input_table",
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "get_required_input_table",
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "get_named_input_table",
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "get_required_input_table",
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "isExtraImport": true,
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "create_base_entity_graph",
        "importPath": "graphrag.index.flows.create_base_entity_graph",
        "description": "graphrag.index.flows.create_base_entity_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_base_entity_graph",
        "documentation": {}
    },
    {
        "label": "create_base_extracted_entities",
        "importPath": "graphrag.index.flows.create_base_extracted_entities",
        "description": "graphrag.index.flows.create_base_extracted_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_base_extracted_entities",
        "documentation": {}
    },
    {
        "label": "create_base_text_units",
        "importPath": "graphrag.index.flows.create_base_text_units",
        "description": "graphrag.index.flows.create_base_text_units",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_base_text_units",
        "documentation": {}
    },
    {
        "label": "create_final_communities",
        "importPath": "graphrag.index.flows.create_final_communities",
        "description": "graphrag.index.flows.create_final_communities",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_final_communities",
        "documentation": {}
    },
    {
        "label": "create_final_community_reports",
        "importPath": "graphrag.index.flows.create_final_community_reports",
        "description": "graphrag.index.flows.create_final_community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_final_community_reports",
        "documentation": {}
    },
    {
        "label": "create_final_covariates",
        "importPath": "graphrag.index.flows.create_final_covariates",
        "description": "graphrag.index.flows.create_final_covariates",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_final_covariates",
        "documentation": {}
    },
    {
        "label": "create_final_documents",
        "importPath": "graphrag.index.flows.create_final_documents",
        "description": "graphrag.index.flows.create_final_documents",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_final_documents",
        "documentation": {}
    },
    {
        "label": "create_final_entities",
        "importPath": "graphrag.index.flows.create_final_entities",
        "description": "graphrag.index.flows.create_final_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_final_entities",
        "documentation": {}
    },
    {
        "label": "create_final_nodes",
        "importPath": "graphrag.index.flows.create_final_nodes",
        "description": "graphrag.index.flows.create_final_nodes",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_final_nodes",
        "documentation": {}
    },
    {
        "label": "create_final_relationships",
        "importPath": "graphrag.index.flows.create_final_relationships",
        "description": "graphrag.index.flows.create_final_relationships",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_final_relationships",
        "documentation": {}
    },
    {
        "label": "create_final_text_units",
        "importPath": "graphrag.index.flows.create_final_text_units",
        "description": "graphrag.index.flows.create_final_text_units",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_final_text_units",
        "documentation": {}
    },
    {
        "label": "create_summarized_entities",
        "importPath": "graphrag.index.flows.create_summarized_entities",
        "description": "graphrag.index.flows.create_summarized_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.flows.create_summarized_entities",
        "documentation": {}
    },
    {
        "label": "NoWorkflowsDefinedError",
        "importPath": "graphrag.index.errors",
        "description": "graphrag.index.errors",
        "isExtraImport": true,
        "detail": "graphrag.index.errors",
        "documentation": {}
    },
    {
        "label": "UndefinedWorkflowError",
        "importPath": "graphrag.index.errors",
        "description": "graphrag.index.errors",
        "isExtraImport": true,
        "detail": "graphrag.index.errors",
        "documentation": {}
    },
    {
        "label": "UnknownWorkflowError",
        "importPath": "graphrag.index.errors",
        "description": "graphrag.index.errors",
        "isExtraImport": true,
        "detail": "graphrag.index.errors",
        "documentation": {}
    },
    {
        "label": "UnknownWorkflowError",
        "importPath": "graphrag.index.errors",
        "description": "graphrag.index.errors",
        "isExtraImport": true,
        "detail": "graphrag.index.errors",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "graphrag.api",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "graphrag.api",
        "description": "graphrag.api",
        "detail": "graphrag.api",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config.models",
        "description": "graphrag.config.models",
        "isExtraImport": true,
        "detail": "graphrag.config.models",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingConfig",
        "importPath": "graphrag.config.models",
        "description": "graphrag.config.models",
        "isExtraImport": true,
        "detail": "graphrag.config.models",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "importPath": "graphrag.config.models",
        "description": "graphrag.config.models",
        "isExtraImport": true,
        "detail": "graphrag.config.models",
        "documentation": {}
    },
    {
        "label": "create_base_documents",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_base_entity_graph",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_base_extracted_entities",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_base_text_units",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_final_communities",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_final_community_reports",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_final_covariates",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_final_documents",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_final_entities",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_final_nodes",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_final_relationships",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_final_text_units",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "create_summarized_entities",
        "importPath": "graphrag.index.workflows.default_workflows",
        "description": "graphrag.index.workflows.default_workflows",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.default_workflows",
        "documentation": {}
    },
    {
        "label": "parse_config",
        "importPath": "pyaml_env",
        "description": "pyaml_env",
        "isExtraImport": true,
        "detail": "pyaml_env",
        "documentation": {}
    },
    {
        "label": "openai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openai",
        "description": "openai",
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "RateLimitError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncAzureOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncAzureOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "APIConnectionError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "InternalServerError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "RateLimitError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncAzureOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AzureOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "OpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMCache",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "OnCacheActionFn",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMConfig",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInvocationFn",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInvocationResult",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMConfig",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "EmbeddingLLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMCache",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInvocationFn",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "OnCacheActionFn",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMConfig",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "EmbeddingInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "EmbeddingOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "CompletionOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "LLMCache",
        "importPath": "graphrag.llm.types",
        "description": "graphrag.llm.types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types",
        "documentation": {}
    },
    {
        "label": "AsyncRetrying",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "retry_if_exception_type",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "stop_after_attempt",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "wait_exponential_jitter",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "AsyncRetrying",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "RetryError",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "Retrying",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "retry_if_exception_type",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "stop_after_attempt",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "wait_exponential_jitter",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "AsyncRetrying",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "RetryError",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "Retrying",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "retry_if_exception_type",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "stop_after_attempt",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "wait_exponential_jitter",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "AsyncRetrying",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "RetryError",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "Retrying",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "retry_if_exception_type",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "stop_after_attempt",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "wait_exponential_jitter",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "RetriesExhaustedError",
        "importPath": "graphrag.llm.errors",
        "description": "graphrag.llm.errors",
        "isExtraImport": true,
        "detail": "graphrag.llm.errors",
        "documentation": {}
    },
    {
        "label": "LLMLimiter",
        "importPath": "graphrag.llm.limiting",
        "description": "graphrag.llm.limiting",
        "isExtraImport": true,
        "detail": "graphrag.llm.limiting",
        "documentation": {}
    },
    {
        "label": "LLMLimiter",
        "importPath": "graphrag.llm.limiting",
        "description": "graphrag.llm.limiting",
        "isExtraImport": true,
        "detail": "graphrag.llm.limiting",
        "documentation": {}
    },
    {
        "label": "AsyncLimiter",
        "importPath": "aiolimiter",
        "description": "aiolimiter",
        "isExtraImport": true,
        "detail": "aiolimiter",
        "documentation": {}
    },
    {
        "label": "AsyncLimiter",
        "importPath": "aiolimiter",
        "description": "aiolimiter",
        "isExtraImport": true,
        "detail": "aiolimiter",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.llm.base",
        "description": "graphrag.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.llm.base",
        "description": "graphrag.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.llm.base",
        "documentation": {}
    },
    {
        "label": "CachingLLM",
        "importPath": "graphrag.llm.base",
        "description": "graphrag.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.llm.base",
        "documentation": {}
    },
    {
        "label": "RateLimitingLLM",
        "importPath": "graphrag.llm.base",
        "description": "graphrag.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.llm.base",
        "description": "graphrag.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.llm.base",
        "description": "graphrag.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.llm.base",
        "description": "graphrag.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.llm.base",
        "documentation": {}
    },
    {
        "label": "cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "repair_json",
        "importPath": "json_repair",
        "description": "json_repair",
        "isExtraImport": true,
        "detail": "json_repair",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Group",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Live",
        "importPath": "rich.live",
        "description": "rich.live",
        "isExtraImport": true,
        "detail": "rich.live",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TaskID",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TimeElapsedColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "Spinner",
        "importPath": "rich.spinner",
        "description": "rich.spinner",
        "isExtraImport": true,
        "detail": "rich.spinner",
        "documentation": {}
    },
    {
        "label": "Tree",
        "importPath": "rich.tree",
        "description": "rich.tree",
        "isExtraImport": true,
        "detail": "rich.tree",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types.llm_types",
        "description": "graphrag.llm.types.llm_types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types.llm_types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types.llm_types",
        "description": "graphrag.llm.types.llm_types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types.llm_types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types.llm_types",
        "description": "graphrag.llm.types.llm_types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types.llm_types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types.llm_types",
        "description": "graphrag.llm.types.llm_types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types.llm_types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types.llm_types",
        "description": "graphrag.llm.types.llm_types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types.llm_types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types.llm_types",
        "description": "graphrag.llm.types.llm_types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types.llm_types",
        "documentation": {}
    },
    {
        "label": "CompletionLLM",
        "importPath": "graphrag.llm.types.llm_types",
        "description": "graphrag.llm.types.llm_types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types.llm_types",
        "documentation": {}
    },
    {
        "label": "EmbeddingLLM",
        "importPath": "graphrag.llm.types.llm_types",
        "description": "graphrag.llm.types.llm_types",
        "isExtraImport": true,
        "detail": "graphrag.llm.types.llm_types",
        "documentation": {}
    },
    {
        "label": "GENERATE_REPORT_RATING_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt",
        "description": "graphrag.prompt_tune.prompt",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt",
        "documentation": {}
    },
    {
        "label": "GENERATE_COMMUNITY_REPORTER_ROLE_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt",
        "description": "graphrag.prompt_tune.prompt",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt",
        "documentation": {}
    },
    {
        "label": "ENTITY_RELATIONSHIPS_GENERATION_JSON_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt",
        "description": "graphrag.prompt_tune.prompt",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt",
        "documentation": {}
    },
    {
        "label": "ENTITY_RELATIONSHIPS_GENERATION_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt",
        "description": "graphrag.prompt_tune.prompt",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt",
        "documentation": {}
    },
    {
        "label": "UNTYPED_ENTITY_RELATIONSHIPS_GENERATION_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt",
        "description": "graphrag.prompt_tune.prompt",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt",
        "documentation": {}
    },
    {
        "label": "DETECT_LANGUAGE_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt",
        "description": "graphrag.prompt_tune.prompt",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt",
        "documentation": {}
    },
    {
        "label": "GENERATE_PERSONA_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt",
        "description": "graphrag.prompt_tune.prompt",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_REPORT_SUMMARIZATION_PROMPT",
        "importPath": "graphrag.prompt_tune.template",
        "description": "graphrag.prompt_tune.template",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.template",
        "documentation": {}
    },
    {
        "label": "EXAMPLE_EXTRACTION_TEMPLATE",
        "importPath": "graphrag.prompt_tune.template",
        "description": "graphrag.prompt_tune.template",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.template",
        "documentation": {}
    },
    {
        "label": "GRAPH_EXTRACTION_JSON_PROMPT",
        "importPath": "graphrag.prompt_tune.template",
        "description": "graphrag.prompt_tune.template",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.template",
        "documentation": {}
    },
    {
        "label": "GRAPH_EXTRACTION_PROMPT",
        "importPath": "graphrag.prompt_tune.template",
        "description": "graphrag.prompt_tune.template",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.template",
        "documentation": {}
    },
    {
        "label": "UNTYPED_EXAMPLE_EXTRACTION_TEMPLATE",
        "importPath": "graphrag.prompt_tune.template",
        "description": "graphrag.prompt_tune.template",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.template",
        "documentation": {}
    },
    {
        "label": "UNTYPED_GRAPH_EXTRACTION_PROMPT",
        "importPath": "graphrag.prompt_tune.template",
        "description": "graphrag.prompt_tune.template",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.template",
        "documentation": {}
    },
    {
        "label": "ENTITY_SUMMARIZATION_PROMPT",
        "importPath": "graphrag.prompt_tune.template",
        "description": "graphrag.prompt_tune.template",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.template",
        "documentation": {}
    },
    {
        "label": "GENERATE_DOMAIN_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt.domain",
        "description": "graphrag.prompt_tune.prompt.domain",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt.domain",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TASK",
        "importPath": "graphrag.prompt_tune.generator.defaults",
        "description": "graphrag.prompt_tune.generator.defaults",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator.defaults",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TASK",
        "importPath": "graphrag.prompt_tune.generator.defaults",
        "description": "graphrag.prompt_tune.generator.defaults",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.generator.defaults",
        "documentation": {}
    },
    {
        "label": "ENTITY_TYPE_GENERATION_JSON_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt.entity_types",
        "description": "graphrag.prompt_tune.prompt.entity_types",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt.entity_types",
        "documentation": {}
    },
    {
        "label": "ENTITY_TYPE_GENERATION_PROMPT",
        "importPath": "graphrag.prompt_tune.prompt.entity_types",
        "description": "graphrag.prompt_tune.prompt.entity_types",
        "isExtraImport": true,
        "detail": "graphrag.prompt_tune.prompt.entity_types",
        "documentation": {}
    },
    {
        "label": "ConversationHistory",
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "ConversationHistory",
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "ConversationHistory",
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "ConversationHistory",
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "ConversationHistory",
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "ConversationHistory",
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "ConversationHistory",
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Covariate",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "TextUnit",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Community",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Covariate",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Document",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "TextUnit",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Covariate",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "TextUnit",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Covariate",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "TextUnit",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Covariate",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "TextUnit",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Covariate",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Entity",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "TextUnit",
        "importPath": "graphrag.model",
        "description": "graphrag.model",
        "isExtraImport": true,
        "detail": "graphrag.model",
        "documentation": {}
    },
    {
        "label": "get_entity_by_key",
        "importPath": "graphrag.query.input.retrieval.entities",
        "description": "graphrag.query.input.retrieval.entities",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.entities",
        "documentation": {}
    },
    {
        "label": "get_entity_by_name",
        "importPath": "graphrag.query.input.retrieval.entities",
        "description": "graphrag.query.input.retrieval.entities",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.entities",
        "documentation": {}
    },
    {
        "label": "to_entity_dataframe",
        "importPath": "graphrag.query.input.retrieval.entities",
        "description": "graphrag.query.input.retrieval.entities",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.entities",
        "documentation": {}
    },
    {
        "label": "BaseTextEmbedding",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseTextEmbedding",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLMCallback",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseTextEmbedding",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLMCallback",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLMCallback",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseTextEmbedding",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLMCallback",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "get_candidate_covariates",
        "importPath": "graphrag.query.input.retrieval.covariates",
        "description": "graphrag.query.input.retrieval.covariates",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.covariates",
        "documentation": {}
    },
    {
        "label": "to_covariate_dataframe",
        "importPath": "graphrag.query.input.retrieval.covariates",
        "description": "graphrag.query.input.retrieval.covariates",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.covariates",
        "documentation": {}
    },
    {
        "label": "get_candidate_relationships",
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "get_entities_from_relationships",
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "get_in_network_relationships",
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "get_out_network_relationships",
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "to_relationship_dataframe",
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "to_list",
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_dict",
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_float",
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_int",
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_list",
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_str",
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_str",
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "isExtraImport": true,
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "OpenaiApiType",
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OPENAI_RETRY_ERROR_TYPES",
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OpenaiApiType",
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OPENAI_RETRY_ERROR_TYPES",
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OpenaiApiType",
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OPENAI_RETRY_ERROR_TYPES",
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OpenaiApiType",
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OpenaiApiType",
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OpenAILLMImpl",
        "importPath": "graphrag.query.llm.oai.base",
        "description": "graphrag.query.llm.oai.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.base",
        "documentation": {}
    },
    {
        "label": "OpenAILLMImpl",
        "importPath": "graphrag.query.llm.oai.base",
        "description": "graphrag.query.llm.oai.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.base",
        "documentation": {}
    },
    {
        "label": "OpenAILLMImpl",
        "importPath": "graphrag.query.llm.oai.base",
        "description": "graphrag.query.llm.oai.base",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.base",
        "documentation": {}
    },
    {
        "label": "BaseLLMCallback",
        "importPath": "graphrag.callbacks.llm_callbacks",
        "description": "graphrag.callbacks.llm_callbacks",
        "isExtraImport": true,
        "detail": "graphrag.callbacks.llm_callbacks",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "GlobalContextBuilder",
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "LocalContextBuilder",
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "LocalContextBuilder",
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "GlobalContextBuilder",
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "LocalContextBuilder",
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "GlobalContextBuilder",
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "LocalContextBuilder",
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "BaseQuestionGen",
        "importPath": "graphrag.query.question_gen.base",
        "description": "graphrag.query.question_gen.base",
        "isExtraImport": true,
        "detail": "graphrag.query.question_gen.base",
        "documentation": {}
    },
    {
        "label": "QuestionResult",
        "importPath": "graphrag.query.question_gen.base",
        "description": "graphrag.query.question_gen.base",
        "isExtraImport": true,
        "detail": "graphrag.query.question_gen.base",
        "documentation": {}
    },
    {
        "label": "QUESTION_SYSTEM_PROMPT",
        "importPath": "graphrag.query.question_gen.system_prompt",
        "description": "graphrag.query.question_gen.system_prompt",
        "isExtraImport": true,
        "detail": "graphrag.query.question_gen.system_prompt",
        "documentation": {}
    },
    {
        "label": "build_community_context",
        "importPath": "graphrag.query.context_builder.community_context",
        "description": "graphrag.query.context_builder.community_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.community_context",
        "documentation": {}
    },
    {
        "label": "build_community_context",
        "importPath": "graphrag.query.context_builder.community_context",
        "description": "graphrag.query.context_builder.community_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.community_context",
        "documentation": {}
    },
    {
        "label": "NO_COMMUNITY_RECORDS_WARNING",
        "importPath": "graphrag.query.context_builder.community_context",
        "description": "graphrag.query.context_builder.community_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.community_context",
        "documentation": {}
    },
    {
        "label": "GlobalSearchLLMCallback",
        "importPath": "graphrag.callbacks.global_search_callbacks",
        "description": "graphrag.callbacks.global_search_callbacks",
        "isExtraImport": true,
        "detail": "graphrag.callbacks.global_search_callbacks",
        "documentation": {}
    },
    {
        "label": "try_parse_json_object",
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "isExtraImport": true,
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "MAP_SYSTEM_PROMPT",
        "importPath": "graphrag.query.structured_search.global_search.map_system_prompt",
        "description": "graphrag.query.structured_search.global_search.map_system_prompt",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.global_search.map_system_prompt",
        "documentation": {}
    },
    {
        "label": "GENERAL_KNOWLEDGE_INSTRUCTION",
        "importPath": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "description": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "documentation": {}
    },
    {
        "label": "NO_DATA_ANSWER",
        "importPath": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "description": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "documentation": {}
    },
    {
        "label": "REDUCE_SYSTEM_PROMPT",
        "importPath": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "description": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "EntityVectorStoreKey",
        "importPath": "graphrag.query.context_builder.entity_extraction",
        "description": "graphrag.query.context_builder.entity_extraction",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.entity_extraction",
        "documentation": {}
    },
    {
        "label": "map_query_to_entities",
        "importPath": "graphrag.query.context_builder.entity_extraction",
        "description": "graphrag.query.context_builder.entity_extraction",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.entity_extraction",
        "documentation": {}
    },
    {
        "label": "EntityVectorStoreKey",
        "importPath": "graphrag.query.context_builder.entity_extraction",
        "description": "graphrag.query.context_builder.entity_extraction",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.entity_extraction",
        "documentation": {}
    },
    {
        "label": "build_covariates_context",
        "importPath": "graphrag.query.context_builder.local_context",
        "description": "graphrag.query.context_builder.local_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.local_context",
        "documentation": {}
    },
    {
        "label": "build_entity_context",
        "importPath": "graphrag.query.context_builder.local_context",
        "description": "graphrag.query.context_builder.local_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.local_context",
        "documentation": {}
    },
    {
        "label": "build_relationship_context",
        "importPath": "graphrag.query.context_builder.local_context",
        "description": "graphrag.query.context_builder.local_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.local_context",
        "documentation": {}
    },
    {
        "label": "get_candidate_context",
        "importPath": "graphrag.query.context_builder.local_context",
        "description": "graphrag.query.context_builder.local_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.local_context",
        "documentation": {}
    },
    {
        "label": "build_text_unit_context",
        "importPath": "graphrag.query.context_builder.source_context",
        "description": "graphrag.query.context_builder.source_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.source_context",
        "documentation": {}
    },
    {
        "label": "count_relationships",
        "importPath": "graphrag.query.context_builder.source_context",
        "description": "graphrag.query.context_builder.source_context",
        "isExtraImport": true,
        "detail": "graphrag.query.context_builder.source_context",
        "documentation": {}
    },
    {
        "label": "get_candidate_communities",
        "importPath": "graphrag.query.input.retrieval.community_reports",
        "description": "graphrag.query.input.retrieval.community_reports",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.community_reports",
        "documentation": {}
    },
    {
        "label": "get_candidate_text_units",
        "importPath": "graphrag.query.input.retrieval.text_units",
        "description": "graphrag.query.input.retrieval.text_units",
        "isExtraImport": true,
        "detail": "graphrag.query.input.retrieval.text_units",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_SYSTEM_PROMPT",
        "importPath": "graphrag.query.structured_search.local_search.system_prompt",
        "description": "graphrag.query.structured_search.local_search.system_prompt",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.local_search.system_prompt",
        "documentation": {}
    },
    {
        "label": "ChatOpenAI",
        "importPath": "graphrag.query.llm.oai.chat_openai",
        "description": "graphrag.query.llm.oai.chat_openai",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.chat_openai",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbedding",
        "importPath": "graphrag.query.llm.oai.embedding",
        "description": "graphrag.query.llm.oai.embedding",
        "isExtraImport": true,
        "detail": "graphrag.query.llm.oai.embedding",
        "documentation": {}
    },
    {
        "label": "GlobalCommunityContext",
        "importPath": "graphrag.query.structured_search.global_search.community_context",
        "description": "graphrag.query.structured_search.global_search.community_context",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.global_search.community_context",
        "documentation": {}
    },
    {
        "label": "GlobalSearch",
        "importPath": "graphrag.query.structured_search.global_search.search",
        "description": "graphrag.query.structured_search.global_search.search",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.global_search.search",
        "documentation": {}
    },
    {
        "label": "LocalSearchMixedContext",
        "importPath": "graphrag.query.structured_search.local_search.mixed_context",
        "description": "graphrag.query.structured_search.local_search.mixed_context",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.local_search.mixed_context",
        "documentation": {}
    },
    {
        "label": "LocalSearch",
        "importPath": "graphrag.query.structured_search.local_search.search",
        "description": "graphrag.query.structured_search.local_search.search",
        "isExtraImport": true,
        "detail": "graphrag.query.structured_search.local_search.search",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "AzureKeyCredential",
        "importPath": "azure.core.credentials",
        "description": "azure.core.credentials",
        "isExtraImport": true,
        "detail": "azure.core.credentials",
        "documentation": {}
    },
    {
        "label": "SearchClient",
        "importPath": "azure.search.documents",
        "description": "azure.search.documents",
        "isExtraImport": true,
        "detail": "azure.search.documents",
        "documentation": {}
    },
    {
        "label": "SearchIndexClient",
        "importPath": "azure.search.documents.indexes",
        "description": "azure.search.documents.indexes",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes",
        "documentation": {}
    },
    {
        "label": "HnswAlgorithmConfiguration",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "HnswParameters",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "SearchableField",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "SearchField",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "SearchFieldDataType",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "SearchIndex",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "SimpleField",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "VectorSearch",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "VectorSearchAlgorithmMetric",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "VectorSearchProfile",
        "importPath": "azure.search.documents.indexes.models",
        "description": "azure.search.documents.indexes.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.indexes.models",
        "documentation": {}
    },
    {
        "label": "VectorizedQuery",
        "importPath": "azure.search.documents.models",
        "description": "azure.search.documents.models",
        "isExtraImport": true,
        "detail": "azure.search.documents.models",
        "documentation": {}
    },
    {
        "label": "TextEmbedder",
        "importPath": "graphrag.model.types",
        "description": "graphrag.model.types",
        "isExtraImport": true,
        "detail": "graphrag.model.types",
        "documentation": {}
    },
    {
        "label": "TextEmbedder",
        "importPath": "graphrag.model.types",
        "description": "graphrag.model.types",
        "isExtraImport": true,
        "detail": "graphrag.model.types",
        "documentation": {}
    },
    {
        "label": "TextEmbedder",
        "importPath": "graphrag.model.types",
        "description": "graphrag.model.types",
        "isExtraImport": true,
        "detail": "graphrag.model.types",
        "documentation": {}
    },
    {
        "label": "lancedb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lancedb",
        "description": "lancedb",
        "detail": "lancedb",
        "documentation": {}
    },
    {
        "label": "pyarrow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyarrow",
        "description": "pyarrow",
        "detail": "pyarrow",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "mock",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "mock",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "mock",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "BlobPipelineStorage",
        "importPath": "graphrag.index.storage.blob_pipeline_storage",
        "description": "graphrag.index.storage.blob_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.blob_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "BlobPipelineStorage",
        "importPath": "graphrag.index.storage.blob_pipeline_storage",
        "description": "graphrag.index.storage.blob_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.blob_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "FilePipelineStorage",
        "importPath": "graphrag.index.storage.file_pipeline_storage",
        "description": "graphrag.index.storage.file_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.file_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "FilePipelineStorage",
        "importPath": "graphrag.index.storage.file_pipeline_storage",
        "description": "graphrag.index.storage.file_pipeline_storage",
        "isExtraImport": true,
        "detail": "graphrag.index.storage.file_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "nbformat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nbformat",
        "description": "nbformat",
        "detail": "nbformat",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "resolve_path",
        "importPath": "graphrag.config.resolve_path",
        "description": "graphrag.config.resolve_path",
        "isExtraImport": true,
        "detail": "graphrag.config.resolve_path",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "stable_largest_connected_component",
        "importPath": "graphrag.index.graph.utils.stable_lcc",
        "description": "graphrag.index.graph.utils.stable_lcc",
        "isExtraImport": true,
        "detail": "graphrag.index.graph.utils.stable_lcc",
        "documentation": {}
    },
    {
        "label": "run_extract_entities",
        "importPath": "graphrag.index.operations.extract_entities.strategies.graph_intelligence",
        "description": "graphrag.index.operations.extract_entities.strategies.graph_intelligence",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.extract_entities.strategies.graph_intelligence",
        "documentation": {}
    },
    {
        "label": "Document",
        "importPath": "graphrag.index.operations.extract_entities.strategies.typing",
        "description": "graphrag.index.operations.extract_entities.strategies.typing",
        "isExtraImport": true,
        "detail": "graphrag.index.operations.extract_entities.strategies.typing",
        "documentation": {}
    },
    {
        "label": "create_mock_llm",
        "importPath": "tests.unit.indexing.verbs.helpers.mock_llm",
        "description": "tests.unit.indexing.verbs.helpers.mock_llm",
        "isExtraImport": true,
        "detail": "tests.unit.indexing.verbs.helpers.mock_llm",
        "documentation": {}
    },
    {
        "label": "INIT_YAML",
        "importPath": "graphrag.index.init_content",
        "description": "graphrag.index.init_content",
        "isExtraImport": true,
        "detail": "graphrag.index.init_content",
        "documentation": {}
    },
    {
        "label": "CachingLLM",
        "importPath": "graphrag.llm.base.caching_llm",
        "description": "graphrag.llm.base.caching_llm",
        "isExtraImport": true,
        "detail": "graphrag.llm.base.caching_llm",
        "documentation": {}
    },
    {
        "label": "OpenAIHistoryTrackingLLM",
        "importPath": "graphrag.llm.openai.openai_history_tracking_llm",
        "description": "graphrag.llm.openai.openai_history_tracking_llm",
        "isExtraImport": true,
        "detail": "graphrag.llm.openai.openai_history_tracking_llm",
        "documentation": {}
    },
    {
        "label": "OpenAIHistoryTrackingLLM",
        "importPath": "graphrag.llm.openai.openai_history_tracking_llm",
        "description": "graphrag.llm.openai.openai_history_tracking_llm",
        "isExtraImport": true,
        "detail": "graphrag.llm.openai.openai_history_tracking_llm",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_base_documents",
        "description": "graphrag.index.workflows.v1.create_base_documents",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_base_documents",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_base_documents",
        "description": "graphrag.index.workflows.v1.create_base_documents",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_base_documents",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_base_entity_graph",
        "description": "graphrag.index.workflows.v1.create_base_entity_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_base_entity_graph",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_base_entity_graph",
        "description": "graphrag.index.workflows.v1.create_base_entity_graph",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_base_entity_graph",
        "documentation": {}
    },
    {
        "label": "VerbParallelizationError",
        "importPath": "datashaper.errors",
        "description": "datashaper.errors",
        "isExtraImport": true,
        "detail": "datashaper.errors",
        "documentation": {}
    },
    {
        "label": "VerbParallelizationError",
        "importPath": "datashaper.errors",
        "description": "datashaper.errors",
        "isExtraImport": true,
        "detail": "datashaper.errors",
        "documentation": {}
    },
    {
        "label": "VerbParallelizationError",
        "importPath": "datashaper.errors",
        "description": "datashaper.errors",
        "isExtraImport": true,
        "detail": "datashaper.errors",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "description": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "description": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_base_text_units",
        "description": "graphrag.index.workflows.v1.create_base_text_units",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_base_text_units",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_base_text_units",
        "description": "graphrag.index.workflows.v1.create_base_text_units",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_base_text_units",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_final_communities",
        "description": "graphrag.index.workflows.v1.create_final_communities",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_communities",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_final_communities",
        "description": "graphrag.index.workflows.v1.create_final_communities",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_communities",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_final_community_reports",
        "description": "graphrag.index.workflows.v1.create_final_community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_community_reports",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_final_community_reports",
        "description": "graphrag.index.workflows.v1.create_final_community_reports",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_community_reports",
        "documentation": {}
    },
    {
        "label": "assert_series_equal",
        "importPath": "pandas.testing",
        "description": "pandas.testing",
        "isExtraImport": true,
        "detail": "pandas.testing",
        "documentation": {}
    },
    {
        "label": "assert_series_equal",
        "importPath": "pandas.testing",
        "description": "pandas.testing",
        "isExtraImport": true,
        "detail": "pandas.testing",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_final_covariates",
        "description": "graphrag.index.workflows.v1.create_final_covariates",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_covariates",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_final_covariates",
        "description": "graphrag.index.workflows.v1.create_final_covariates",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_covariates",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_final_documents",
        "description": "graphrag.index.workflows.v1.create_final_documents",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_documents",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_final_documents",
        "description": "graphrag.index.workflows.v1.create_final_documents",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_documents",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_final_entities",
        "description": "graphrag.index.workflows.v1.create_final_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_entities",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_final_entities",
        "description": "graphrag.index.workflows.v1.create_final_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_entities",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_final_nodes",
        "description": "graphrag.index.workflows.v1.create_final_nodes",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_nodes",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_final_nodes",
        "description": "graphrag.index.workflows.v1.create_final_nodes",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_nodes",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_final_relationships",
        "description": "graphrag.index.workflows.v1.create_final_relationships",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_relationships",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_final_relationships",
        "description": "graphrag.index.workflows.v1.create_final_relationships",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_relationships",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_final_text_units",
        "description": "graphrag.index.workflows.v1.create_final_text_units",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_text_units",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_final_text_units",
        "description": "graphrag.index.workflows.v1.create_final_text_units",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_final_text_units",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "importPath": "graphrag.index.workflows.v1.create_summarized_entities",
        "description": "graphrag.index.workflows.v1.create_summarized_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_summarized_entities",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "importPath": "graphrag.index.workflows.v1.create_summarized_entities",
        "description": "graphrag.index.workflows.v1.create_summarized_entities",
        "isExtraImport": true,
        "detail": "graphrag.index.workflows.v1.create_summarized_entities",
        "documentation": {}
    },
    {
        "label": "pipeline_file",
        "kind": 5,
        "importPath": "examples.custom_input.run",
        "description": "examples.custom_input.run",
        "peekOfCode": "pipeline_file = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), \"./pipeline.yml\"\n)\nasync def run():\n    # Load your dataset\n    dataset = _load_dataset_some_unique_way()\n    # Load your config without the input section\n    config = pipeline_file\n    # Grab the last result from the pipeline, should be our entity extraction\n    outputs = []",
        "detail": "examples.custom_input.run",
        "documentation": {}
    },
    {
        "label": "str_append",
        "kind": 2,
        "importPath": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "description": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "peekOfCode": "def str_append(\n    input: VerbInput, source_column: str, target_column: str, string_to_append: str\n):\n    \"\"\"A custom verb that appends a string to a column\"\"\"\n    # by convention, we typically use \"column\" as the input column name and \"to\" as the output column name, but you can use whatever you want\n    # just as long as the \"args\" in the workflow reference match the function signature\n    input_data = input.get_input()\n    output_df = input_data.copy()\n    output_df[target_column] = output_df[source_column].apply(\n        lambda x: f\"{x}{string_to_append}\"",
        "detail": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "documentation": {}
    },
    {
        "label": "custom_verbs",
        "kind": 5,
        "importPath": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "description": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "peekOfCode": "custom_verbs = {\n    \"str_append\": str_append,\n}",
        "detail": "examples.custom_set_of_available_verbs.custom_verb_definitions",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "examples.custom_set_of_available_verbs.run",
        "description": "examples.custom_set_of_available_verbs.run",
        "peekOfCode": "dataset = pd.DataFrame([{\"col1\": 2, \"col2\": 4}, {\"col1\": 5, \"col2\": 10}])\nasync def run_with_config():\n    \"\"\"Run a pipeline with a config file\"\"\"\n    # load pipeline.yml in this directory\n    config_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"./pipeline.yml\"\n    )\n    outputs = []\n    async for output in run_pipeline_with_config(\n        config_or_path=config_path, dataset=dataset",
        "detail": "examples.custom_set_of_available_verbs.run",
        "documentation": {}
    },
    {
        "label": "sample_data_dir",
        "kind": 5,
        "importPath": "examples.custom_set_of_available_workflows.run",
        "description": "examples.custom_set_of_available_workflows.run",
        "peekOfCode": "sample_data_dir = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), \"../_sample_data/\"\n)\n# our fake dataset\ndataset = pd.DataFrame([{\"col1\": 2, \"col2\": 4}, {\"col1\": 5, \"col2\": 10}])\nasync def run_with_config():\n    \"\"\"Run a pipeline with a config file\"\"\"\n    # load pipeline.yml in this directory\n    config_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"./pipeline.yml\"",
        "detail": "examples.custom_set_of_available_workflows.run",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "examples.custom_set_of_available_workflows.run",
        "description": "examples.custom_set_of_available_workflows.run",
        "peekOfCode": "dataset = pd.DataFrame([{\"col1\": 2, \"col2\": 4}, {\"col1\": 5, \"col2\": 10}])\nasync def run_with_config():\n    \"\"\"Run a pipeline with a config file\"\"\"\n    # load pipeline.yml in this directory\n    config_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"./pipeline.yml\"\n    )\n    # Grab the last result from the pipeline, should be our entity extraction\n    tables = []\n    async for table in run_pipeline_with_config(",
        "detail": "examples.custom_set_of_available_workflows.run",
        "documentation": {}
    },
    {
        "label": "sample_data_dir",
        "kind": 5,
        "importPath": "examples.entity_extraction.with_graph_intelligence.run",
        "description": "examples.entity_extraction.with_graph_intelligence.run",
        "peekOfCode": "sample_data_dir = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), \"../../_sample_data/\"\n)\nshared_dataset = asyncio.run(\n    load_input(\n        PipelineCSVInputConfig(\n            file_pattern=\".*\\\\.csv$\",\n            base_dir=sample_data_dir,\n            source_column=\"author\",\n            text_column=\"message\",",
        "detail": "examples.entity_extraction.with_graph_intelligence.run",
        "documentation": {}
    },
    {
        "label": "shared_dataset",
        "kind": 5,
        "importPath": "examples.entity_extraction.with_graph_intelligence.run",
        "description": "examples.entity_extraction.with_graph_intelligence.run",
        "peekOfCode": "shared_dataset = asyncio.run(\n    load_input(\n        PipelineCSVInputConfig(\n            file_pattern=\".*\\\\.csv$\",\n            base_dir=sample_data_dir,\n            source_column=\"author\",\n            text_column=\"message\",\n            timestamp_column=\"date(yyyyMMddHHmmss)\",\n            timestamp_format=\"%Y%m%d%H%M%S\",\n            title_column=\"message\",",
        "detail": "examples.entity_extraction.with_graph_intelligence.run",
        "documentation": {}
    },
    {
        "label": "sample_data_dir",
        "kind": 5,
        "importPath": "examples.entity_extraction.with_nltk.run",
        "description": "examples.entity_extraction.with_nltk.run",
        "peekOfCode": "sample_data_dir = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), \"../../_sample_data/\"\n)\nshared_dataset = asyncio.run(\n    load_input(\n        PipelineCSVInputConfig(\n            file_pattern=\".*\\\\.csv$\",\n            base_dir=sample_data_dir,\n            source_column=\"author\",\n            text_column=\"message\",",
        "detail": "examples.entity_extraction.with_nltk.run",
        "documentation": {}
    },
    {
        "label": "shared_dataset",
        "kind": 5,
        "importPath": "examples.entity_extraction.with_nltk.run",
        "description": "examples.entity_extraction.with_nltk.run",
        "peekOfCode": "shared_dataset = asyncio.run(\n    load_input(\n        PipelineCSVInputConfig(\n            file_pattern=\".*\\\\.csv$\",\n            base_dir=sample_data_dir,\n            source_column=\"author\",\n            text_column=\"message\",\n            timestamp_column=\"date(yyyyMMddHHmmss)\",\n            timestamp_format=\"%Y%m%d%H%M%S\",\n            title_column=\"message\",",
        "detail": "examples.entity_extraction.with_nltk.run",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "examples.interdependent_workflows.run",
        "description": "examples.interdependent_workflows.run",
        "peekOfCode": "dataset = pd.DataFrame([\n    {\"type\": \"A\", \"col1\": 2, \"col2\": 4},\n    {\"type\": \"A\", \"col1\": 5, \"col2\": 10},\n    {\"type\": \"A\", \"col1\": 15, \"col2\": 26},\n    {\"type\": \"B\", \"col1\": 6, \"col2\": 15},\n])\nasync def run_with_config():\n    \"\"\"Run a pipeline with a config file\"\"\"\n    # load pipeline.yml in this directory\n    config_path = os.path.join(",
        "detail": "examples.interdependent_workflows.run",
        "documentation": {}
    },
    {
        "label": "sample_data_dir",
        "kind": 5,
        "importPath": "examples.multiple_workflows.run",
        "description": "examples.multiple_workflows.run",
        "peekOfCode": "sample_data_dir = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), \"./../_sample_data/\"\n)\nasync def run_with_config():\n    dataset = await load_input(\n        PipelineCSVInputConfig(\n            file_pattern=\".*\\\\.csv$\",\n            base_dir=sample_data_dir,\n            source_column=\"author\",\n            text_column=\"message\",",
        "detail": "examples.multiple_workflows.run",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "examples.single_verb.run",
        "description": "examples.single_verb.run",
        "peekOfCode": "dataset = pd.DataFrame([{\"col1\": 2, \"col2\": 4}, {\"col1\": 5, \"col2\": 10}])\nasync def run_with_config():\n    \"\"\"Run a pipeline with a config file\"\"\"\n    # load pipeline.yml in this directory\n    config_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"./pipeline.yml\"\n    )\n    tables = []\n    async for table in run_pipeline_with_config(\n        config_or_path=config_path, dataset=dataset",
        "detail": "examples.single_verb.run",
        "documentation": {}
    },
    {
        "label": "sample_data_dir",
        "kind": 5,
        "importPath": "examples.use_built_in_workflows.run",
        "description": "examples.use_built_in_workflows.run",
        "peekOfCode": "sample_data_dir = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), \"../_sample_data/\"\n)\n# Load our dataset once\nshared_dataset = asyncio.run(\n    load_input(\n        PipelineCSVInputConfig(\n            file_pattern=\".*\\\\.csv$\",\n            base_dir=sample_data_dir,\n            source_column=\"author\",",
        "detail": "examples.use_built_in_workflows.run",
        "documentation": {}
    },
    {
        "label": "shared_dataset",
        "kind": 5,
        "importPath": "examples.use_built_in_workflows.run",
        "description": "examples.use_built_in_workflows.run",
        "peekOfCode": "shared_dataset = asyncio.run(\n    load_input(\n        PipelineCSVInputConfig(\n            file_pattern=\".*\\\\.csv$\",\n            base_dir=sample_data_dir,\n            source_column=\"author\",\n            text_column=\"message\",\n            timestamp_column=\"date(yyyyMMddHHmmss)\",\n            timestamp_format=\"%Y%m%d%H%M%S\",\n            title_column=\"message\",",
        "detail": "examples.use_built_in_workflows.run",
        "documentation": {}
    },
    {
        "label": "ExampleStorage",
        "kind": 6,
        "importPath": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "description": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "peekOfCode": "class ExampleStorage(MemoryPipelineStorage):\n    \"\"\"Example of a custom storage handler\"\"\"\n    async def get(\n        self, key: str, as_bytes: bool | None = None, encoding: str | None = None\n    ) -> Any:\n        print(f\"ExampleStorage.get {key}\")\n        return await super().get(key, as_bytes)\n    async def set(\n        self, key: str, value: str | bytes | None, encoding: str | None = None\n    ) -> None:",
        "detail": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "documentation": {}
    },
    {
        "label": "ExampleCache",
        "kind": 6,
        "importPath": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "description": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "peekOfCode": "class ExampleCache(InMemoryCache):\n    \"\"\"Example of a custom cache handler\"\"\"\n    async def get(self, key: str) -> Any:\n        print(f\"ExampleCache.get {key}\")\n        return await super().get(key)\n    async def set(self, key: str, value: Any, debug_data: dict | None = None) -> None:\n        print(f\"ExampleCache.set {key}\")\n        return await super().set(key, value, debug_data)\n    async def has(self, key: str) -> bool:\n        print(f\"ExampleCache.has {key}\")",
        "detail": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "documentation": {}
    },
    {
        "label": "ExampleReporter",
        "kind": 6,
        "importPath": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "description": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "peekOfCode": "class ExampleReporter(NoopWorkflowCallbacks):\n    \"\"\"Example of a custom reporter.  This will print out all of the status updates from the pipeline.\"\"\"\n    def progress(self, progress: Progress):\n        print(\"ExampleReporter.progress: \", progress)\n    def error(self, message: str, details: dict[str, Any] | None = None):\n        print(\"ExampleReporter.error: \", message)\n    def warning(self, message: str, details: dict[str, Any] | None = None):\n        print(\"ExampleReporter.warning: \", message)\n    def log(self, message: str, details: dict[str, Any] | None = None):\n        print(\"ExampleReporter.log: \", message)",
        "detail": "examples.various_levels_of_configs.workflows_and_inputs_with_custom_handlers",
        "documentation": {}
    },
    {
        "label": "sample_data_dir",
        "kind": 5,
        "importPath": "examples.various_levels_of_configs.workflows_only",
        "description": "examples.various_levels_of_configs.workflows_only",
        "peekOfCode": "sample_data_dir = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), \"../_sample_data/\"\n)\nasync def main():\n    if (\n        \"EXAMPLE_OPENAI_API_KEY\" not in os.environ\n        and \"OPENAI_API_KEY\" not in os.environ\n    ):\n        msg = \"Please set EXAMPLE_OPENAI_API_KEY or OPENAI_API_KEY environment variable to run this example\"\n        raise Exception(msg)",
        "detail": "examples.various_levels_of_configs.workflows_only",
        "documentation": {}
    },
    {
        "label": "reporter",
        "kind": 5,
        "importPath": "graphrag.api.query_api",
        "description": "graphrag.api.query_api",
        "peekOfCode": "reporter = PrintProgressReporter(\"\")\n@validate_call(config={\"arbitrary_types_allowed\": True})\nasync def global_search(\n    config: GraphRagConfig,\n    nodes: pd.DataFrame,\n    entities: pd.DataFrame,\n    community_reports: pd.DataFrame,\n    community_level: int,\n    response_type: str,\n    query: str,",
        "detail": "graphrag.api.query_api",
        "documentation": {}
    },
    {
        "label": "BlobWorkflowCallbacks",
        "kind": 6,
        "importPath": "graphrag.callbacks.blob_workflow_callbacks",
        "description": "graphrag.callbacks.blob_workflow_callbacks",
        "peekOfCode": "class BlobWorkflowCallbacks(NoopWorkflowCallbacks):\n    \"\"\"A logger that writes to a blob storage account.\"\"\"\n    _blob_service_client: BlobServiceClient\n    _container_name: str\n    _max_block_count: int = 25000  # 25k blocks per blob\n    def __init__(\n        self,\n        connection_string: str | None,\n        container_name: str,\n        blob_name: str = \"\",",
        "detail": "graphrag.callbacks.blob_workflow_callbacks",
        "documentation": {}
    },
    {
        "label": "ConsoleWorkflowCallbacks",
        "kind": 6,
        "importPath": "graphrag.callbacks.console_workflow_callbacks",
        "description": "graphrag.callbacks.console_workflow_callbacks",
        "peekOfCode": "class ConsoleWorkflowCallbacks(NoopWorkflowCallbacks):\n    \"\"\"A logger that writes to a console.\"\"\"\n    def on_error(\n        self,\n        message: str,\n        cause: BaseException | None = None,\n        stack: str | None = None,\n        details: dict | None = None,\n    ):\n        \"\"\"Handle when an error occurs.\"\"\"",
        "detail": "graphrag.callbacks.console_workflow_callbacks",
        "documentation": {}
    },
    {
        "label": "create_pipeline_reporter",
        "kind": 2,
        "importPath": "graphrag.callbacks.factories",
        "description": "graphrag.callbacks.factories",
        "peekOfCode": "def create_pipeline_reporter(\n    config: PipelineReportingConfig | None, root_dir: str | None\n) -> WorkflowCallbacks:\n    \"\"\"Create a reporter for the given pipeline config.\"\"\"\n    config = config or PipelineFileReportingConfig(base_dir=\"logs\")\n    match config.type:\n        case ReportingType.file:\n            config = cast(PipelineFileReportingConfig, config)\n            return FileWorkflowCallbacks(\n                str(Path(root_dir or \"\") / (config.base_dir or \"\"))",
        "detail": "graphrag.callbacks.factories",
        "documentation": {}
    },
    {
        "label": "FileWorkflowCallbacks",
        "kind": 6,
        "importPath": "graphrag.callbacks.file_workflow_callbacks",
        "description": "graphrag.callbacks.file_workflow_callbacks",
        "peekOfCode": "class FileWorkflowCallbacks(NoopWorkflowCallbacks):\n    \"\"\"A logger that writes to a local file.\"\"\"\n    _out_stream: TextIOWrapper\n    def __init__(self, directory: str):\n        \"\"\"Create a new file-based workflow logger.\"\"\"\n        Path(directory).mkdir(parents=True, exist_ok=True)\n        self._out_stream = open(  # noqa: PTH123, SIM115\n            Path(directory) / \"logs.json\", \"a\", encoding=\"utf-8\", errors=\"strict\"\n        )\n    def on_error(",
        "detail": "graphrag.callbacks.file_workflow_callbacks",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.callbacks.file_workflow_callbacks",
        "description": "graphrag.callbacks.file_workflow_callbacks",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass FileWorkflowCallbacks(NoopWorkflowCallbacks):\n    \"\"\"A logger that writes to a local file.\"\"\"\n    _out_stream: TextIOWrapper\n    def __init__(self, directory: str):\n        \"\"\"Create a new file-based workflow logger.\"\"\"\n        Path(directory).mkdir(parents=True, exist_ok=True)\n        self._out_stream = open(  # noqa: PTH123, SIM115\n            Path(directory) / \"logs.json\", \"a\", encoding=\"utf-8\", errors=\"strict\"\n        )",
        "detail": "graphrag.callbacks.file_workflow_callbacks",
        "documentation": {}
    },
    {
        "label": "GlobalSearchLLMCallback",
        "kind": 6,
        "importPath": "graphrag.callbacks.global_search_callbacks",
        "description": "graphrag.callbacks.global_search_callbacks",
        "peekOfCode": "class GlobalSearchLLMCallback(BaseLLMCallback):\n    \"\"\"GlobalSearch LLM Callbacks.\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.map_response_contexts = []\n        self.map_response_outputs = []\n    def on_map_response_start(self, map_response_contexts: list[str]):\n        \"\"\"Handle the start of map response.\"\"\"\n        self.map_response_contexts = map_response_contexts\n    def on_map_response_end(self, map_response_outputs: list[SearchResult]):",
        "detail": "graphrag.callbacks.global_search_callbacks",
        "documentation": {}
    },
    {
        "label": "BaseLLMCallback",
        "kind": 6,
        "importPath": "graphrag.callbacks.llm_callbacks",
        "description": "graphrag.callbacks.llm_callbacks",
        "peekOfCode": "class BaseLLMCallback:\n    \"\"\"Base class for LLM callbacks.\"\"\"\n    def __init__(self):\n        self.response = []\n    def on_llm_new_token(self, token: str):\n        \"\"\"Handle when a new token is generated.\"\"\"\n        self.response.append(token)",
        "detail": "graphrag.callbacks.llm_callbacks",
        "documentation": {}
    },
    {
        "label": "ProgressWorkflowCallbacks",
        "kind": 6,
        "importPath": "graphrag.callbacks.progress_workflow_callbacks",
        "description": "graphrag.callbacks.progress_workflow_callbacks",
        "peekOfCode": "class ProgressWorkflowCallbacks(NoopWorkflowCallbacks):\n    \"\"\"A callbackmanager that delegates to a ProgressReporter.\"\"\"\n    _root_progress: ProgressReporter\n    _progress_stack: list[ProgressReporter]\n    def __init__(self, progress: ProgressReporter) -> None:\n        \"\"\"Create a new ProgressWorkflowCallbacks.\"\"\"\n        self._progress = progress\n        self._progress_stack = [progress]\n    def _pop(self) -> None:\n        self._progress_stack.pop()",
        "detail": "graphrag.callbacks.progress_workflow_callbacks",
        "documentation": {}
    },
    {
        "label": "CacheConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.cache_config_input",
        "description": "graphrag.config.input_models.cache_config_input",
        "peekOfCode": "class CacheConfigInput(TypedDict):\n    \"\"\"The default configuration section for Cache.\"\"\"\n    type: NotRequired[CacheType | str | None]\n    base_dir: NotRequired[str | None]\n    connection_string: NotRequired[str | None]\n    container_name: NotRequired[str | None]\n    storage_account_blob_url: NotRequired[str | None]",
        "detail": "graphrag.config.input_models.cache_config_input",
        "documentation": {}
    },
    {
        "label": "ChunkingConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.chunking_config_input",
        "description": "graphrag.config.input_models.chunking_config_input",
        "peekOfCode": "class ChunkingConfigInput(TypedDict):\n    \"\"\"Configuration section for chunking.\"\"\"\n    size: NotRequired[int | str | None]\n    overlap: NotRequired[int | str | None]\n    group_by_columns: NotRequired[list[str] | str | None]\n    strategy: NotRequired[dict | None]",
        "detail": "graphrag.config.input_models.chunking_config_input",
        "documentation": {}
    },
    {
        "label": "ClaimExtractionConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.claim_extraction_config_input",
        "description": "graphrag.config.input_models.claim_extraction_config_input",
        "peekOfCode": "class ClaimExtractionConfigInput(LLMConfigInput):\n    \"\"\"Configuration section for claim extraction.\"\"\"\n    enabled: NotRequired[bool | None]\n    prompt: NotRequired[str | None]\n    description: NotRequired[str | None]\n    max_gleanings: NotRequired[int | str | None]\n    strategy: NotRequired[dict | None]\n    encoding_model: NotRequired[str | None]",
        "detail": "graphrag.config.input_models.claim_extraction_config_input",
        "documentation": {}
    },
    {
        "label": "ClusterGraphConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.cluster_graph_config_input",
        "description": "graphrag.config.input_models.cluster_graph_config_input",
        "peekOfCode": "class ClusterGraphConfigInput(TypedDict):\n    \"\"\"Configuration section for clustering graphs.\"\"\"\n    max_cluster_size: NotRequired[int | None]\n    strategy: NotRequired[dict | None]",
        "detail": "graphrag.config.input_models.cluster_graph_config_input",
        "documentation": {}
    },
    {
        "label": "CommunityReportsConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.community_reports_config_input",
        "description": "graphrag.config.input_models.community_reports_config_input",
        "peekOfCode": "class CommunityReportsConfigInput(LLMConfigInput):\n    \"\"\"Configuration section for community reports.\"\"\"\n    prompt: NotRequired[str | None]\n    max_length: NotRequired[int | str | None]\n    max_input_length: NotRequired[int | str | None]\n    strategy: NotRequired[dict | None]",
        "detail": "graphrag.config.input_models.community_reports_config_input",
        "documentation": {}
    },
    {
        "label": "EmbedGraphConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.embed_graph_config_input",
        "description": "graphrag.config.input_models.embed_graph_config_input",
        "peekOfCode": "class EmbedGraphConfigInput(TypedDict):\n    \"\"\"The default configuration section for Node2Vec.\"\"\"\n    enabled: NotRequired[bool | str | None]\n    num_walks: NotRequired[int | str | None]\n    walk_length: NotRequired[int | str | None]\n    window_size: NotRequired[int | str | None]\n    iterations: NotRequired[int | str | None]\n    random_seed: NotRequired[int | str | None]\n    strategy: NotRequired[dict | None]",
        "detail": "graphrag.config.input_models.embed_graph_config_input",
        "documentation": {}
    },
    {
        "label": "EntityExtractionConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.entity_extraction_config_input",
        "description": "graphrag.config.input_models.entity_extraction_config_input",
        "peekOfCode": "class EntityExtractionConfigInput(LLMConfigInput):\n    \"\"\"Configuration section for entity extraction.\"\"\"\n    prompt: NotRequired[str | None]\n    entity_types: NotRequired[list[str] | str | None]\n    max_gleanings: NotRequired[int | str | None]\n    strategy: NotRequired[dict | None]\n    encoding_model: NotRequired[str | None]",
        "detail": "graphrag.config.input_models.entity_extraction_config_input",
        "documentation": {}
    },
    {
        "label": "GlobalSearchConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.global_search_config_input",
        "description": "graphrag.config.input_models.global_search_config_input",
        "peekOfCode": "class GlobalSearchConfigInput(TypedDict):\n    \"\"\"The default configuration section for Cache.\"\"\"\n    max_tokens: NotRequired[int | str | None]\n    data_max_tokens: NotRequired[int | str | None]\n    map_max_tokens: NotRequired[int | str | None]\n    reduce_max_tokens: NotRequired[int | str | None]\n    concurrency: NotRequired[int | str | None]",
        "detail": "graphrag.config.input_models.global_search_config_input",
        "documentation": {}
    },
    {
        "label": "GraphRagConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.graphrag_config_input",
        "description": "graphrag.config.input_models.graphrag_config_input",
        "peekOfCode": "class GraphRagConfigInput(LLMConfigInput):\n    \"\"\"Base class for the Default-Configuration parameterization settings.\"\"\"\n    reporting: NotRequired[ReportingConfigInput | None]\n    storage: NotRequired[StorageConfigInput | None]\n    cache: NotRequired[CacheConfigInput | None]\n    input: NotRequired[InputConfigInput | None]\n    embed_graph: NotRequired[EmbedGraphConfigInput | None]\n    embeddings: NotRequired[TextEmbeddingConfigInput | None]\n    chunks: NotRequired[ChunkingConfigInput | None]\n    snapshots: NotRequired[SnapshotsConfigInput | None]",
        "detail": "graphrag.config.input_models.graphrag_config_input",
        "documentation": {}
    },
    {
        "label": "InputConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.input_config_input",
        "description": "graphrag.config.input_models.input_config_input",
        "peekOfCode": "class InputConfigInput(TypedDict):\n    \"\"\"The default configuration section for Input.\"\"\"\n    type: NotRequired[InputType | str | None]\n    file_type: NotRequired[InputFileType | str | None]\n    base_dir: NotRequired[str | None]\n    connection_string: NotRequired[str | None]\n    container_name: NotRequired[str | None]\n    file_encoding: NotRequired[str | None]\n    file_pattern: NotRequired[str | None]\n    source_column: NotRequired[str | None]",
        "detail": "graphrag.config.input_models.input_config_input",
        "documentation": {}
    },
    {
        "label": "LLMConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.llm_config_input",
        "description": "graphrag.config.input_models.llm_config_input",
        "peekOfCode": "class LLMConfigInput(TypedDict):\n    \"\"\"Base class for LLM-configured steps.\"\"\"\n    llm: NotRequired[LLMParametersInput | None]\n    parallelization: NotRequired[ParallelizationParametersInput | None]\n    async_mode: NotRequired[AsyncType | str | None]",
        "detail": "graphrag.config.input_models.llm_config_input",
        "documentation": {}
    },
    {
        "label": "LLMParametersInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.llm_parameters_input",
        "description": "graphrag.config.input_models.llm_parameters_input",
        "peekOfCode": "class LLMParametersInput(TypedDict):\n    \"\"\"LLM Parameters model.\"\"\"\n    api_key: NotRequired[str | None]\n    type: NotRequired[LLMType | str | None]\n    model: NotRequired[str | None]\n    max_tokens: NotRequired[int | str | None]\n    request_timeout: NotRequired[float | str | None]\n    api_base: NotRequired[str | None]\n    api_version: NotRequired[str | None]\n    organization: NotRequired[str | None]",
        "detail": "graphrag.config.input_models.llm_parameters_input",
        "documentation": {}
    },
    {
        "label": "LocalSearchConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.local_search_config_input",
        "description": "graphrag.config.input_models.local_search_config_input",
        "peekOfCode": "class LocalSearchConfigInput(TypedDict):\n    \"\"\"The default configuration section for Cache.\"\"\"\n    text_unit_prop: NotRequired[float | str | None]\n    community_prop: NotRequired[float | str | None]\n    conversation_history_max_turns: NotRequired[int | str | None]\n    top_k_entities: NotRequired[int | str | None]\n    top_k_relationships: NotRequired[int | str | None]\n    max_tokens: NotRequired[int | str | None]\n    llm_max_tokens: NotRequired[int | str | None]",
        "detail": "graphrag.config.input_models.local_search_config_input",
        "documentation": {}
    },
    {
        "label": "ParallelizationParametersInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.parallelization_parameters_input",
        "description": "graphrag.config.input_models.parallelization_parameters_input",
        "peekOfCode": "class ParallelizationParametersInput(TypedDict):\n    \"\"\"LLM Parameters model.\"\"\"\n    stagger: NotRequired[float | str | None]\n    num_threads: NotRequired[int | str | None]",
        "detail": "graphrag.config.input_models.parallelization_parameters_input",
        "documentation": {}
    },
    {
        "label": "ReportingConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.reporting_config_input",
        "description": "graphrag.config.input_models.reporting_config_input",
        "peekOfCode": "class ReportingConfigInput(TypedDict):\n    \"\"\"The default configuration section for Reporting.\"\"\"\n    type: NotRequired[ReportingType | str | None]\n    base_dir: NotRequired[str | None]\n    connection_string: NotRequired[str | None]\n    container_name: NotRequired[str | None]\n    storage_account_blob_url: NotRequired[str | None]",
        "detail": "graphrag.config.input_models.reporting_config_input",
        "documentation": {}
    },
    {
        "label": "SnapshotsConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.snapshots_config_input",
        "description": "graphrag.config.input_models.snapshots_config_input",
        "peekOfCode": "class SnapshotsConfigInput(TypedDict):\n    \"\"\"Configuration section for snapshots.\"\"\"\n    graphml: NotRequired[bool | str | None]\n    raw_entities: NotRequired[bool | str | None]\n    top_level_nodes: NotRequired[bool | str | None]",
        "detail": "graphrag.config.input_models.snapshots_config_input",
        "documentation": {}
    },
    {
        "label": "StorageConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.storage_config_input",
        "description": "graphrag.config.input_models.storage_config_input",
        "peekOfCode": "class StorageConfigInput(TypedDict):\n    \"\"\"The default configuration section for Storage.\"\"\"\n    type: NotRequired[StorageType | str | None]\n    base_dir: NotRequired[str | None]\n    connection_string: NotRequired[str | None]\n    container_name: NotRequired[str | None]\n    storage_account_blob_url: NotRequired[str | None]",
        "detail": "graphrag.config.input_models.storage_config_input",
        "documentation": {}
    },
    {
        "label": "SummarizeDescriptionsConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.summarize_descriptions_config_input",
        "description": "graphrag.config.input_models.summarize_descriptions_config_input",
        "peekOfCode": "class SummarizeDescriptionsConfigInput(LLMConfigInput):\n    \"\"\"Configuration section for description summarization.\"\"\"\n    prompt: NotRequired[str | None]\n    max_length: NotRequired[int | str | None]\n    strategy: NotRequired[dict | None]",
        "detail": "graphrag.config.input_models.summarize_descriptions_config_input",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.text_embedding_config_input",
        "description": "graphrag.config.input_models.text_embedding_config_input",
        "peekOfCode": "class TextEmbeddingConfigInput(LLMConfigInput):\n    \"\"\"Configuration section for text embeddings.\"\"\"\n    batch_size: NotRequired[int | str | None]\n    batch_max_tokens: NotRequired[int | str | None]\n    target: NotRequired[TextEmbeddingTarget | str | None]\n    skip: NotRequired[list[str] | str | None]\n    vector_store: NotRequired[dict | None]\n    strategy: NotRequired[dict | None]",
        "detail": "graphrag.config.input_models.text_embedding_config_input",
        "documentation": {}
    },
    {
        "label": "UmapConfigInput",
        "kind": 6,
        "importPath": "graphrag.config.input_models.umap_config_input",
        "description": "graphrag.config.input_models.umap_config_input",
        "peekOfCode": "class UmapConfigInput(TypedDict):\n    \"\"\"Configuration section for UMAP.\"\"\"\n    enabled: NotRequired[bool | str | None]",
        "detail": "graphrag.config.input_models.umap_config_input",
        "documentation": {}
    },
    {
        "label": "CacheConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.cache_config",
        "description": "graphrag.config.models.cache_config",
        "peekOfCode": "class CacheConfig(BaseModel):\n    \"\"\"The default configuration section for Cache.\"\"\"\n    type: CacheType = Field(\n        description=\"The cache type to use.\", default=defs.CACHE_TYPE\n    )\n    base_dir: str = Field(\n        description=\"The base directory for the cache.\", default=defs.CACHE_BASE_DIR\n    )\n    connection_string: str | None = Field(\n        description=\"The cache connection string to use.\", default=None",
        "detail": "graphrag.config.models.cache_config",
        "documentation": {}
    },
    {
        "label": "ChunkingConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.chunking_config",
        "description": "graphrag.config.models.chunking_config",
        "peekOfCode": "class ChunkingConfig(BaseModel):\n    \"\"\"Configuration section for chunking.\"\"\"\n    size: int = Field(description=\"The chunk size to use.\", default=defs.CHUNK_SIZE)\n    overlap: int = Field(\n        description=\"The chunk overlap to use.\", default=defs.CHUNK_OVERLAP\n    )\n    group_by_columns: list[str] = Field(\n        description=\"The chunk by columns to use.\",\n        default=defs.CHUNK_GROUP_BY_COLUMNS,\n    )",
        "detail": "graphrag.config.models.chunking_config",
        "documentation": {}
    },
    {
        "label": "ClaimExtractionConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.claim_extraction_config",
        "description": "graphrag.config.models.claim_extraction_config",
        "peekOfCode": "class ClaimExtractionConfig(LLMConfig):\n    \"\"\"Configuration section for claim extraction.\"\"\"\n    enabled: bool = Field(\n        description=\"Whether claim extraction is enabled.\",\n    )\n    prompt: str | None = Field(\n        description=\"The claim extraction prompt to use.\", default=None\n    )\n    description: str = Field(\n        description=\"The claim description to use.\",",
        "detail": "graphrag.config.models.claim_extraction_config",
        "documentation": {}
    },
    {
        "label": "ClusterGraphConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.cluster_graph_config",
        "description": "graphrag.config.models.cluster_graph_config",
        "peekOfCode": "class ClusterGraphConfig(BaseModel):\n    \"\"\"Configuration section for clustering graphs.\"\"\"\n    max_cluster_size: int = Field(\n        description=\"The maximum cluster size to use.\", default=defs.MAX_CLUSTER_SIZE\n    )\n    strategy: dict | None = Field(\n        description=\"The cluster strategy to use.\", default=None\n    )\n    def resolved_strategy(self) -> dict:\n        \"\"\"Get the resolved cluster strategy.\"\"\"",
        "detail": "graphrag.config.models.cluster_graph_config",
        "documentation": {}
    },
    {
        "label": "CommunityReportsConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.community_reports_config",
        "description": "graphrag.config.models.community_reports_config",
        "peekOfCode": "class CommunityReportsConfig(LLMConfig):\n    \"\"\"Configuration section for community reports.\"\"\"\n    prompt: str | None = Field(\n        description=\"The community report extraction prompt to use.\", default=None\n    )\n    max_length: int = Field(\n        description=\"The community report maximum length in tokens.\",\n        default=defs.COMMUNITY_REPORT_MAX_LENGTH,\n    )\n    max_input_length: int = Field(",
        "detail": "graphrag.config.models.community_reports_config",
        "documentation": {}
    },
    {
        "label": "EmbedGraphConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.embed_graph_config",
        "description": "graphrag.config.models.embed_graph_config",
        "peekOfCode": "class EmbedGraphConfig(BaseModel):\n    \"\"\"The default configuration section for Node2Vec.\"\"\"\n    enabled: bool = Field(\n        description=\"A flag indicating whether to enable node2vec.\",\n        default=defs.NODE2VEC_ENABLED,\n    )\n    num_walks: int = Field(\n        description=\"The node2vec number of walks.\", default=defs.NODE2VEC_NUM_WALKS\n    )\n    walk_length: int = Field(",
        "detail": "graphrag.config.models.embed_graph_config",
        "documentation": {}
    },
    {
        "label": "EntityExtractionConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.entity_extraction_config",
        "description": "graphrag.config.models.entity_extraction_config",
        "peekOfCode": "class EntityExtractionConfig(LLMConfig):\n    \"\"\"Configuration section for entity extraction.\"\"\"\n    prompt: str | None = Field(\n        description=\"The entity extraction prompt to use.\", default=None\n    )\n    entity_types: list[str] = Field(\n        description=\"The entity extraction entity types to use.\",\n        default=defs.ENTITY_EXTRACTION_ENTITY_TYPES,\n    )\n    max_gleanings: int = Field(",
        "detail": "graphrag.config.models.entity_extraction_config",
        "documentation": {}
    },
    {
        "label": "GlobalSearchConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.global_search_config",
        "description": "graphrag.config.models.global_search_config",
        "peekOfCode": "class GlobalSearchConfig(BaseModel):\n    \"\"\"The default configuration section for Cache.\"\"\"\n    temperature: float | None = Field(\n        description=\"The temperature to use for token generation.\",\n        default=defs.GLOBAL_SEARCH_LLM_TEMPERATURE,\n    )\n    top_p: float | None = Field(\n        description=\"The top-p value to use for token generation.\",\n        default=defs.GLOBAL_SEARCH_LLM_TOP_P,\n    )",
        "detail": "graphrag.config.models.global_search_config",
        "documentation": {}
    },
    {
        "label": "GraphRagConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.graph_rag_config",
        "description": "graphrag.config.models.graph_rag_config",
        "peekOfCode": "class GraphRagConfig(LLMConfig):\n    \"\"\"Base class for the Default-Configuration parameterization settings.\"\"\"\n    def __repr__(self) -> str:\n        \"\"\"Get a string representation.\"\"\"\n        return pformat(self, highlight=False)\n    def __str__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return self.model_dump_json(indent=4)\n    root_dir: str = Field(\n        description=\"The root directory for the configuration.\", default=None",
        "detail": "graphrag.config.models.graph_rag_config",
        "documentation": {}
    },
    {
        "label": "InputConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.input_config",
        "description": "graphrag.config.models.input_config",
        "peekOfCode": "class InputConfig(BaseModel):\n    \"\"\"The default configuration section for Input.\"\"\"\n    type: InputType = Field(\n        description=\"The input type to use.\", default=defs.INPUT_TYPE\n    )\n    file_type: InputFileType = Field(\n        description=\"The input file type to use.\", default=defs.INPUT_FILE_TYPE\n    )\n    base_dir: str = Field(\n        description=\"The input base directory to use.\", default=defs.INPUT_BASE_DIR",
        "detail": "graphrag.config.models.input_config",
        "documentation": {}
    },
    {
        "label": "LLMConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.llm_config",
        "description": "graphrag.config.models.llm_config",
        "peekOfCode": "class LLMConfig(BaseModel):\n    \"\"\"Base class for LLM-configured steps.\"\"\"\n    llm: LLMParameters = Field(\n        description=\"The LLM configuration to use.\", default=LLMParameters()\n    )\n    parallelization: ParallelizationParameters = Field(\n        description=\"The parallelization configuration to use.\",\n        default=ParallelizationParameters(),\n    )\n    async_mode: AsyncType = Field(",
        "detail": "graphrag.config.models.llm_config",
        "documentation": {}
    },
    {
        "label": "LLMParameters",
        "kind": 6,
        "importPath": "graphrag.config.models.llm_parameters",
        "description": "graphrag.config.models.llm_parameters",
        "peekOfCode": "class LLMParameters(BaseModel):\n    \"\"\"LLM Parameters model.\"\"\"\n    model_config = ConfigDict(protected_namespaces=(), extra=\"allow\")\n    api_key: str | None = Field(\n        description=\"The API key to use for the LLM service.\",\n        default=None,\n    )\n    type: LLMType = Field(\n        description=\"The type of LLM model to use.\", default=defs.LLM_TYPE\n    )",
        "detail": "graphrag.config.models.llm_parameters",
        "documentation": {}
    },
    {
        "label": "LocalSearchConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.local_search_config",
        "description": "graphrag.config.models.local_search_config",
        "peekOfCode": "class LocalSearchConfig(BaseModel):\n    \"\"\"The default configuration section for Cache.\"\"\"\n    text_unit_prop: float = Field(\n        description=\"The text unit proportion.\",\n        default=defs.LOCAL_SEARCH_TEXT_UNIT_PROP,\n    )\n    community_prop: float = Field(\n        description=\"The community proportion.\",\n        default=defs.LOCAL_SEARCH_COMMUNITY_PROP,\n    )",
        "detail": "graphrag.config.models.local_search_config",
        "documentation": {}
    },
    {
        "label": "ParallelizationParameters",
        "kind": 6,
        "importPath": "graphrag.config.models.parallelization_parameters",
        "description": "graphrag.config.models.parallelization_parameters",
        "peekOfCode": "class ParallelizationParameters(BaseModel):\n    \"\"\"LLM Parameters model.\"\"\"\n    stagger: float = Field(\n        description=\"The stagger to use for the LLM service.\",\n        default=defs.PARALLELIZATION_STAGGER,\n    )\n    num_threads: int = Field(\n        description=\"The number of threads to use for the LLM service.\",\n        default=defs.PARALLELIZATION_NUM_THREADS,\n    )",
        "detail": "graphrag.config.models.parallelization_parameters",
        "documentation": {}
    },
    {
        "label": "ReportingConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.reporting_config",
        "description": "graphrag.config.models.reporting_config",
        "peekOfCode": "class ReportingConfig(BaseModel):\n    \"\"\"The default configuration section for Reporting.\"\"\"\n    type: ReportingType = Field(\n        description=\"The reporting type to use.\", default=defs.REPORTING_TYPE\n    )\n    base_dir: str = Field(\n        description=\"The base directory for reporting.\",\n        default=defs.REPORTING_BASE_DIR,\n    )\n    connection_string: str | None = Field(",
        "detail": "graphrag.config.models.reporting_config",
        "documentation": {}
    },
    {
        "label": "SnapshotsConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.snapshots_config",
        "description": "graphrag.config.models.snapshots_config",
        "peekOfCode": "class SnapshotsConfig(BaseModel):\n    \"\"\"Configuration section for snapshots.\"\"\"\n    graphml: bool = Field(\n        description=\"A flag indicating whether to take snapshots of GraphML.\",\n        default=defs.SNAPSHOTS_GRAPHML,\n    )\n    raw_entities: bool = Field(\n        description=\"A flag indicating whether to take snapshots of raw entities.\",\n        default=defs.SNAPSHOTS_RAW_ENTITIES,\n    )",
        "detail": "graphrag.config.models.snapshots_config",
        "documentation": {}
    },
    {
        "label": "StorageConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.storage_config",
        "description": "graphrag.config.models.storage_config",
        "peekOfCode": "class StorageConfig(BaseModel):\n    \"\"\"The default configuration section for Storage.\"\"\"\n    type: StorageType = Field(\n        description=\"The storage type to use.\", default=defs.STORAGE_TYPE\n    )\n    base_dir: str = Field(\n        description=\"The base directory for the storage.\",\n        default=defs.STORAGE_BASE_DIR,\n    )\n    connection_string: str | None = Field(",
        "detail": "graphrag.config.models.storage_config",
        "documentation": {}
    },
    {
        "label": "SummarizeDescriptionsConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.summarize_descriptions_config",
        "description": "graphrag.config.models.summarize_descriptions_config",
        "peekOfCode": "class SummarizeDescriptionsConfig(LLMConfig):\n    \"\"\"Configuration section for description summarization.\"\"\"\n    prompt: str | None = Field(\n        description=\"The description summarization prompt to use.\", default=None\n    )\n    max_length: int = Field(\n        description=\"The description summarization maximum length.\",\n        default=defs.SUMMARIZE_DESCRIPTIONS_MAX_LENGTH,\n    )\n    strategy: dict | None = Field(",
        "detail": "graphrag.config.models.summarize_descriptions_config",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.text_embedding_config",
        "description": "graphrag.config.models.text_embedding_config",
        "peekOfCode": "class TextEmbeddingConfig(LLMConfig):\n    \"\"\"Configuration section for text embeddings.\"\"\"\n    batch_size: int = Field(\n        description=\"The batch size to use.\", default=defs.EMBEDDING_BATCH_SIZE\n    )\n    batch_max_tokens: int = Field(\n        description=\"The batch max tokens to use.\",\n        default=defs.EMBEDDING_BATCH_MAX_TOKENS,\n    )\n    target: TextEmbeddingTarget = Field(",
        "detail": "graphrag.config.models.text_embedding_config",
        "documentation": {}
    },
    {
        "label": "UmapConfig",
        "kind": 6,
        "importPath": "graphrag.config.models.umap_config",
        "description": "graphrag.config.models.umap_config",
        "peekOfCode": "class UmapConfig(BaseModel):\n    \"\"\"Configuration section for UMAP.\"\"\"\n    enabled: bool = Field(\n        description=\"A flag indicating whether to enable UMAP.\",\n        default=defs.UMAP_ENABLED,\n    )",
        "detail": "graphrag.config.models.umap_config",
        "documentation": {}
    },
    {
        "label": "ConfigFileLoader",
        "kind": 6,
        "importPath": "graphrag.config.config_file_loader",
        "description": "graphrag.config.config_file_loader",
        "peekOfCode": "class ConfigFileLoader(ABC):\n    \"\"\"Base class for loading a configuration from a file.\"\"\"\n    @abstractmethod\n    def load_config(self, config_path: str | Path) -> GraphRagConfig:\n        \"\"\"Load configuration from a file.\"\"\"\n        raise NotImplementedError\nclass ConfigYamlLoader(ConfigFileLoader):\n    \"\"\"Load a configuration from a yaml file.\"\"\"\n    def load_config(self, config_path: str | Path) -> GraphRagConfig:\n        \"\"\"Load a configuration from a yaml file.",
        "detail": "graphrag.config.config_file_loader",
        "documentation": {}
    },
    {
        "label": "ConfigYamlLoader",
        "kind": 6,
        "importPath": "graphrag.config.config_file_loader",
        "description": "graphrag.config.config_file_loader",
        "peekOfCode": "class ConfigYamlLoader(ConfigFileLoader):\n    \"\"\"Load a configuration from a yaml file.\"\"\"\n    def load_config(self, config_path: str | Path) -> GraphRagConfig:\n        \"\"\"Load a configuration from a yaml file.\n        Parameters\n        ----------\n        config_path : str | Path\n            The path to the yaml file to load.\n        Returns\n        -------",
        "detail": "graphrag.config.config_file_loader",
        "documentation": {}
    },
    {
        "label": "ConfigJsonLoader",
        "kind": 6,
        "importPath": "graphrag.config.config_file_loader",
        "description": "graphrag.config.config_file_loader",
        "peekOfCode": "class ConfigJsonLoader(ConfigFileLoader):\n    \"\"\"Load a configuration from a json file.\"\"\"\n    def load_config(self, config_path: str | Path) -> GraphRagConfig:\n        \"\"\"Load a configuration from a json file.\n        Parameters\n        ----------\n        config_path : str | Path\n            The path to the json file to load.\n        Returns\n        -------",
        "detail": "graphrag.config.config_file_loader",
        "documentation": {}
    },
    {
        "label": "search_for_config_in_root_dir",
        "kind": 2,
        "importPath": "graphrag.config.config_file_loader",
        "description": "graphrag.config.config_file_loader",
        "peekOfCode": "def search_for_config_in_root_dir(root: str | Path) -> Path | None:\n    \"\"\"Resolve the config path from the given root directory.\n    Parameters\n    ----------\n    root : str | Path\n        The path to the root directory containing the config file.\n        Searches for a default config file (settings.{yaml,yml,json}).\n    Returns\n    -------\n    Path | None",
        "detail": "graphrag.config.config_file_loader",
        "documentation": {}
    },
    {
        "label": "get_config_file_loader",
        "kind": 2,
        "importPath": "graphrag.config.config_file_loader",
        "description": "graphrag.config.config_file_loader",
        "peekOfCode": "def get_config_file_loader(config_path: str | Path) -> ConfigFileLoader:\n    \"\"\"Config File Loader Factory.\n    Parameters\n    ----------\n    config_path : str | Path\n        The path to the config file.\n    Returns\n    -------\n    ConfigFileLoader\n        The config file loader for the provided config file.",
        "detail": "graphrag.config.config_file_loader",
        "documentation": {}
    },
    {
        "label": "load_config_from_file",
        "kind": 2,
        "importPath": "graphrag.config.config_file_loader",
        "description": "graphrag.config.config_file_loader",
        "peekOfCode": "def load_config_from_file(config_path: str | Path) -> GraphRagConfig:\n    \"\"\"Load a configuration from a file.\n    Parameters\n    ----------\n    config_path : str | Path\n        The path to the configuration file.\n        Supports .yaml, .yml, and .json config files.\n    Returns\n    -------\n    GraphRagConfig",
        "detail": "graphrag.config.config_file_loader",
        "documentation": {}
    },
    {
        "label": "_default_config_files",
        "kind": 5,
        "importPath": "graphrag.config.config_file_loader",
        "description": "graphrag.config.config_file_loader",
        "peekOfCode": "_default_config_files = [\"settings.yaml\", \"settings.yml\", \"settings.json\"]\ndef search_for_config_in_root_dir(root: str | Path) -> Path | None:\n    \"\"\"Resolve the config path from the given root directory.\n    Parameters\n    ----------\n    root : str | Path\n        The path to the root directory containing the config file.\n        Searches for a default config file (settings.{yaml,yml,json}).\n    Returns\n    -------",
        "detail": "graphrag.config.config_file_loader",
        "documentation": {}
    },
    {
        "label": "Fragment",
        "kind": 6,
        "importPath": "graphrag.config.create_graphrag_config",
        "description": "graphrag.config.create_graphrag_config",
        "peekOfCode": "class Fragment(str, Enum):\n    \"\"\"Configuration Fragments.\"\"\"\n    api_base = \"API_BASE\"\n    api_key = \"API_KEY\"\n    api_version = \"API_VERSION\"\n    api_organization = \"API_ORGANIZATION\"\n    api_proxy = \"API_PROXY\"\n    async_mode = \"ASYNC_MODE\"\n    base_dir = \"BASE_DIR\"\n    cognitive_services_endpoint = \"COGNITIVE_SERVICES_ENDPOINT\"",
        "detail": "graphrag.config.create_graphrag_config",
        "documentation": {}
    },
    {
        "label": "Section",
        "kind": 6,
        "importPath": "graphrag.config.create_graphrag_config",
        "description": "graphrag.config.create_graphrag_config",
        "peekOfCode": "class Section(str, Enum):\n    \"\"\"Configuration Sections.\"\"\"\n    base = \"BASE\"\n    cache = \"CACHE\"\n    chunk = \"CHUNK\"\n    claim_extraction = \"CLAIM_EXTRACTION\"\n    community_reports = \"COMMUNITY_REPORTS\"\n    embedding = \"EMBEDDING\"\n    entity_extraction = \"ENTITY_EXTRACTION\"\n    graphrag = \"GRAPHRAG\"",
        "detail": "graphrag.config.create_graphrag_config",
        "documentation": {}
    },
    {
        "label": "create_graphrag_config",
        "kind": 2,
        "importPath": "graphrag.config.create_graphrag_config",
        "description": "graphrag.config.create_graphrag_config",
        "peekOfCode": "def create_graphrag_config(\n    values: GraphRagConfigInput | None = None, root_dir: str | None = None\n) -> GraphRagConfig:\n    \"\"\"Load Configuration Parameters from a dictionary.\"\"\"\n    values = values or {}\n    root_dir = root_dir or str(Path.cwd())\n    env = _make_env(root_dir)\n    _token_replace(cast(dict, values))\n    InputModelValidator.validate_python(values, strict=True)\n    reader = EnvironmentReader(env)",
        "detail": "graphrag.config.create_graphrag_config",
        "documentation": {}
    },
    {
        "label": "InputModelValidator",
        "kind": 5,
        "importPath": "graphrag.config.create_graphrag_config",
        "description": "graphrag.config.create_graphrag_config",
        "peekOfCode": "InputModelValidator = TypeAdapter(GraphRagConfigInput)\ndef create_graphrag_config(\n    values: GraphRagConfigInput | None = None, root_dir: str | None = None\n) -> GraphRagConfig:\n    \"\"\"Load Configuration Parameters from a dictionary.\"\"\"\n    values = values or {}\n    root_dir = root_dir or str(Path.cwd())\n    env = _make_env(root_dir)\n    _token_replace(cast(dict, values))\n    InputModelValidator.validate_python(values, strict=True)",
        "detail": "graphrag.config.create_graphrag_config",
        "documentation": {}
    },
    {
        "label": "ASYNC_MODE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "ASYNC_MODE = AsyncType.Threaded\nENCODING_MODEL = \"cl100k_base\"\n#\n# LLM Parameters\n#\nLLM_TYPE = LLMType.OpenAIChat\nLLM_MODEL = \"gpt-4-turbo-preview\"\nLLM_MAX_TOKENS = 4000\nLLM_TEMPERATURE = 0\nLLM_TOP_P = 1",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "ENCODING_MODEL",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "ENCODING_MODEL = \"cl100k_base\"\n#\n# LLM Parameters\n#\nLLM_TYPE = LLMType.OpenAIChat\nLLM_MODEL = \"gpt-4-turbo-preview\"\nLLM_MAX_TOKENS = 4000\nLLM_TEMPERATURE = 0\nLLM_TOP_P = 1\nLLM_N = 1",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_TYPE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_TYPE = LLMType.OpenAIChat\nLLM_MODEL = \"gpt-4-turbo-preview\"\nLLM_MAX_TOKENS = 4000\nLLM_TEMPERATURE = 0\nLLM_TOP_P = 1\nLLM_N = 1\nLLM_REQUEST_TIMEOUT = 180.0\nLLM_TOKENS_PER_MINUTE = 0\nLLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_MODEL",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_MODEL = \"gpt-4-turbo-preview\"\nLLM_MAX_TOKENS = 4000\nLLM_TEMPERATURE = 0\nLLM_TOP_P = 1\nLLM_N = 1\nLLM_REQUEST_TIMEOUT = 180.0\nLLM_TOKENS_PER_MINUTE = 0\nLLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_MAX_TOKENS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_MAX_TOKENS = 4000\nLLM_TEMPERATURE = 0\nLLM_TOP_P = 1\nLLM_N = 1\nLLM_REQUEST_TIMEOUT = 180.0\nLLM_TOKENS_PER_MINUTE = 0\nLLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_TEMPERATURE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_TEMPERATURE = 0\nLLM_TOP_P = 1\nLLM_N = 1\nLLM_REQUEST_TIMEOUT = 180.0\nLLM_TOKENS_PER_MINUTE = 0\nLLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_TOP_P",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_TOP_P = 1\nLLM_N = 1\nLLM_REQUEST_TIMEOUT = 180.0\nLLM_TOKENS_PER_MINUTE = 0\nLLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25\n#",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_N",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_N = 1\nLLM_REQUEST_TIMEOUT = 180.0\nLLM_TOKENS_PER_MINUTE = 0\nLLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25\n#\n# Text Embedding Parameters",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_REQUEST_TIMEOUT",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_REQUEST_TIMEOUT = 180.0\nLLM_TOKENS_PER_MINUTE = 0\nLLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25\n#\n# Text Embedding Parameters\n#",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_TOKENS_PER_MINUTE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_TOKENS_PER_MINUTE = 0\nLLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25\n#\n# Text Embedding Parameters\n#\nEMBEDDING_TYPE = LLMType.OpenAIEmbedding",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_REQUESTS_PER_MINUTE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_REQUESTS_PER_MINUTE = 0\nLLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25\n#\n# Text Embedding Parameters\n#\nEMBEDDING_TYPE = LLMType.OpenAIEmbedding\nEMBEDDING_MODEL = \"text-embedding-3-small\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_MAX_RETRIES",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_MAX_RETRIES = 10\nLLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25\n#\n# Text Embedding Parameters\n#\nEMBEDDING_TYPE = LLMType.OpenAIEmbedding\nEMBEDDING_MODEL = \"text-embedding-3-small\"\nEMBEDDING_BATCH_SIZE = 16",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_MAX_RETRY_WAIT",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_MAX_RETRY_WAIT = 10.0\nLLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25\n#\n# Text Embedding Parameters\n#\nEMBEDDING_TYPE = LLMType.OpenAIEmbedding\nEMBEDDING_MODEL = \"text-embedding-3-small\"\nEMBEDDING_BATCH_SIZE = 16\nEMBEDDING_BATCH_MAX_TOKENS = 8191",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION = True\nLLM_CONCURRENT_REQUESTS = 25\n#\n# Text Embedding Parameters\n#\nEMBEDDING_TYPE = LLMType.OpenAIEmbedding\nEMBEDDING_MODEL = \"text-embedding-3-small\"\nEMBEDDING_BATCH_SIZE = 16\nEMBEDDING_BATCH_MAX_TOKENS = 8191\nEMBEDDING_TARGET = TextEmbeddingTarget.required",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LLM_CONCURRENT_REQUESTS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LLM_CONCURRENT_REQUESTS = 25\n#\n# Text Embedding Parameters\n#\nEMBEDDING_TYPE = LLMType.OpenAIEmbedding\nEMBEDDING_MODEL = \"text-embedding-3-small\"\nEMBEDDING_BATCH_SIZE = 16\nEMBEDDING_BATCH_MAX_TOKENS = 8191\nEMBEDDING_TARGET = TextEmbeddingTarget.required\nCACHE_TYPE = CacheType.file",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_TYPE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "EMBEDDING_TYPE = LLMType.OpenAIEmbedding\nEMBEDDING_MODEL = \"text-embedding-3-small\"\nEMBEDDING_BATCH_SIZE = 16\nEMBEDDING_BATCH_MAX_TOKENS = 8191\nEMBEDDING_TARGET = TextEmbeddingTarget.required\nCACHE_TYPE = CacheType.file\nCACHE_BASE_DIR = \"cache\"\nCHUNK_SIZE = 1200\nCHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_MODEL",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "EMBEDDING_MODEL = \"text-embedding-3-small\"\nEMBEDDING_BATCH_SIZE = 16\nEMBEDDING_BATCH_MAX_TOKENS = 8191\nEMBEDDING_TARGET = TextEmbeddingTarget.required\nCACHE_TYPE = CacheType.file\nCACHE_BASE_DIR = \"cache\"\nCHUNK_SIZE = 1200\nCHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_BATCH_SIZE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "EMBEDDING_BATCH_SIZE = 16\nEMBEDDING_BATCH_MAX_TOKENS = 8191\nEMBEDDING_TARGET = TextEmbeddingTarget.required\nCACHE_TYPE = CacheType.file\nCACHE_BASE_DIR = \"cache\"\nCHUNK_SIZE = 1200\nCHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_BATCH_MAX_TOKENS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "EMBEDDING_BATCH_MAX_TOKENS = 8191\nEMBEDDING_TARGET = TextEmbeddingTarget.required\nCACHE_TYPE = CacheType.file\nCACHE_BASE_DIR = \"cache\"\nCHUNK_SIZE = 1200\nCHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"\n)",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_TARGET",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "EMBEDDING_TARGET = TextEmbeddingTarget.required\nCACHE_TYPE = CacheType.file\nCACHE_BASE_DIR = \"cache\"\nCHUNK_SIZE = 1200\nCHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"\n)\nCLAIM_MAX_GLEANINGS = 1",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CACHE_TYPE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "CACHE_TYPE = CacheType.file\nCACHE_BASE_DIR = \"cache\"\nCHUNK_SIZE = 1200\nCHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"\n)\nCLAIM_MAX_GLEANINGS = 1\nCLAIM_EXTRACTION_ENABLED = False",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CACHE_BASE_DIR",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "CACHE_BASE_DIR = \"cache\"\nCHUNK_SIZE = 1200\nCHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"\n)\nCLAIM_MAX_GLEANINGS = 1\nCLAIM_EXTRACTION_ENABLED = False\nMAX_CLUSTER_SIZE = 10",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CHUNK_SIZE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "CHUNK_SIZE = 1200\nCHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"\n)\nCLAIM_MAX_GLEANINGS = 1\nCLAIM_EXTRACTION_ENABLED = False\nMAX_CLUSTER_SIZE = 10\nCOMMUNITY_REPORT_MAX_LENGTH = 2000",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CHUNK_OVERLAP",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "CHUNK_OVERLAP = 100\nCHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"\n)\nCLAIM_MAX_GLEANINGS = 1\nCLAIM_EXTRACTION_ENABLED = False\nMAX_CLUSTER_SIZE = 10\nCOMMUNITY_REPORT_MAX_LENGTH = 2000\nCOMMUNITY_REPORT_MAX_INPUT_LENGTH = 8000",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CHUNK_GROUP_BY_COLUMNS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "CHUNK_GROUP_BY_COLUMNS = [\"id\"]\nCLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"\n)\nCLAIM_MAX_GLEANINGS = 1\nCLAIM_EXTRACTION_ENABLED = False\nMAX_CLUSTER_SIZE = 10\nCOMMUNITY_REPORT_MAX_LENGTH = 2000\nCOMMUNITY_REPORT_MAX_INPUT_LENGTH = 8000\nENTITY_EXTRACTION_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CLAIM_DESCRIPTION",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "CLAIM_DESCRIPTION = (\n    \"Any claims or facts that could be relevant to information discovery.\"\n)\nCLAIM_MAX_GLEANINGS = 1\nCLAIM_EXTRACTION_ENABLED = False\nMAX_CLUSTER_SIZE = 10\nCOMMUNITY_REPORT_MAX_LENGTH = 2000\nCOMMUNITY_REPORT_MAX_INPUT_LENGTH = 8000\nENTITY_EXTRACTION_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nENTITY_EXTRACTION_MAX_GLEANINGS = 1",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CLAIM_MAX_GLEANINGS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "CLAIM_MAX_GLEANINGS = 1\nCLAIM_EXTRACTION_ENABLED = False\nMAX_CLUSTER_SIZE = 10\nCOMMUNITY_REPORT_MAX_LENGTH = 2000\nCOMMUNITY_REPORT_MAX_INPUT_LENGTH = 8000\nENTITY_EXTRACTION_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nENTITY_EXTRACTION_MAX_GLEANINGS = 1\nINPUT_FILE_TYPE = InputFileType.text\nINPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CLAIM_EXTRACTION_ENABLED",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "CLAIM_EXTRACTION_ENABLED = False\nMAX_CLUSTER_SIZE = 10\nCOMMUNITY_REPORT_MAX_LENGTH = 2000\nCOMMUNITY_REPORT_MAX_INPUT_LENGTH = 8000\nENTITY_EXTRACTION_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nENTITY_EXTRACTION_MAX_GLEANINGS = 1\nINPUT_FILE_TYPE = InputFileType.text\nINPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "MAX_CLUSTER_SIZE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "MAX_CLUSTER_SIZE = 10\nCOMMUNITY_REPORT_MAX_LENGTH = 2000\nCOMMUNITY_REPORT_MAX_INPUT_LENGTH = 8000\nENTITY_EXTRACTION_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nENTITY_EXTRACTION_MAX_GLEANINGS = 1\nINPUT_FILE_TYPE = InputFileType.text\nINPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_REPORT_MAX_LENGTH",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "COMMUNITY_REPORT_MAX_LENGTH = 2000\nCOMMUNITY_REPORT_MAX_INPUT_LENGTH = 8000\nENTITY_EXTRACTION_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nENTITY_EXTRACTION_MAX_GLEANINGS = 1\nINPUT_FILE_TYPE = InputFileType.text\nINPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_REPORT_MAX_INPUT_LENGTH",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "COMMUNITY_REPORT_MAX_INPUT_LENGTH = 8000\nENTITY_EXTRACTION_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nENTITY_EXTRACTION_MAX_GLEANINGS = 1\nINPUT_FILE_TYPE = InputFileType.text\nINPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "ENTITY_EXTRACTION_ENTITY_TYPES",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "ENTITY_EXTRACTION_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nENTITY_EXTRACTION_MAX_GLEANINGS = 1\nINPUT_FILE_TYPE = InputFileType.text\nINPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "ENTITY_EXTRACTION_MAX_GLEANINGS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "ENTITY_EXTRACTION_MAX_GLEANINGS = 1\nINPUT_FILE_TYPE = InputFileType.text\nINPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "INPUT_FILE_TYPE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "INPUT_FILE_TYPE = InputFileType.text\nINPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "INPUT_TYPE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "INPUT_TYPE = InputType.file\nINPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "INPUT_BASE_DIR",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "INPUT_BASE_DIR = \"input\"\nINPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "INPUT_FILE_ENCODING",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "INPUT_FILE_ENCODING = \"utf-8\"\nINPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "INPUT_TEXT_COLUMN",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "INPUT_TEXT_COLUMN = \"text\"\nINPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "INPUT_CSV_PATTERN",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "INPUT_CSV_PATTERN = \".*\\\\.csv$\"\nINPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "INPUT_TEXT_PATTERN",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "INPUT_TEXT_PATTERN = \".*\\\\.txt$\"\nPARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "PARALLELIZATION_STAGGER",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "PARALLELIZATION_STAGGER = 0.3\nPARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "PARALLELIZATION_NUM_THREADS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "PARALLELIZATION_NUM_THREADS = 50\nNODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "NODE2VEC_ENABLED",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "NODE2VEC_ENABLED = False\nNODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "NODE2VEC_NUM_WALKS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "NODE2VEC_NUM_WALKS = 10\nNODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "NODE2VEC_WALK_LENGTH",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "NODE2VEC_WALK_LENGTH = 40\nNODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "NODE2VEC_WINDOW_SIZE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "NODE2VEC_WINDOW_SIZE = 2\nNODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "NODE2VEC_ITERATIONS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "NODE2VEC_ITERATIONS = 3\nNODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "NODE2VEC_RANDOM_SEED",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "NODE2VEC_RANDOM_SEED = 597832\nREPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "REPORTING_TYPE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "REPORTING_TYPE = ReportingType.file\nREPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False\n# Local Search",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "REPORTING_BASE_DIR",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "REPORTING_BASE_DIR = \"output\"\nSNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False\n# Local Search\nLOCAL_SEARCH_TEXT_UNIT_PROP = 0.5",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "SNAPSHOTS_GRAPHML",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "SNAPSHOTS_GRAPHML = False\nSNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False\n# Local Search\nLOCAL_SEARCH_TEXT_UNIT_PROP = 0.5\nLOCAL_SEARCH_COMMUNITY_PROP = 0.1",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "SNAPSHOTS_RAW_ENTITIES",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "SNAPSHOTS_RAW_ENTITIES = False\nSNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False\n# Local Search\nLOCAL_SEARCH_TEXT_UNIT_PROP = 0.5\nLOCAL_SEARCH_COMMUNITY_PROP = 0.1\nLOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "SNAPSHOTS_TOP_LEVEL_NODES",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "SNAPSHOTS_TOP_LEVEL_NODES = False\nSTORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False\n# Local Search\nLOCAL_SEARCH_TEXT_UNIT_PROP = 0.5\nLOCAL_SEARCH_COMMUNITY_PROP = 0.1\nLOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5\nLOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "STORAGE_BASE_DIR",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "STORAGE_BASE_DIR = \"output\"\nSTORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False\n# Local Search\nLOCAL_SEARCH_TEXT_UNIT_PROP = 0.5\nLOCAL_SEARCH_COMMUNITY_PROP = 0.1\nLOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5\nLOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10\nLOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "STORAGE_TYPE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "STORAGE_TYPE = StorageType.file\nSUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False\n# Local Search\nLOCAL_SEARCH_TEXT_UNIT_PROP = 0.5\nLOCAL_SEARCH_COMMUNITY_PROP = 0.1\nLOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5\nLOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10\nLOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10\nLOCAL_SEARCH_MAX_TOKENS = 12_000",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "SUMMARIZE_DESCRIPTIONS_MAX_LENGTH",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "SUMMARIZE_DESCRIPTIONS_MAX_LENGTH = 500\nUMAP_ENABLED = False\n# Local Search\nLOCAL_SEARCH_TEXT_UNIT_PROP = 0.5\nLOCAL_SEARCH_COMMUNITY_PROP = 0.1\nLOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5\nLOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10\nLOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10\nLOCAL_SEARCH_MAX_TOKENS = 12_000\nLOCAL_SEARCH_LLM_TEMPERATURE = 0",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "UMAP_ENABLED",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "UMAP_ENABLED = False\n# Local Search\nLOCAL_SEARCH_TEXT_UNIT_PROP = 0.5\nLOCAL_SEARCH_COMMUNITY_PROP = 0.1\nLOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5\nLOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10\nLOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10\nLOCAL_SEARCH_MAX_TOKENS = 12_000\nLOCAL_SEARCH_LLM_TEMPERATURE = 0\nLOCAL_SEARCH_LLM_TOP_P = 1",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_TEXT_UNIT_PROP",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_TEXT_UNIT_PROP = 0.5\nLOCAL_SEARCH_COMMUNITY_PROP = 0.1\nLOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5\nLOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10\nLOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10\nLOCAL_SEARCH_MAX_TOKENS = 12_000\nLOCAL_SEARCH_LLM_TEMPERATURE = 0\nLOCAL_SEARCH_LLM_TOP_P = 1\nLOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_COMMUNITY_PROP",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_COMMUNITY_PROP = 0.1\nLOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5\nLOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10\nLOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10\nLOCAL_SEARCH_MAX_TOKENS = 12_000\nLOCAL_SEARCH_LLM_TEMPERATURE = 0\nLOCAL_SEARCH_LLM_TOP_P = 1\nLOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_CONVERSATION_HISTORY_MAX_TURNS = 5\nLOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10\nLOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10\nLOCAL_SEARCH_MAX_TOKENS = 12_000\nLOCAL_SEARCH_LLM_TEMPERATURE = 0\nLOCAL_SEARCH_LLM_TOP_P = 1\nLOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search\nGLOBAL_SEARCH_LLM_TEMPERATURE = 0",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_TOP_K_MAPPED_ENTITIES",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_TOP_K_MAPPED_ENTITIES = 10\nLOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10\nLOCAL_SEARCH_MAX_TOKENS = 12_000\nLOCAL_SEARCH_LLM_TEMPERATURE = 0\nLOCAL_SEARCH_LLM_TOP_P = 1\nLOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search\nGLOBAL_SEARCH_LLM_TEMPERATURE = 0\nGLOBAL_SEARCH_LLM_TOP_P = 1",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_TOP_K_RELATIONSHIPS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_TOP_K_RELATIONSHIPS = 10\nLOCAL_SEARCH_MAX_TOKENS = 12_000\nLOCAL_SEARCH_LLM_TEMPERATURE = 0\nLOCAL_SEARCH_LLM_TOP_P = 1\nLOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search\nGLOBAL_SEARCH_LLM_TEMPERATURE = 0\nGLOBAL_SEARCH_LLM_TOP_P = 1\nGLOBAL_SEARCH_LLM_N = 1",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_MAX_TOKENS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_MAX_TOKENS = 12_000\nLOCAL_SEARCH_LLM_TEMPERATURE = 0\nLOCAL_SEARCH_LLM_TOP_P = 1\nLOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search\nGLOBAL_SEARCH_LLM_TEMPERATURE = 0\nGLOBAL_SEARCH_LLM_TOP_P = 1\nGLOBAL_SEARCH_LLM_N = 1\nGLOBAL_SEARCH_MAX_TOKENS = 12_000",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_LLM_TEMPERATURE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_LLM_TEMPERATURE = 0\nLOCAL_SEARCH_LLM_TOP_P = 1\nLOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search\nGLOBAL_SEARCH_LLM_TEMPERATURE = 0\nGLOBAL_SEARCH_LLM_TOP_P = 1\nGLOBAL_SEARCH_LLM_N = 1\nGLOBAL_SEARCH_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_LLM_TOP_P",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_LLM_TOP_P = 1\nLOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search\nGLOBAL_SEARCH_LLM_TEMPERATURE = 0\nGLOBAL_SEARCH_LLM_TOP_P = 1\nGLOBAL_SEARCH_LLM_N = 1\nGLOBAL_SEARCH_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_MAP_MAX_TOKENS = 1000",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_LLM_N",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_LLM_N = 1\nLOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search\nGLOBAL_SEARCH_LLM_TEMPERATURE = 0\nGLOBAL_SEARCH_LLM_TOP_P = 1\nGLOBAL_SEARCH_LLM_N = 1\nGLOBAL_SEARCH_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_MAP_MAX_TOKENS = 1000\nGLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_LLM_MAX_TOKENS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "LOCAL_SEARCH_LLM_MAX_TOKENS = 2000\n# Global Search\nGLOBAL_SEARCH_LLM_TEMPERATURE = 0\nGLOBAL_SEARCH_LLM_TOP_P = 1\nGLOBAL_SEARCH_LLM_N = 1\nGLOBAL_SEARCH_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_MAP_MAX_TOKENS = 1000\nGLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000\nGLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "GLOBAL_SEARCH_LLM_TEMPERATURE",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "GLOBAL_SEARCH_LLM_TEMPERATURE = 0\nGLOBAL_SEARCH_LLM_TOP_P = 1\nGLOBAL_SEARCH_LLM_N = 1\nGLOBAL_SEARCH_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_MAP_MAX_TOKENS = 1000\nGLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000\nGLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "GLOBAL_SEARCH_LLM_TOP_P",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "GLOBAL_SEARCH_LLM_TOP_P = 1\nGLOBAL_SEARCH_LLM_N = 1\nGLOBAL_SEARCH_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_MAP_MAX_TOKENS = 1000\nGLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000\nGLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "GLOBAL_SEARCH_LLM_N",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "GLOBAL_SEARCH_LLM_N = 1\nGLOBAL_SEARCH_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_MAP_MAX_TOKENS = 1000\nGLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000\nGLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "GLOBAL_SEARCH_MAX_TOKENS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "GLOBAL_SEARCH_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_MAP_MAX_TOKENS = 1000\nGLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000\nGLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "GLOBAL_SEARCH_DATA_MAX_TOKENS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "GLOBAL_SEARCH_DATA_MAX_TOKENS = 12_000\nGLOBAL_SEARCH_MAP_MAX_TOKENS = 1000\nGLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000\nGLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "GLOBAL_SEARCH_MAP_MAX_TOKENS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "GLOBAL_SEARCH_MAP_MAX_TOKENS = 1000\nGLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000\nGLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "GLOBAL_SEARCH_REDUCE_MAX_TOKENS",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "GLOBAL_SEARCH_REDUCE_MAX_TOKENS = 2_000\nGLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "GLOBAL_SEARCH_CONCURRENCY",
        "kind": 5,
        "importPath": "graphrag.config.defaults",
        "description": "graphrag.config.defaults",
        "peekOfCode": "GLOBAL_SEARCH_CONCURRENCY = 32",
        "detail": "graphrag.config.defaults",
        "documentation": {}
    },
    {
        "label": "CacheType",
        "kind": 6,
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "peekOfCode": "class CacheType(str, Enum):\n    \"\"\"The cache configuration type for the pipeline.\"\"\"\n    file = \"file\"\n    \"\"\"The file cache configuration type.\"\"\"\n    memory = \"memory\"\n    \"\"\"The memory cache configuration type.\"\"\"\n    none = \"none\"\n    \"\"\"The none cache configuration type.\"\"\"\n    blob = \"blob\"\n    \"\"\"The blob cache configuration type.\"\"\"",
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputFileType",
        "kind": 6,
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "peekOfCode": "class InputFileType(str, Enum):\n    \"\"\"The input file type for the pipeline.\"\"\"\n    csv = \"csv\"\n    \"\"\"The CSV input type.\"\"\"\n    text = \"text\"\n    \"\"\"The text input type.\"\"\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nclass InputType(str, Enum):",
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "InputType",
        "kind": 6,
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "peekOfCode": "class InputType(str, Enum):\n    \"\"\"The input type for the pipeline.\"\"\"\n    file = \"file\"\n    \"\"\"The file storage type.\"\"\"\n    blob = \"blob\"\n    \"\"\"The blob storage type.\"\"\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nclass StorageType(str, Enum):",
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "StorageType",
        "kind": 6,
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "peekOfCode": "class StorageType(str, Enum):\n    \"\"\"The storage type for the pipeline.\"\"\"\n    file = \"file\"\n    \"\"\"The file storage type.\"\"\"\n    memory = \"memory\"\n    \"\"\"The memory storage type.\"\"\"\n    blob = \"blob\"\n    \"\"\"The blob storage type.\"\"\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"",
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "ReportingType",
        "kind": 6,
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "peekOfCode": "class ReportingType(str, Enum):\n    \"\"\"The reporting configuration type for the pipeline.\"\"\"\n    file = \"file\"\n    \"\"\"The file reporting configuration type.\"\"\"\n    console = \"console\"\n    \"\"\"The console reporting configuration type.\"\"\"\n    blob = \"blob\"\n    \"\"\"The blob reporting configuration type.\"\"\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"",
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingTarget",
        "kind": 6,
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "peekOfCode": "class TextEmbeddingTarget(str, Enum):\n    \"\"\"The target to use for text embeddings.\"\"\"\n    all = \"all\"\n    required = \"required\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nclass LLMType(str, Enum):\n    \"\"\"LLMType enum class definition.\"\"\"\n    # Embeddings",
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "LLMType",
        "kind": 6,
        "importPath": "graphrag.config.enums",
        "description": "graphrag.config.enums",
        "peekOfCode": "class LLMType(str, Enum):\n    \"\"\"LLMType enum class definition.\"\"\"\n    # Embeddings\n    OpenAIEmbedding = \"openai_embedding\"\n    AzureOpenAIEmbedding = \"azure_openai_embedding\"\n    # Raw Completion\n    OpenAI = \"openai\"\n    AzureOpenAI = \"azure_openai\"\n    # Chat Completion\n    OpenAIChat = \"openai_chat\"",
        "detail": "graphrag.config.enums",
        "documentation": {}
    },
    {
        "label": "EnvironmentReader",
        "kind": 6,
        "importPath": "graphrag.config.environment_reader",
        "description": "graphrag.config.environment_reader",
        "peekOfCode": "class EnvironmentReader:\n    \"\"\"A configuration reader utility class.\"\"\"\n    _env: Env\n    _config_stack: list[dict]\n    def __init__(self, env: Env):\n        self._env = env\n        self._config_stack = []\n    @property\n    def env(self):\n        \"\"\"Get the environment object.\"\"\"",
        "detail": "graphrag.config.environment_reader",
        "documentation": {}
    },
    {
        "label": "read_key",
        "kind": 2,
        "importPath": "graphrag.config.environment_reader",
        "description": "graphrag.config.environment_reader",
        "peekOfCode": "def read_key(value: KeyValue) -> str:\n    \"\"\"Read a key value.\"\"\"\n    if not isinstance(value, str):\n        return value.value.lower()\n    return value.lower()\nclass EnvironmentReader:\n    \"\"\"A configuration reader utility class.\"\"\"\n    _env: Env\n    _config_stack: list[dict]\n    def __init__(self, env: Env):",
        "detail": "graphrag.config.environment_reader",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "graphrag.config.environment_reader",
        "description": "graphrag.config.environment_reader",
        "peekOfCode": "T = TypeVar(\"T\")\nKeyValue = str | Enum\nEnvKeySet = str | list[str]\ndef read_key(value: KeyValue) -> str:\n    \"\"\"Read a key value.\"\"\"\n    if not isinstance(value, str):\n        return value.value.lower()\n    return value.lower()\nclass EnvironmentReader:\n    \"\"\"A configuration reader utility class.\"\"\"",
        "detail": "graphrag.config.environment_reader",
        "documentation": {}
    },
    {
        "label": "KeyValue",
        "kind": 5,
        "importPath": "graphrag.config.environment_reader",
        "description": "graphrag.config.environment_reader",
        "peekOfCode": "KeyValue = str | Enum\nEnvKeySet = str | list[str]\ndef read_key(value: KeyValue) -> str:\n    \"\"\"Read a key value.\"\"\"\n    if not isinstance(value, str):\n        return value.value.lower()\n    return value.lower()\nclass EnvironmentReader:\n    \"\"\"A configuration reader utility class.\"\"\"\n    _env: Env",
        "detail": "graphrag.config.environment_reader",
        "documentation": {}
    },
    {
        "label": "EnvKeySet",
        "kind": 5,
        "importPath": "graphrag.config.environment_reader",
        "description": "graphrag.config.environment_reader",
        "peekOfCode": "EnvKeySet = str | list[str]\ndef read_key(value: KeyValue) -> str:\n    \"\"\"Read a key value.\"\"\"\n    if not isinstance(value, str):\n        return value.value.lower()\n    return value.lower()\nclass EnvironmentReader:\n    \"\"\"A configuration reader utility class.\"\"\"\n    _env: Env\n    _config_stack: list[dict]",
        "detail": "graphrag.config.environment_reader",
        "documentation": {}
    },
    {
        "label": "ApiKeyMissingError",
        "kind": 6,
        "importPath": "graphrag.config.errors",
        "description": "graphrag.config.errors",
        "peekOfCode": "class ApiKeyMissingError(ValueError):\n    \"\"\"LLM Key missing error.\"\"\"\n    def __init__(self, embedding: bool = False) -> None:\n        \"\"\"Init method definition.\"\"\"\n        api_type = \"Embedding\" if embedding else \"Completion\"\n        api_key = \"GRAPHRAG_EMBEDDING_API_KEY\" if embedding else \"GRAPHRAG_LLM_API_KEY\"\n        msg = f\"API Key is required for {api_type} API. Please set either the OPENAI_API_KEY, GRAPHRAG_API_KEY or {api_key} environment variable.\"\n        super().__init__(msg)\nclass AzureApiBaseMissingError(ValueError):\n    \"\"\"Azure API Base missing error.\"\"\"",
        "detail": "graphrag.config.errors",
        "documentation": {}
    },
    {
        "label": "AzureApiBaseMissingError",
        "kind": 6,
        "importPath": "graphrag.config.errors",
        "description": "graphrag.config.errors",
        "peekOfCode": "class AzureApiBaseMissingError(ValueError):\n    \"\"\"Azure API Base missing error.\"\"\"\n    def __init__(self, embedding: bool = False) -> None:\n        \"\"\"Init method definition.\"\"\"\n        api_type = \"Embedding\" if embedding else \"Completion\"\n        api_base = \"GRAPHRAG_EMBEDDING_API_BASE\" if embedding else \"GRAPHRAG_API_BASE\"\n        msg = f\"API Base is required for {api_type} API. Please set either the OPENAI_API_BASE, GRAPHRAG_API_BASE or {api_base} environment variable.\"\n        super().__init__(msg)\nclass AzureDeploymentNameMissingError(ValueError):\n    \"\"\"Azure Deployment Name missing error.\"\"\"",
        "detail": "graphrag.config.errors",
        "documentation": {}
    },
    {
        "label": "AzureDeploymentNameMissingError",
        "kind": 6,
        "importPath": "graphrag.config.errors",
        "description": "graphrag.config.errors",
        "peekOfCode": "class AzureDeploymentNameMissingError(ValueError):\n    \"\"\"Azure Deployment Name missing error.\"\"\"\n    def __init__(self, embedding: bool = False) -> None:\n        \"\"\"Init method definition.\"\"\"\n        api_type = \"Embedding\" if embedding else \"Completion\"\n        api_base = (\n            \"GRAPHRAG_EMBEDDING_DEPLOYMENT_NAME\"\n            if embedding\n            else \"GRAPHRAG_LLM_DEPLOYMENT_NAME\"\n        )",
        "detail": "graphrag.config.errors",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "graphrag.config.load_config",
        "description": "graphrag.config.load_config",
        "peekOfCode": "def load_config(\n    root_dir: str | Path,\n    config_filepath: str | None = None,\n) -> GraphRagConfig:\n    \"\"\"Load configuration from a file or create a default configuration.\n    If a config file is not found the default configuration is created.\n    Parameters\n    ----------\n    root_dir : str | Path\n        The root directory of the project. Will search for the config file in this directory.",
        "detail": "graphrag.config.load_config",
        "documentation": {}
    },
    {
        "label": "enable_logging",
        "kind": 2,
        "importPath": "graphrag.config.logging",
        "description": "graphrag.config.logging",
        "peekOfCode": "def enable_logging(log_filepath: str | Path, verbose: bool = False) -> None:\n    \"\"\"Enable logging to a file.\n    Parameters\n    ----------\n    log_filepath : str | Path\n        The path to the log file.\n    verbose : bool, default=False\n        Whether to log debug messages.\n    \"\"\"\n    log_filepath = Path(log_filepath)",
        "detail": "graphrag.config.logging",
        "documentation": {}
    },
    {
        "label": "enable_logging_with_config",
        "kind": 2,
        "importPath": "graphrag.config.logging",
        "description": "graphrag.config.logging",
        "peekOfCode": "def enable_logging_with_config(\n    config: GraphRagConfig, verbose: bool = False\n) -> tuple[bool, str]:\n    \"\"\"Enable logging to a file based on the config.\n    Parameters\n    ----------\n    config : GraphRagConfig\n        The configuration.\n    timestamp_value : str\n        The timestamp value representing the directory to place the log files.",
        "detail": "graphrag.config.logging",
        "documentation": {}
    },
    {
        "label": "read_dotenv",
        "kind": 2,
        "importPath": "graphrag.config.read_dotenv",
        "description": "graphrag.config.read_dotenv",
        "peekOfCode": "def read_dotenv(root: str) -> None:\n    \"\"\"Read a .env file in the given root path.\"\"\"\n    env_path = Path(root) / \".env\"\n    if env_path.exists():\n        log.info(\"Loading pipeline .env file\")\n        env_config = dotenv_values(f\"{env_path}\")\n        for key, value in env_config.items():\n            if key not in os.environ:\n                os.environ[key] = value or \"\"\n    else:",
        "detail": "graphrag.config.read_dotenv",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.config.read_dotenv",
        "description": "graphrag.config.read_dotenv",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef read_dotenv(root: str) -> None:\n    \"\"\"Read a .env file in the given root path.\"\"\"\n    env_path = Path(root) / \".env\"\n    if env_path.exists():\n        log.info(\"Loading pipeline .env file\")\n        env_config = dotenv_values(f\"{env_path}\")\n        for key, value in env_config.items():\n            if key not in os.environ:\n                os.environ[key] = value or \"\"",
        "detail": "graphrag.config.read_dotenv",
        "documentation": {}
    },
    {
        "label": "resolve_path",
        "kind": 2,
        "importPath": "graphrag.config.resolve_path",
        "description": "graphrag.config.resolve_path",
        "peekOfCode": "def resolve_path(\n    path_to_resolve: Path | str,\n    root_dir: Path | str | None = None,\n    pattern_or_timestamp_value: re.Pattern[str] | str | None = None,\n) -> Path:\n    \"\"\"Resolve the path.\n    Resolves any timestamp variables by either using the provided timestamp value if string or\n    by looking up the latest available timestamp directory that matches the given pattern.\n    Resolves the path against the root directory if provided.\n    Parameters",
        "detail": "graphrag.config.resolve_path",
        "documentation": {}
    },
    {
        "label": "resolve_paths",
        "kind": 2,
        "importPath": "graphrag.config.resolve_path",
        "description": "graphrag.config.resolve_path",
        "peekOfCode": "def resolve_paths(\n    config: GraphRagConfig,\n    pattern_or_timestamp_value: re.Pattern[str] | str | None = None,\n) -> None:\n    \"\"\"Resolve storage and reporting paths in the configuration for local file handling.\n    Resolves any timestamp variables in the configuration paths by either using the provided timestamp value if string or\n    by looking up the latest available timestamp directory that matches the given pattern.\n    Parameters\n    ----------\n    config : GraphRagConfig",
        "detail": "graphrag.config.resolve_path",
        "documentation": {}
    },
    {
        "label": "JsonPipelineCache",
        "kind": 6,
        "importPath": "graphrag.index.cache.json_pipeline_cache",
        "description": "graphrag.index.cache.json_pipeline_cache",
        "peekOfCode": "class JsonPipelineCache(PipelineCache):\n    \"\"\"File pipeline cache class definition.\"\"\"\n    _storage: PipelineStorage\n    _encoding: str\n    def __init__(self, storage: PipelineStorage, encoding=\"utf-8\"):\n        \"\"\"Init method definition.\"\"\"\n        self._storage = storage\n        self._encoding = encoding\n    async def get(self, key: str) -> str | None:\n        \"\"\"Get method definition.\"\"\"",
        "detail": "graphrag.index.cache.json_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "load_cache",
        "kind": 2,
        "importPath": "graphrag.index.cache.load_cache",
        "description": "graphrag.index.cache.load_cache",
        "peekOfCode": "def load_cache(config: PipelineCacheConfig | None, root_dir: str | None):\n    \"\"\"Load the cache from the given config.\"\"\"\n    if config is None:\n        return NoopPipelineCache()\n    match config.type:\n        case CacheType.none:\n            return NoopPipelineCache()\n        case CacheType.memory:\n            return create_memory_cache()\n        case CacheType.file:",
        "detail": "graphrag.index.cache.load_cache",
        "documentation": {}
    },
    {
        "label": "InMemoryCache",
        "kind": 6,
        "importPath": "graphrag.index.cache.memory_pipeline_cache",
        "description": "graphrag.index.cache.memory_pipeline_cache",
        "peekOfCode": "class InMemoryCache(PipelineCache):\n    \"\"\"In memory cache class definition.\"\"\"\n    _cache: dict[str, Any]\n    _name: str\n    def __init__(self, name: str | None = None):\n        \"\"\"Init method definition.\"\"\"\n        self._cache = {}\n        self._name = name or \"\"\n    async def get(self, key: str) -> Any:\n        \"\"\"Get the value for the given key.",
        "detail": "graphrag.index.cache.memory_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "create_memory_cache",
        "kind": 2,
        "importPath": "graphrag.index.cache.memory_pipeline_cache",
        "description": "graphrag.index.cache.memory_pipeline_cache",
        "peekOfCode": "def create_memory_cache() -> PipelineCache:\n    \"\"\"Create a memory cache.\"\"\"\n    return InMemoryCache()",
        "detail": "graphrag.index.cache.memory_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "NoopPipelineCache",
        "kind": 6,
        "importPath": "graphrag.index.cache.noop_pipeline_cache",
        "description": "graphrag.index.cache.noop_pipeline_cache",
        "peekOfCode": "class NoopPipelineCache(PipelineCache):\n    \"\"\"A no-op implementation of the pipeline cache, usually useful for testing.\"\"\"\n    async def get(self, key: str) -> Any:\n        \"\"\"Get the value for the given key.\n        Args:\n            - key - The key to get the value for.\n            - as_bytes - Whether or not to return the value as bytes.\n        Returns\n        -------\n            - output - The value for the given key.",
        "detail": "graphrag.index.cache.noop_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "PipelineCache",
        "kind": 6,
        "importPath": "graphrag.index.cache.pipeline_cache",
        "description": "graphrag.index.cache.pipeline_cache",
        "peekOfCode": "class PipelineCache(metaclass=ABCMeta):\n    \"\"\"Provide a cache interface for the pipeline.\"\"\"\n    @abstractmethod\n    async def get(self, key: str) -> Any:\n        \"\"\"Get the value for the given key.\n        Args:\n            - key - The key to get the value for.\n            - as_bytes - Whether or not to return the value as bytes.\n        Returns\n        -------",
        "detail": "graphrag.index.cache.pipeline_cache",
        "documentation": {}
    },
    {
        "label": "PipelineCacheConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "peekOfCode": "class PipelineCacheConfig(BaseModel, Generic[T]):\n    \"\"\"Represent the cache configuration for the pipeline.\"\"\"\n    type: T\nclass PipelineFileCacheConfig(PipelineCacheConfig[Literal[CacheType.file]]):\n    \"\"\"Represent the file cache configuration for the pipeline.\"\"\"\n    type: Literal[CacheType.file] = CacheType.file\n    \"\"\"The type of cache.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the cache.\", default=None\n    )",
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineFileCacheConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "peekOfCode": "class PipelineFileCacheConfig(PipelineCacheConfig[Literal[CacheType.file]]):\n    \"\"\"Represent the file cache configuration for the pipeline.\"\"\"\n    type: Literal[CacheType.file] = CacheType.file\n    \"\"\"The type of cache.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the cache.\", default=None\n    )\n    \"\"\"The base directory for the cache.\"\"\"\nclass PipelineMemoryCacheConfig(PipelineCacheConfig[Literal[CacheType.memory]]):\n    \"\"\"Represent the memory cache configuration for the pipeline.\"\"\"",
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineMemoryCacheConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "peekOfCode": "class PipelineMemoryCacheConfig(PipelineCacheConfig[Literal[CacheType.memory]]):\n    \"\"\"Represent the memory cache configuration for the pipeline.\"\"\"\n    type: Literal[CacheType.memory] = CacheType.memory\n    \"\"\"The type of cache.\"\"\"\nclass PipelineNoneCacheConfig(PipelineCacheConfig[Literal[CacheType.none]]):\n    \"\"\"Represent the none cache configuration for the pipeline.\"\"\"\n    type: Literal[CacheType.none] = CacheType.none\n    \"\"\"The type of cache.\"\"\"\nclass PipelineBlobCacheConfig(PipelineCacheConfig[Literal[CacheType.blob]]):\n    \"\"\"Represents the blob cache configuration for the pipeline.\"\"\"",
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineNoneCacheConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "peekOfCode": "class PipelineNoneCacheConfig(PipelineCacheConfig[Literal[CacheType.none]]):\n    \"\"\"Represent the none cache configuration for the pipeline.\"\"\"\n    type: Literal[CacheType.none] = CacheType.none\n    \"\"\"The type of cache.\"\"\"\nclass PipelineBlobCacheConfig(PipelineCacheConfig[Literal[CacheType.blob]]):\n    \"\"\"Represents the blob cache configuration for the pipeline.\"\"\"\n    type: Literal[CacheType.blob] = CacheType.blob\n    \"\"\"The type of cache.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the cache.\", default=None",
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineBlobCacheConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "peekOfCode": "class PipelineBlobCacheConfig(PipelineCacheConfig[Literal[CacheType.blob]]):\n    \"\"\"Represents the blob cache configuration for the pipeline.\"\"\"\n    type: Literal[CacheType.blob] = CacheType.blob\n    \"\"\"The type of cache.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the cache.\", default=None\n    )\n    \"\"\"The base directory for the cache.\"\"\"\n    connection_string: str | None = pydantic_Field(\n        description=\"The blob cache connection string for the cache.\", default=None",
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "peekOfCode": "T = TypeVar(\"T\")\nclass PipelineCacheConfig(BaseModel, Generic[T]):\n    \"\"\"Represent the cache configuration for the pipeline.\"\"\"\n    type: T\nclass PipelineFileCacheConfig(PipelineCacheConfig[Literal[CacheType.file]]):\n    \"\"\"Represent the file cache configuration for the pipeline.\"\"\"\n    type: Literal[CacheType.file] = CacheType.file\n    \"\"\"The type of cache.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the cache.\", default=None",
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineCacheConfigTypes",
        "kind": 5,
        "importPath": "graphrag.index.config.cache",
        "description": "graphrag.index.config.cache",
        "peekOfCode": "PipelineCacheConfigTypes = (\n    PipelineFileCacheConfig\n    | PipelineMemoryCacheConfig\n    | PipelineBlobCacheConfig\n    | PipelineNoneCacheConfig\n)",
        "detail": "graphrag.index.config.cache",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "peekOfCode": "class PipelineInputConfig(BaseModel, Generic[T]):\n    \"\"\"Represent the configuration for an input.\"\"\"\n    file_type: T\n    \"\"\"The file type of input.\"\"\"\n    type: InputType | None = pydantic_Field(\n        description=\"The input type to use.\",\n        default=None,\n    )\n    \"\"\"The input type to use.\"\"\"\n    connection_string: str | None = pydantic_Field(",
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineCSVInputConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "peekOfCode": "class PipelineCSVInputConfig(PipelineInputConfig[Literal[InputFileType.csv]]):\n    \"\"\"Represent the configuration for a CSV input.\"\"\"\n    file_type: Literal[InputFileType.csv] = InputFileType.csv\n    source_column: str | None = pydantic_Field(\n        description=\"The column to use as the source of the document.\", default=None\n    )\n    \"\"\"The column to use as the source of the document.\"\"\"\n    timestamp_column: str | None = pydantic_Field(\n        description=\"The column to use as the timestamp of the document.\", default=None\n    )",
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineTextInputConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "peekOfCode": "class PipelineTextInputConfig(PipelineInputConfig[Literal[InputFileType.text]]):\n    \"\"\"Represent the configuration for a text input.\"\"\"\n    file_type: Literal[InputFileType.text] = InputFileType.text\n    # Text Specific\n    title_text_length: int | None = pydantic_Field(\n        description=\"Number of characters to use from the text as the title.\",\n        default=None,\n    )\n    \"\"\"Number of characters to use from the text as the title.\"\"\"\nPipelineInputConfigTypes = PipelineCSVInputConfig | PipelineTextInputConfig",
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "peekOfCode": "T = TypeVar(\"T\")\nclass PipelineInputConfig(BaseModel, Generic[T]):\n    \"\"\"Represent the configuration for an input.\"\"\"\n    file_type: T\n    \"\"\"The file type of input.\"\"\"\n    type: InputType | None = pydantic_Field(\n        description=\"The input type to use.\",\n        default=None,\n    )\n    \"\"\"The input type to use.\"\"\"",
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineInputConfigTypes",
        "kind": 5,
        "importPath": "graphrag.index.config.input",
        "description": "graphrag.index.config.input",
        "peekOfCode": "PipelineInputConfigTypes = PipelineCSVInputConfig | PipelineTextInputConfig\n\"\"\"Represent the types of inputs that can be used in a pipeline.\"\"\"",
        "detail": "graphrag.index.config.input",
        "documentation": {}
    },
    {
        "label": "PipelineConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.pipeline",
        "description": "graphrag.index.config.pipeline",
        "peekOfCode": "class PipelineConfig(BaseModel):\n    \"\"\"Represent the configuration for a pipeline.\"\"\"\n    def __repr__(self) -> str:\n        \"\"\"Get a string representation.\"\"\"\n        return pformat(self, highlight=False)\n    def __str__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return str(self.model_dump_json(indent=4))\n    extends: list[str] | str | None = pydantic_Field(\n        description=\"Extends another pipeline configuration\", default=None",
        "detail": "graphrag.index.config.pipeline",
        "documentation": {}
    },
    {
        "label": "PipelineReportingConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "peekOfCode": "class PipelineReportingConfig(BaseModel, Generic[T]):\n    \"\"\"Represent the reporting configuration for the pipeline.\"\"\"\n    type: T\nclass PipelineFileReportingConfig(PipelineReportingConfig[Literal[ReportingType.file]]):\n    \"\"\"Represent the file reporting configuration for the pipeline.\"\"\"\n    type: Literal[ReportingType.file] = ReportingType.file\n    \"\"\"The type of reporting.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the reporting.\", default=None\n    )",
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineFileReportingConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "peekOfCode": "class PipelineFileReportingConfig(PipelineReportingConfig[Literal[ReportingType.file]]):\n    \"\"\"Represent the file reporting configuration for the pipeline.\"\"\"\n    type: Literal[ReportingType.file] = ReportingType.file\n    \"\"\"The type of reporting.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the reporting.\", default=None\n    )\n    \"\"\"The base directory for the reporting.\"\"\"\nclass PipelineConsoleReportingConfig(\n    PipelineReportingConfig[Literal[ReportingType.console]]",
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineConsoleReportingConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "peekOfCode": "class PipelineConsoleReportingConfig(\n    PipelineReportingConfig[Literal[ReportingType.console]]\n):\n    \"\"\"Represent the console reporting configuration for the pipeline.\"\"\"\n    type: Literal[ReportingType.console] = ReportingType.console\n    \"\"\"The type of reporting.\"\"\"\nclass PipelineBlobReportingConfig(PipelineReportingConfig[Literal[ReportingType.blob]]):\n    \"\"\"Represents the blob reporting configuration for the pipeline.\"\"\"\n    type: Literal[ReportingType.blob] = ReportingType.blob\n    \"\"\"The type of reporting.\"\"\"",
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineBlobReportingConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "peekOfCode": "class PipelineBlobReportingConfig(PipelineReportingConfig[Literal[ReportingType.blob]]):\n    \"\"\"Represents the blob reporting configuration for the pipeline.\"\"\"\n    type: Literal[ReportingType.blob] = ReportingType.blob\n    \"\"\"The type of reporting.\"\"\"\n    connection_string: str | None = pydantic_Field(\n        description=\"The blob reporting connection string for the reporting.\",\n        default=None,\n    )\n    \"\"\"The blob reporting connection string for the reporting.\"\"\"\n    container_name: str = pydantic_Field(",
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "peekOfCode": "T = TypeVar(\"T\")\nclass PipelineReportingConfig(BaseModel, Generic[T]):\n    \"\"\"Represent the reporting configuration for the pipeline.\"\"\"\n    type: T\nclass PipelineFileReportingConfig(PipelineReportingConfig[Literal[ReportingType.file]]):\n    \"\"\"Represent the file reporting configuration for the pipeline.\"\"\"\n    type: Literal[ReportingType.file] = ReportingType.file\n    \"\"\"The type of reporting.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the reporting.\", default=None",
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineReportingConfigTypes",
        "kind": 5,
        "importPath": "graphrag.index.config.reporting",
        "description": "graphrag.index.config.reporting",
        "peekOfCode": "PipelineReportingConfigTypes = (\n    PipelineFileReportingConfig\n    | PipelineConsoleReportingConfig\n    | PipelineBlobReportingConfig\n)",
        "detail": "graphrag.index.config.reporting",
        "documentation": {}
    },
    {
        "label": "PipelineStorageConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "peekOfCode": "class PipelineStorageConfig(BaseModel, Generic[T]):\n    \"\"\"Represent the storage configuration for the pipeline.\"\"\"\n    type: T\nclass PipelineFileStorageConfig(PipelineStorageConfig[Literal[StorageType.file]]):\n    \"\"\"Represent the file storage configuration for the pipeline.\"\"\"\n    type: Literal[StorageType.file] = StorageType.file\n    \"\"\"The type of storage.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the storage.\", default=None\n    )",
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineFileStorageConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "peekOfCode": "class PipelineFileStorageConfig(PipelineStorageConfig[Literal[StorageType.file]]):\n    \"\"\"Represent the file storage configuration for the pipeline.\"\"\"\n    type: Literal[StorageType.file] = StorageType.file\n    \"\"\"The type of storage.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the storage.\", default=None\n    )\n    \"\"\"The base directory for the storage.\"\"\"\nclass PipelineMemoryStorageConfig(PipelineStorageConfig[Literal[StorageType.memory]]):\n    \"\"\"Represent the memory storage configuration for the pipeline.\"\"\"",
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineMemoryStorageConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "peekOfCode": "class PipelineMemoryStorageConfig(PipelineStorageConfig[Literal[StorageType.memory]]):\n    \"\"\"Represent the memory storage configuration for the pipeline.\"\"\"\n    type: Literal[StorageType.memory] = StorageType.memory\n    \"\"\"The type of storage.\"\"\"\nclass PipelineBlobStorageConfig(PipelineStorageConfig[Literal[StorageType.blob]]):\n    \"\"\"Represents the blob storage configuration for the pipeline.\"\"\"\n    type: Literal[StorageType.blob] = StorageType.blob\n    \"\"\"The type of storage.\"\"\"\n    connection_string: str | None = pydantic_Field(\n        description=\"The blob storage connection string for the storage.\", default=None",
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineBlobStorageConfig",
        "kind": 6,
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "peekOfCode": "class PipelineBlobStorageConfig(PipelineStorageConfig[Literal[StorageType.blob]]):\n    \"\"\"Represents the blob storage configuration for the pipeline.\"\"\"\n    type: Literal[StorageType.blob] = StorageType.blob\n    \"\"\"The type of storage.\"\"\"\n    connection_string: str | None = pydantic_Field(\n        description=\"The blob storage connection string for the storage.\", default=None\n    )\n    \"\"\"The blob storage connection string for the storage.\"\"\"\n    container_name: str = pydantic_Field(\n        description=\"The container name for storage\", default=None",
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "peekOfCode": "T = TypeVar(\"T\")\nclass PipelineStorageConfig(BaseModel, Generic[T]):\n    \"\"\"Represent the storage configuration for the pipeline.\"\"\"\n    type: T\nclass PipelineFileStorageConfig(PipelineStorageConfig[Literal[StorageType.file]]):\n    \"\"\"Represent the file storage configuration for the pipeline.\"\"\"\n    type: Literal[StorageType.file] = StorageType.file\n    \"\"\"The type of storage.\"\"\"\n    base_dir: str | None = pydantic_Field(\n        description=\"The base directory for the storage.\", default=None",
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorageConfigTypes",
        "kind": 5,
        "importPath": "graphrag.index.config.storage",
        "description": "graphrag.index.config.storage",
        "peekOfCode": "PipelineStorageConfigTypes = (\n    PipelineFileStorageConfig | PipelineMemoryStorageConfig | PipelineBlobStorageConfig\n)",
        "detail": "graphrag.index.config.storage",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowReference",
        "kind": 6,
        "importPath": "graphrag.index.config.workflow",
        "description": "graphrag.index.config.workflow",
        "peekOfCode": "class PipelineWorkflowReference(BaseModel):\n    \"\"\"Represent a reference to a workflow, and can optionally be the workflow itself.\"\"\"\n    name: str | None = pydantic_Field(description=\"Name of the workflow.\", default=None)\n    \"\"\"Name of the workflow.\"\"\"\n    steps: list[PipelineWorkflowStep] | None = pydantic_Field(\n        description=\"The optional steps for the workflow.\", default=None\n    )\n    \"\"\"The optional steps for the workflow.\"\"\"\n    config: PipelineWorkflowConfig | None = pydantic_Field(\n        description=\"The optional configuration for the workflow.\", default=None",
        "detail": "graphrag.index.config.workflow",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowStep",
        "kind": 5,
        "importPath": "graphrag.index.config.workflow",
        "description": "graphrag.index.config.workflow",
        "peekOfCode": "PipelineWorkflowStep = dict[str, Any]\n\"\"\"Represent a step in a workflow.\"\"\"\nPipelineWorkflowConfig = dict[str, Any]\n\"\"\"Represent a configuration for a workflow.\"\"\"\nclass PipelineWorkflowReference(BaseModel):\n    \"\"\"Represent a reference to a workflow, and can optionally be the workflow itself.\"\"\"\n    name: str | None = pydantic_Field(description=\"Name of the workflow.\", default=None)\n    \"\"\"Name of the workflow.\"\"\"\n    steps: list[PipelineWorkflowStep] | None = pydantic_Field(\n        description=\"The optional steps for the workflow.\", default=None",
        "detail": "graphrag.index.config.workflow",
        "documentation": {}
    },
    {
        "label": "PipelineWorkflowConfig",
        "kind": 5,
        "importPath": "graphrag.index.config.workflow",
        "description": "graphrag.index.config.workflow",
        "peekOfCode": "PipelineWorkflowConfig = dict[str, Any]\n\"\"\"Represent a configuration for a workflow.\"\"\"\nclass PipelineWorkflowReference(BaseModel):\n    \"\"\"Represent a reference to a workflow, and can optionally be the workflow itself.\"\"\"\n    name: str | None = pydantic_Field(description=\"Name of the workflow.\", default=None)\n    \"\"\"Name of the workflow.\"\"\"\n    steps: list[PipelineWorkflowStep] | None = pydantic_Field(\n        description=\"The optional steps for the workflow.\", default=None\n    )\n    \"\"\"The optional steps for the workflow.\"\"\"",
        "detail": "graphrag.index.config.workflow",
        "documentation": {}
    },
    {
        "label": "CSVTableEmitter",
        "kind": 6,
        "importPath": "graphrag.index.emit.csv_table_emitter",
        "description": "graphrag.index.emit.csv_table_emitter",
        "peekOfCode": "class CSVTableEmitter(TableEmitter):\n    \"\"\"CSVTableEmitter class.\"\"\"\n    _storage: PipelineStorage\n    def __init__(self, storage: PipelineStorage):\n        \"\"\"Create a new CSV Table Emitter.\"\"\"\n        self._storage = storage\n    async def emit(self, name: str, data: pd.DataFrame) -> None:\n        \"\"\"Emit a dataframe to storage.\"\"\"\n        filename = f\"{name}.csv\"\n        log.info(\"emitting CSV table %s\", filename)",
        "detail": "graphrag.index.emit.csv_table_emitter",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.emit.csv_table_emitter",
        "description": "graphrag.index.emit.csv_table_emitter",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass CSVTableEmitter(TableEmitter):\n    \"\"\"CSVTableEmitter class.\"\"\"\n    _storage: PipelineStorage\n    def __init__(self, storage: PipelineStorage):\n        \"\"\"Create a new CSV Table Emitter.\"\"\"\n        self._storage = storage\n    async def emit(self, name: str, data: pd.DataFrame) -> None:\n        \"\"\"Emit a dataframe to storage.\"\"\"\n        filename = f\"{name}.csv\"",
        "detail": "graphrag.index.emit.csv_table_emitter",
        "documentation": {}
    },
    {
        "label": "create_table_emitter",
        "kind": 2,
        "importPath": "graphrag.index.emit.factories",
        "description": "graphrag.index.emit.factories",
        "peekOfCode": "def create_table_emitter(\n    emitter_type: TableEmitterType, storage: PipelineStorage, on_error: ErrorHandlerFn\n) -> TableEmitter:\n    \"\"\"Create a table emitter based on the specified type.\"\"\"\n    match emitter_type:\n        case TableEmitterType.Json:\n            return JsonTableEmitter(storage)\n        case TableEmitterType.Parquet:\n            return ParquetTableEmitter(storage, on_error)\n        case TableEmitterType.CSV:",
        "detail": "graphrag.index.emit.factories",
        "documentation": {}
    },
    {
        "label": "create_table_emitters",
        "kind": 2,
        "importPath": "graphrag.index.emit.factories",
        "description": "graphrag.index.emit.factories",
        "peekOfCode": "def create_table_emitters(\n    emitter_types: list[TableEmitterType],\n    storage: PipelineStorage,\n    on_error: ErrorHandlerFn,\n) -> list[TableEmitter]:\n    \"\"\"Create a list of table emitters based on the specified types.\"\"\"\n    return [\n        create_table_emitter(emitter_type, storage, on_error)\n        for emitter_type in emitter_types\n    ]",
        "detail": "graphrag.index.emit.factories",
        "documentation": {}
    },
    {
        "label": "JsonTableEmitter",
        "kind": 6,
        "importPath": "graphrag.index.emit.json_table_emitter",
        "description": "graphrag.index.emit.json_table_emitter",
        "peekOfCode": "class JsonTableEmitter(TableEmitter):\n    \"\"\"JsonTableEmitter class.\"\"\"\n    _storage: PipelineStorage\n    def __init__(self, storage: PipelineStorage):\n        \"\"\"Create a new Json Table Emitter.\"\"\"\n        self._storage = storage\n    async def emit(self, name: str, data: pd.DataFrame) -> None:\n        \"\"\"Emit a dataframe to storage.\"\"\"\n        filename = f\"{name}.json\"\n        log.info(\"emitting JSON table %s\", filename)",
        "detail": "graphrag.index.emit.json_table_emitter",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.emit.json_table_emitter",
        "description": "graphrag.index.emit.json_table_emitter",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass JsonTableEmitter(TableEmitter):\n    \"\"\"JsonTableEmitter class.\"\"\"\n    _storage: PipelineStorage\n    def __init__(self, storage: PipelineStorage):\n        \"\"\"Create a new Json Table Emitter.\"\"\"\n        self._storage = storage\n    async def emit(self, name: str, data: pd.DataFrame) -> None:\n        \"\"\"Emit a dataframe to storage.\"\"\"\n        filename = f\"{name}.json\"",
        "detail": "graphrag.index.emit.json_table_emitter",
        "documentation": {}
    },
    {
        "label": "ParquetTableEmitter",
        "kind": 6,
        "importPath": "graphrag.index.emit.parquet_table_emitter",
        "description": "graphrag.index.emit.parquet_table_emitter",
        "peekOfCode": "class ParquetTableEmitter(TableEmitter):\n    \"\"\"ParquetTableEmitter class.\"\"\"\n    _storage: PipelineStorage\n    _on_error: ErrorHandlerFn\n    def __init__(\n        self,\n        storage: PipelineStorage,\n        on_error: ErrorHandlerFn,\n    ):\n        \"\"\"Create a new Parquet Table Emitter.\"\"\"",
        "detail": "graphrag.index.emit.parquet_table_emitter",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.emit.parquet_table_emitter",
        "description": "graphrag.index.emit.parquet_table_emitter",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass ParquetTableEmitter(TableEmitter):\n    \"\"\"ParquetTableEmitter class.\"\"\"\n    _storage: PipelineStorage\n    _on_error: ErrorHandlerFn\n    def __init__(\n        self,\n        storage: PipelineStorage,\n        on_error: ErrorHandlerFn,\n    ):",
        "detail": "graphrag.index.emit.parquet_table_emitter",
        "documentation": {}
    },
    {
        "label": "TableEmitter",
        "kind": 6,
        "importPath": "graphrag.index.emit.table_emitter",
        "description": "graphrag.index.emit.table_emitter",
        "peekOfCode": "class TableEmitter(Protocol):\n    \"\"\"TableEmitter protocol for emitting tables to a destination.\"\"\"\n    async def emit(self, name: str, data: pd.DataFrame) -> None:\n        \"\"\"Emit a dataframe to storage.\"\"\"",
        "detail": "graphrag.index.emit.table_emitter",
        "documentation": {}
    },
    {
        "label": "TableEmitterType",
        "kind": 6,
        "importPath": "graphrag.index.emit.types",
        "description": "graphrag.index.emit.types",
        "peekOfCode": "class TableEmitterType(str, Enum):\n    \"\"\"Table Emitter Types.\"\"\"\n    Json = \"json\"\n    Parquet = \"parquet\"\n    CSV = \"csv\"\n    def __str__(self):\n        \"\"\"Return the string representation of the enum value.\"\"\"\n        return self.value",
        "detail": "graphrag.index.emit.types",
        "documentation": {}
    },
    {
        "label": "create_base_documents",
        "kind": 2,
        "importPath": "graphrag.index.flows.create_base_documents",
        "description": "graphrag.index.flows.create_base_documents",
        "peekOfCode": "def create_base_documents(\n    documents: pd.DataFrame,\n    text_units: pd.DataFrame,\n    document_attribute_columns: list[str] | None = None,\n) -> pd.DataFrame:\n    \"\"\"Transform base documents by joining them with their text_units and adding optional attributes.\"\"\"\n    exploded = (\n        text_units.explode(\"document_ids\")\n        .loc[:, [\"id\", \"document_ids\", \"text\"]]\n        .rename(",
        "detail": "graphrag.index.flows.create_base_documents",
        "documentation": {}
    },
    {
        "label": "Aggregation",
        "kind": 6,
        "importPath": "graphrag.index.flows.create_base_text_units",
        "description": "graphrag.index.flows.create_base_text_units",
        "peekOfCode": "class Aggregation:\n    \"\"\"Aggregation class method definition.\"\"\"\n    column: str | None\n    operation: str\n    to: str\n    # Only useful for the concat operation\n    separator: str | None = None\ndef _get_pandas_agg_operation(agg: Aggregation) -> Any:\n    if agg.operation == \"string_concat\":\n        return (agg.separator or \",\").join",
        "detail": "graphrag.index.flows.create_base_text_units",
        "documentation": {}
    },
    {
        "label": "create_base_text_units",
        "kind": 2,
        "importPath": "graphrag.index.flows.create_base_text_units",
        "description": "graphrag.index.flows.create_base_text_units",
        "peekOfCode": "def create_base_text_units(\n    documents: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    chunk_column_name: str,\n    n_tokens_column_name: str,\n    chunk_by_columns: list[str],\n    chunk_strategy: dict[str, Any] | None = None,\n) -> pd.DataFrame:\n    \"\"\"All the steps to transform base text_units.\"\"\"\n    sort = documents.sort_values(by=[\"id\"], ascending=[True])",
        "detail": "graphrag.index.flows.create_base_text_units",
        "documentation": {}
    },
    {
        "label": "create_final_communities",
        "kind": 2,
        "importPath": "graphrag.index.flows.create_final_communities",
        "description": "graphrag.index.flows.create_final_communities",
        "peekOfCode": "def create_final_communities(\n    entity_graph: pd.DataFrame,\n    callbacks: VerbCallbacks,\n) -> pd.DataFrame:\n    \"\"\"All the steps to transform final communities.\"\"\"\n    graph_nodes = unpack_graph(entity_graph, callbacks, \"clustered_graph\", \"nodes\")\n    graph_edges = unpack_graph(entity_graph, callbacks, \"clustered_graph\", \"edges\")\n    # Merge graph_nodes with graph_edges for both source and target matches\n    source_clusters = graph_nodes.merge(\n        graph_edges, left_on=\"label\", right_on=\"source\", how=\"inner\"",
        "detail": "graphrag.index.flows.create_final_communities",
        "documentation": {}
    },
    {
        "label": "NodeEmbeddings",
        "kind": 6,
        "importPath": "graphrag.index.graph.embedding.embedding",
        "description": "graphrag.index.graph.embedding.embedding",
        "peekOfCode": "class NodeEmbeddings:\n    \"\"\"Node embeddings class definition.\"\"\"\n    nodes: list[str]\n    embeddings: np.ndarray\ndef embed_nod2vec(\n    graph: nx.Graph | nx.DiGraph,\n    dimensions: int = 1536,\n    num_walks: int = 10,\n    walk_length: int = 40,\n    window_size: int = 2,",
        "detail": "graphrag.index.graph.embedding.embedding",
        "documentation": {}
    },
    {
        "label": "embed_nod2vec",
        "kind": 2,
        "importPath": "graphrag.index.graph.embedding.embedding",
        "description": "graphrag.index.graph.embedding.embedding",
        "peekOfCode": "def embed_nod2vec(\n    graph: nx.Graph | nx.DiGraph,\n    dimensions: int = 1536,\n    num_walks: int = 10,\n    walk_length: int = 40,\n    window_size: int = 2,\n    iterations: int = 3,\n    random_seed: int = 86,\n) -> NodeEmbeddings:\n    \"\"\"Generate node embeddings using Node2Vec.\"\"\"",
        "detail": "graphrag.index.graph.embedding.embedding",
        "documentation": {}
    },
    {
        "label": "ClaimExtractorResult",
        "kind": 6,
        "importPath": "graphrag.index.graph.extractors.claims.claim_extractor",
        "description": "graphrag.index.graph.extractors.claims.claim_extractor",
        "peekOfCode": "class ClaimExtractorResult:\n    \"\"\"Claim extractor result class definition.\"\"\"\n    output: list[dict]\n    source_docs: dict[str, Any]\nclass ClaimExtractor:\n    \"\"\"Claim extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _extraction_prompt: str\n    _summary_prompt: str\n    _output_formatter_prompt: str",
        "detail": "graphrag.index.graph.extractors.claims.claim_extractor",
        "documentation": {}
    },
    {
        "label": "ClaimExtractor",
        "kind": 6,
        "importPath": "graphrag.index.graph.extractors.claims.claim_extractor",
        "description": "graphrag.index.graph.extractors.claims.claim_extractor",
        "peekOfCode": "class ClaimExtractor:\n    \"\"\"Claim extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _extraction_prompt: str\n    _summary_prompt: str\n    _output_formatter_prompt: str\n    _input_text_key: str\n    _input_entity_spec_key: str\n    _input_claim_description_key: str\n    _tuple_delimiter_key: str",
        "detail": "graphrag.index.graph.extractors.claims.claim_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TUPLE_DELIMITER",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.claims.claim_extractor",
        "description": "graphrag.index.graph.extractors.claims.claim_extractor",
        "peekOfCode": "DEFAULT_TUPLE_DELIMITER = \"<|>\"\nDEFAULT_RECORD_DELIMITER = \"##\"\nDEFAULT_COMPLETION_DELIMITER = \"<|COMPLETE|>\"\nlog = logging.getLogger(__name__)\n@dataclass\nclass ClaimExtractorResult:\n    \"\"\"Claim extractor result class definition.\"\"\"\n    output: list[dict]\n    source_docs: dict[str, Any]\nclass ClaimExtractor:",
        "detail": "graphrag.index.graph.extractors.claims.claim_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RECORD_DELIMITER",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.claims.claim_extractor",
        "description": "graphrag.index.graph.extractors.claims.claim_extractor",
        "peekOfCode": "DEFAULT_RECORD_DELIMITER = \"##\"\nDEFAULT_COMPLETION_DELIMITER = \"<|COMPLETE|>\"\nlog = logging.getLogger(__name__)\n@dataclass\nclass ClaimExtractorResult:\n    \"\"\"Claim extractor result class definition.\"\"\"\n    output: list[dict]\n    source_docs: dict[str, Any]\nclass ClaimExtractor:\n    \"\"\"Claim extractor class definition.\"\"\"",
        "detail": "graphrag.index.graph.extractors.claims.claim_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_COMPLETION_DELIMITER",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.claims.claim_extractor",
        "description": "graphrag.index.graph.extractors.claims.claim_extractor",
        "peekOfCode": "DEFAULT_COMPLETION_DELIMITER = \"<|COMPLETE|>\"\nlog = logging.getLogger(__name__)\n@dataclass\nclass ClaimExtractorResult:\n    \"\"\"Claim extractor result class definition.\"\"\"\n    output: list[dict]\n    source_docs: dict[str, Any]\nclass ClaimExtractor:\n    \"\"\"Claim extractor class definition.\"\"\"\n    _llm: CompletionLLM",
        "detail": "graphrag.index.graph.extractors.claims.claim_extractor",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.claims.claim_extractor",
        "description": "graphrag.index.graph.extractors.claims.claim_extractor",
        "peekOfCode": "log = logging.getLogger(__name__)\n@dataclass\nclass ClaimExtractorResult:\n    \"\"\"Claim extractor result class definition.\"\"\"\n    output: list[dict]\n    source_docs: dict[str, Any]\nclass ClaimExtractor:\n    \"\"\"Claim extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _extraction_prompt: str",
        "detail": "graphrag.index.graph.extractors.claims.claim_extractor",
        "documentation": {}
    },
    {
        "label": "CLAIM_EXTRACTION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.claims.prompts",
        "description": "graphrag.index.graph.extractors.claims.prompts",
        "peekOfCode": "CLAIM_EXTRACTION_PROMPT = \"\"\"\n-Target activity-\nYou are an intelligent assistant that helps a human analyst to analyze claims against certain entities presented in a text document.\n-Goal-\nGiven a text document that is potentially relevant to this activity, an entity specification, and a claim description, extract all entities that match the entity specification and all claims against those entities.\n-Steps-\n1. Extract all named entities that match the predefined entity specification. Entity specification can either be a list of entity names or a list of entity types.\n2. For each entity identified in step 1, extract all claims associated with the entity. Claims need to match the specified claim description, and the entity should be the subject of the claim.\nFor each claim, extract the following information:\n- Subject: name of the entity that is subject of the claim, capitalized. The subject entity is one that committed the action described in the claim. Subject needs to be one of the named entities identified in step 1.",
        "detail": "graphrag.index.graph.extractors.claims.prompts",
        "documentation": {}
    },
    {
        "label": "CONTINUE_PROMPT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.claims.prompts",
        "description": "graphrag.index.graph.extractors.claims.prompts",
        "peekOfCode": "CONTINUE_PROMPT = \"MANY entities were missed in the last extraction.  Add them below using the same format:\\n\"\nLOOP_PROMPT = \"It appears some entities may have still been missed.  Answer YES {tuple_delimiter} NO if there are still entities that need to be added.\\n\"",
        "detail": "graphrag.index.graph.extractors.claims.prompts",
        "documentation": {}
    },
    {
        "label": "LOOP_PROMPT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.claims.prompts",
        "description": "graphrag.index.graph.extractors.claims.prompts",
        "peekOfCode": "LOOP_PROMPT = \"It appears some entities may have still been missed.  Answer YES {tuple_delimiter} NO if there are still entities that need to be added.\\n\"",
        "detail": "graphrag.index.graph.extractors.claims.prompts",
        "documentation": {}
    },
    {
        "label": "build_mixed_context",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.build_mixed_context",
        "description": "graphrag.index.graph.extractors.community_reports.build_mixed_context",
        "peekOfCode": "def build_mixed_context(context: list[dict], max_tokens: int) -> str:\n    \"\"\"\n    Build parent context by concatenating all sub-communities' contexts.\n    If the context exceeds the limit, we use sub-community reports instead.\n    \"\"\"\n    sorted_context = sorted(\n        context, key=lambda x: x[schemas.CONTEXT_SIZE], reverse=True\n    )\n    # replace local context with sub-community reports, starting from the biggest sub-community\n    substitute_reports = []",
        "detail": "graphrag.index.graph.extractors.community_reports.build_mixed_context",
        "documentation": {}
    },
    {
        "label": "CommunityReportsResult",
        "kind": 6,
        "importPath": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "description": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "peekOfCode": "class CommunityReportsResult:\n    \"\"\"Community reports result class definition.\"\"\"\n    output: str\n    structured_output: dict\nclass CommunityReportsExtractor:\n    \"\"\"Community reports extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _input_text_key: str\n    _extraction_prompt: str\n    _output_formatter_prompt: str",
        "detail": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "documentation": {}
    },
    {
        "label": "CommunityReportsExtractor",
        "kind": 6,
        "importPath": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "description": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "peekOfCode": "class CommunityReportsExtractor:\n    \"\"\"Community reports extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _input_text_key: str\n    _extraction_prompt: str\n    _output_formatter_prompt: str\n    _on_error: ErrorHandlerFn\n    _max_report_length: int\n    def __init__(\n        self,",
        "detail": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "description": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "peekOfCode": "log = logging.getLogger(__name__)\n@dataclass\nclass CommunityReportsResult:\n    \"\"\"Community reports result class definition.\"\"\"\n    output: str\n    structured_output: dict\nclass CommunityReportsExtractor:\n    \"\"\"Community reports extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _input_text_key: str",
        "detail": "graphrag.index.graph.extractors.community_reports.community_reports_extractor",
        "documentation": {}
    },
    {
        "label": "prep_community_report_context",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.prep_community_report_context",
        "description": "graphrag.index.graph.extractors.community_reports.prep_community_report_context",
        "peekOfCode": "def prep_community_report_context(\n    report_df: pd.DataFrame | None,\n    community_hierarchy_df: pd.DataFrame,\n    local_context_df: pd.DataFrame,\n    level: int | str,\n    max_tokens: int,\n) -> pd.DataFrame:\n    \"\"\"\n    Prep context for each community in a given level.\n    For each community:",
        "detail": "graphrag.index.graph.extractors.community_reports.prep_community_report_context",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.prep_community_report_context",
        "description": "graphrag.index.graph.extractors.community_reports.prep_community_report_context",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef prep_community_report_context(\n    report_df: pd.DataFrame | None,\n    community_hierarchy_df: pd.DataFrame,\n    local_context_df: pd.DataFrame,\n    level: int | str,\n    max_tokens: int,\n) -> pd.DataFrame:\n    \"\"\"\n    Prep context for each community in a given level.",
        "detail": "graphrag.index.graph.extractors.community_reports.prep_community_report_context",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_REPORT_PROMPT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.prompts",
        "description": "graphrag.index.graph.extractors.community_reports.prompts",
        "peekOfCode": "COMMUNITY_REPORT_PROMPT = \"\"\"\nYou are an AI assistant that helps a human analyst to perform general information discovery. Information discovery is the process of identifying and assessing relevant information associated with certain entities (e.g., organizations and individuals) within a network.\n# Goal\nWrite a comprehensive report of a community, given a list of entities that belong to the community as well as their relationships and optional associated claims. The report will be used to inform decision-makers about information associated with the community and their potential impact. The content of this report includes an overview of the community's key entities, their legal compliance, technical capabilities, reputation, and noteworthy claims.\n# Report Structure\nThe report should include the following sections:\n- TITLE: community's name that represents its key entities - title should be short but specific. When possible, include representative named entities in the title.\n- SUMMARY: An executive summary of the community's overall structure, how its entities are related to each other, and significant information associated with its entities.\n- IMPACT SEVERITY RATING: a float score between 0-10 that represents the severity of IMPACT posed by entities within the community.  IMPACT is the scored importance of a community.\n- RATING EXPLANATION: Give a single sentence explanation of the IMPACT severity rating.",
        "detail": "graphrag.index.graph.extractors.community_reports.prompts",
        "documentation": {}
    },
    {
        "label": "NODE_ID",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "NODE_ID = \"human_readable_id\"\nNODE_NAME = \"title\"\nNODE_DESCRIPTION = \"description\"\nNODE_DEGREE = \"degree\"\nNODE_DETAILS = \"node_details\"\nNODE_COMMUNITY = \"community\"\nNODE_LEVEL = \"level\"\n# POST-PREP EDGE TABLE SCHEMA\nEDGE_ID = \"human_readable_id\"\nEDGE_SOURCE = \"source\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_NAME",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "NODE_NAME = \"title\"\nNODE_DESCRIPTION = \"description\"\nNODE_DEGREE = \"degree\"\nNODE_DETAILS = \"node_details\"\nNODE_COMMUNITY = \"community\"\nNODE_LEVEL = \"level\"\n# POST-PREP EDGE TABLE SCHEMA\nEDGE_ID = \"human_readable_id\"\nEDGE_SOURCE = \"source\"\nEDGE_TARGET = \"target\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_DESCRIPTION",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "NODE_DESCRIPTION = \"description\"\nNODE_DEGREE = \"degree\"\nNODE_DETAILS = \"node_details\"\nNODE_COMMUNITY = \"community\"\nNODE_LEVEL = \"level\"\n# POST-PREP EDGE TABLE SCHEMA\nEDGE_ID = \"human_readable_id\"\nEDGE_SOURCE = \"source\"\nEDGE_TARGET = \"target\"\nEDGE_DESCRIPTION = \"description\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_DEGREE",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "NODE_DEGREE = \"degree\"\nNODE_DETAILS = \"node_details\"\nNODE_COMMUNITY = \"community\"\nNODE_LEVEL = \"level\"\n# POST-PREP EDGE TABLE SCHEMA\nEDGE_ID = \"human_readable_id\"\nEDGE_SOURCE = \"source\"\nEDGE_TARGET = \"target\"\nEDGE_DESCRIPTION = \"description\"\nEDGE_DEGREE = \"rank\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_DETAILS",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "NODE_DETAILS = \"node_details\"\nNODE_COMMUNITY = \"community\"\nNODE_LEVEL = \"level\"\n# POST-PREP EDGE TABLE SCHEMA\nEDGE_ID = \"human_readable_id\"\nEDGE_SOURCE = \"source\"\nEDGE_TARGET = \"target\"\nEDGE_DESCRIPTION = \"description\"\nEDGE_DEGREE = \"rank\"\nEDGE_DETAILS = \"edge_details\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_COMMUNITY",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "NODE_COMMUNITY = \"community\"\nNODE_LEVEL = \"level\"\n# POST-PREP EDGE TABLE SCHEMA\nEDGE_ID = \"human_readable_id\"\nEDGE_SOURCE = \"source\"\nEDGE_TARGET = \"target\"\nEDGE_DESCRIPTION = \"description\"\nEDGE_DEGREE = \"rank\"\nEDGE_DETAILS = \"edge_details\"\nEDGE_WEIGHT = \"weight\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "NODE_LEVEL",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "NODE_LEVEL = \"level\"\n# POST-PREP EDGE TABLE SCHEMA\nEDGE_ID = \"human_readable_id\"\nEDGE_SOURCE = \"source\"\nEDGE_TARGET = \"target\"\nEDGE_DESCRIPTION = \"description\"\nEDGE_DEGREE = \"rank\"\nEDGE_DETAILS = \"edge_details\"\nEDGE_WEIGHT = \"weight\"\n# POST-PREP CLAIM TABLE SCHEMA",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_ID",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "EDGE_ID = \"human_readable_id\"\nEDGE_SOURCE = \"source\"\nEDGE_TARGET = \"target\"\nEDGE_DESCRIPTION = \"description\"\nEDGE_DEGREE = \"rank\"\nEDGE_DETAILS = \"edge_details\"\nEDGE_WEIGHT = \"weight\"\n# POST-PREP CLAIM TABLE SCHEMA\nCLAIM_ID = \"human_readable_id\"\nCLAIM_SUBJECT = \"subject_id\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_SOURCE",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "EDGE_SOURCE = \"source\"\nEDGE_TARGET = \"target\"\nEDGE_DESCRIPTION = \"description\"\nEDGE_DEGREE = \"rank\"\nEDGE_DETAILS = \"edge_details\"\nEDGE_WEIGHT = \"weight\"\n# POST-PREP CLAIM TABLE SCHEMA\nCLAIM_ID = \"human_readable_id\"\nCLAIM_SUBJECT = \"subject_id\"\nCLAIM_TYPE = \"type\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_TARGET",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "EDGE_TARGET = \"target\"\nEDGE_DESCRIPTION = \"description\"\nEDGE_DEGREE = \"rank\"\nEDGE_DETAILS = \"edge_details\"\nEDGE_WEIGHT = \"weight\"\n# POST-PREP CLAIM TABLE SCHEMA\nCLAIM_ID = \"human_readable_id\"\nCLAIM_SUBJECT = \"subject_id\"\nCLAIM_TYPE = \"type\"\nCLAIM_STATUS = \"status\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_DESCRIPTION",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "EDGE_DESCRIPTION = \"description\"\nEDGE_DEGREE = \"rank\"\nEDGE_DETAILS = \"edge_details\"\nEDGE_WEIGHT = \"weight\"\n# POST-PREP CLAIM TABLE SCHEMA\nCLAIM_ID = \"human_readable_id\"\nCLAIM_SUBJECT = \"subject_id\"\nCLAIM_TYPE = \"type\"\nCLAIM_STATUS = \"status\"\nCLAIM_DESCRIPTION = \"description\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_DEGREE",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "EDGE_DEGREE = \"rank\"\nEDGE_DETAILS = \"edge_details\"\nEDGE_WEIGHT = \"weight\"\n# POST-PREP CLAIM TABLE SCHEMA\nCLAIM_ID = \"human_readable_id\"\nCLAIM_SUBJECT = \"subject_id\"\nCLAIM_TYPE = \"type\"\nCLAIM_STATUS = \"status\"\nCLAIM_DESCRIPTION = \"description\"\nCLAIM_DETAILS = \"claim_details\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_DETAILS",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "EDGE_DETAILS = \"edge_details\"\nEDGE_WEIGHT = \"weight\"\n# POST-PREP CLAIM TABLE SCHEMA\nCLAIM_ID = \"human_readable_id\"\nCLAIM_SUBJECT = \"subject_id\"\nCLAIM_TYPE = \"type\"\nCLAIM_STATUS = \"status\"\nCLAIM_DESCRIPTION = \"description\"\nCLAIM_DETAILS = \"claim_details\"\n# COMMUNITY HIERARCHY TABLE SCHEMA",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EDGE_WEIGHT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "EDGE_WEIGHT = \"weight\"\n# POST-PREP CLAIM TABLE SCHEMA\nCLAIM_ID = \"human_readable_id\"\nCLAIM_SUBJECT = \"subject_id\"\nCLAIM_TYPE = \"type\"\nCLAIM_STATUS = \"status\"\nCLAIM_DESCRIPTION = \"description\"\nCLAIM_DETAILS = \"claim_details\"\n# COMMUNITY HIERARCHY TABLE SCHEMA\nSUB_COMMUNITY = \"sub_communitty\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_ID",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CLAIM_ID = \"human_readable_id\"\nCLAIM_SUBJECT = \"subject_id\"\nCLAIM_TYPE = \"type\"\nCLAIM_STATUS = \"status\"\nCLAIM_DESCRIPTION = \"description\"\nCLAIM_DETAILS = \"claim_details\"\n# COMMUNITY HIERARCHY TABLE SCHEMA\nSUB_COMMUNITY = \"sub_communitty\"\nSUB_COMMUNITY_SIZE = \"sub_community_size\"\nCOMMUNITY_LEVEL = \"level\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_SUBJECT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CLAIM_SUBJECT = \"subject_id\"\nCLAIM_TYPE = \"type\"\nCLAIM_STATUS = \"status\"\nCLAIM_DESCRIPTION = \"description\"\nCLAIM_DETAILS = \"claim_details\"\n# COMMUNITY HIERARCHY TABLE SCHEMA\nSUB_COMMUNITY = \"sub_communitty\"\nSUB_COMMUNITY_SIZE = \"sub_community_size\"\nCOMMUNITY_LEVEL = \"level\"\n# COMMUNITY CONTEXT TABLE SCHEMA",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_TYPE",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CLAIM_TYPE = \"type\"\nCLAIM_STATUS = \"status\"\nCLAIM_DESCRIPTION = \"description\"\nCLAIM_DETAILS = \"claim_details\"\n# COMMUNITY HIERARCHY TABLE SCHEMA\nSUB_COMMUNITY = \"sub_communitty\"\nSUB_COMMUNITY_SIZE = \"sub_community_size\"\nCOMMUNITY_LEVEL = \"level\"\n# COMMUNITY CONTEXT TABLE SCHEMA\nALL_CONTEXT = \"all_context\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_STATUS",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CLAIM_STATUS = \"status\"\nCLAIM_DESCRIPTION = \"description\"\nCLAIM_DETAILS = \"claim_details\"\n# COMMUNITY HIERARCHY TABLE SCHEMA\nSUB_COMMUNITY = \"sub_communitty\"\nSUB_COMMUNITY_SIZE = \"sub_community_size\"\nCOMMUNITY_LEVEL = \"level\"\n# COMMUNITY CONTEXT TABLE SCHEMA\nALL_CONTEXT = \"all_context\"\nCONTEXT_STRING = \"context_string\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_DESCRIPTION",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CLAIM_DESCRIPTION = \"description\"\nCLAIM_DETAILS = \"claim_details\"\n# COMMUNITY HIERARCHY TABLE SCHEMA\nSUB_COMMUNITY = \"sub_communitty\"\nSUB_COMMUNITY_SIZE = \"sub_community_size\"\nCOMMUNITY_LEVEL = \"level\"\n# COMMUNITY CONTEXT TABLE SCHEMA\nALL_CONTEXT = \"all_context\"\nCONTEXT_STRING = \"context_string\"\nCONTEXT_SIZE = \"context_size\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CLAIM_DETAILS",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CLAIM_DETAILS = \"claim_details\"\n# COMMUNITY HIERARCHY TABLE SCHEMA\nSUB_COMMUNITY = \"sub_communitty\"\nSUB_COMMUNITY_SIZE = \"sub_community_size\"\nCOMMUNITY_LEVEL = \"level\"\n# COMMUNITY CONTEXT TABLE SCHEMA\nALL_CONTEXT = \"all_context\"\nCONTEXT_STRING = \"context_string\"\nCONTEXT_SIZE = \"context_size\"\nCONTEXT_EXCEED_FLAG = \"context_exceed_limit\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "SUB_COMMUNITY",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "SUB_COMMUNITY = \"sub_communitty\"\nSUB_COMMUNITY_SIZE = \"sub_community_size\"\nCOMMUNITY_LEVEL = \"level\"\n# COMMUNITY CONTEXT TABLE SCHEMA\nALL_CONTEXT = \"all_context\"\nCONTEXT_STRING = \"context_string\"\nCONTEXT_SIZE = \"context_size\"\nCONTEXT_EXCEED_FLAG = \"context_exceed_limit\"\n# COMMUNITY REPORT TABLE SCHEMA\nREPORT_ID = \"id\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "SUB_COMMUNITY_SIZE",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "SUB_COMMUNITY_SIZE = \"sub_community_size\"\nCOMMUNITY_LEVEL = \"level\"\n# COMMUNITY CONTEXT TABLE SCHEMA\nALL_CONTEXT = \"all_context\"\nCONTEXT_STRING = \"context_string\"\nCONTEXT_SIZE = \"context_size\"\nCONTEXT_EXCEED_FLAG = \"context_exceed_limit\"\n# COMMUNITY REPORT TABLE SCHEMA\nREPORT_ID = \"id\"\nCOMMUNITY_ID = \"id\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_LEVEL",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "COMMUNITY_LEVEL = \"level\"\n# COMMUNITY CONTEXT TABLE SCHEMA\nALL_CONTEXT = \"all_context\"\nCONTEXT_STRING = \"context_string\"\nCONTEXT_SIZE = \"context_size\"\nCONTEXT_EXCEED_FLAG = \"context_exceed_limit\"\n# COMMUNITY REPORT TABLE SCHEMA\nREPORT_ID = \"id\"\nCOMMUNITY_ID = \"id\"\nCOMMUNITY_LEVEL = \"level\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "ALL_CONTEXT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "ALL_CONTEXT = \"all_context\"\nCONTEXT_STRING = \"context_string\"\nCONTEXT_SIZE = \"context_size\"\nCONTEXT_EXCEED_FLAG = \"context_exceed_limit\"\n# COMMUNITY REPORT TABLE SCHEMA\nREPORT_ID = \"id\"\nCOMMUNITY_ID = \"id\"\nCOMMUNITY_LEVEL = \"level\"\nTITLE = \"title\"\nSUMMARY = \"summary\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CONTEXT_STRING",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CONTEXT_STRING = \"context_string\"\nCONTEXT_SIZE = \"context_size\"\nCONTEXT_EXCEED_FLAG = \"context_exceed_limit\"\n# COMMUNITY REPORT TABLE SCHEMA\nREPORT_ID = \"id\"\nCOMMUNITY_ID = \"id\"\nCOMMUNITY_LEVEL = \"level\"\nTITLE = \"title\"\nSUMMARY = \"summary\"\nFINDINGS = \"findings\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CONTEXT_SIZE",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CONTEXT_SIZE = \"context_size\"\nCONTEXT_EXCEED_FLAG = \"context_exceed_limit\"\n# COMMUNITY REPORT TABLE SCHEMA\nREPORT_ID = \"id\"\nCOMMUNITY_ID = \"id\"\nCOMMUNITY_LEVEL = \"level\"\nTITLE = \"title\"\nSUMMARY = \"summary\"\nFINDINGS = \"findings\"\nRATING = \"rank\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "CONTEXT_EXCEED_FLAG",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "CONTEXT_EXCEED_FLAG = \"context_exceed_limit\"\n# COMMUNITY REPORT TABLE SCHEMA\nREPORT_ID = \"id\"\nCOMMUNITY_ID = \"id\"\nCOMMUNITY_LEVEL = \"level\"\nTITLE = \"title\"\nSUMMARY = \"summary\"\nFINDINGS = \"findings\"\nRATING = \"rank\"\nEXPLANATION = \"rating_explanation\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "REPORT_ID",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "REPORT_ID = \"id\"\nCOMMUNITY_ID = \"id\"\nCOMMUNITY_LEVEL = \"level\"\nTITLE = \"title\"\nSUMMARY = \"summary\"\nFINDINGS = \"findings\"\nRATING = \"rank\"\nEXPLANATION = \"rating_explanation\"\nFULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_ID",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "COMMUNITY_ID = \"id\"\nCOMMUNITY_LEVEL = \"level\"\nTITLE = \"title\"\nSUMMARY = \"summary\"\nFINDINGS = \"findings\"\nRATING = \"rank\"\nEXPLANATION = \"rating_explanation\"\nFULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_LEVEL",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "COMMUNITY_LEVEL = \"level\"\nTITLE = \"title\"\nSUMMARY = \"summary\"\nFINDINGS = \"findings\"\nRATING = \"rank\"\nEXPLANATION = \"rating_explanation\"\nFULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "TITLE",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "TITLE = \"title\"\nSUMMARY = \"summary\"\nFINDINGS = \"findings\"\nRATING = \"rank\"\nEXPLANATION = \"rating_explanation\"\nFULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "SUMMARY",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "SUMMARY = \"summary\"\nFINDINGS = \"findings\"\nRATING = \"rank\"\nEXPLANATION = \"rating_explanation\"\nFULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "FINDINGS",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "FINDINGS = \"findings\"\nRATING = \"rank\"\nEXPLANATION = \"rating_explanation\"\nFULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "RATING",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "RATING = \"rank\"\nEXPLANATION = \"rating_explanation\"\nFULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "EXPLANATION",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "EXPLANATION = \"rating_explanation\"\nFULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "FULL_CONTENT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "FULL_CONTENT = \"full_content\"\nFULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "FULL_CONTENT_JSON",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.community_reports.schemas",
        "description": "graphrag.index.graph.extractors.community_reports.schemas",
        "peekOfCode": "FULL_CONTENT_JSON = \"full_content_json\"",
        "detail": "graphrag.index.graph.extractors.community_reports.schemas",
        "documentation": {}
    },
    {
        "label": "sort_context",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.sort_context",
        "description": "graphrag.index.graph.extractors.community_reports.sort_context",
        "peekOfCode": "def sort_context(\n    local_context: list[dict],\n    sub_community_reports: list[dict] | None = None,\n    max_tokens: int | None = None,\n    node_id_column: str = schemas.NODE_ID,\n    node_name_column: str = schemas.NODE_NAME,\n    node_details_column: str = schemas.NODE_DETAILS,\n    edge_id_column: str = schemas.EDGE_ID,\n    edge_details_column: str = schemas.EDGE_DETAILS,\n    edge_degree_column: str = schemas.EDGE_DEGREE,",
        "detail": "graphrag.index.graph.extractors.community_reports.sort_context",
        "documentation": {}
    },
    {
        "label": "set_context_size",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.utils",
        "description": "graphrag.index.graph.extractors.community_reports.utils",
        "peekOfCode": "def set_context_size(df: pd.DataFrame) -> None:\n    \"\"\"Measure the number of tokens in the context.\"\"\"\n    df[schemas.CONTEXT_SIZE] = df[schemas.CONTEXT_STRING].apply(lambda x: num_tokens(x))\ndef set_context_exceeds_flag(df: pd.DataFrame, max_tokens: int) -> None:\n    \"\"\"Set a flag to indicate if the context exceeds the limit.\"\"\"\n    df[schemas.CONTEXT_EXCEED_FLAG] = df[schemas.CONTEXT_SIZE].apply(\n        lambda x: x > max_tokens\n    )\ndef get_levels(df: pd.DataFrame, level_column: str = schemas.NODE_LEVEL) -> list[int]:\n    \"\"\"Get the levels of the communities.\"\"\"",
        "detail": "graphrag.index.graph.extractors.community_reports.utils",
        "documentation": {}
    },
    {
        "label": "set_context_exceeds_flag",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.utils",
        "description": "graphrag.index.graph.extractors.community_reports.utils",
        "peekOfCode": "def set_context_exceeds_flag(df: pd.DataFrame, max_tokens: int) -> None:\n    \"\"\"Set a flag to indicate if the context exceeds the limit.\"\"\"\n    df[schemas.CONTEXT_EXCEED_FLAG] = df[schemas.CONTEXT_SIZE].apply(\n        lambda x: x > max_tokens\n    )\ndef get_levels(df: pd.DataFrame, level_column: str = schemas.NODE_LEVEL) -> list[int]:\n    \"\"\"Get the levels of the communities.\"\"\"\n    result = sorted(df[level_column].fillna(-1).unique().tolist(), reverse=True)\n    return [r for r in result if r != -1]\ndef filter_nodes_to_level(node_df: pd.DataFrame, level: int) -> pd.DataFrame:",
        "detail": "graphrag.index.graph.extractors.community_reports.utils",
        "documentation": {}
    },
    {
        "label": "get_levels",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.utils",
        "description": "graphrag.index.graph.extractors.community_reports.utils",
        "peekOfCode": "def get_levels(df: pd.DataFrame, level_column: str = schemas.NODE_LEVEL) -> list[int]:\n    \"\"\"Get the levels of the communities.\"\"\"\n    result = sorted(df[level_column].fillna(-1).unique().tolist(), reverse=True)\n    return [r for r in result if r != -1]\ndef filter_nodes_to_level(node_df: pd.DataFrame, level: int) -> pd.DataFrame:\n    \"\"\"Filter nodes to level.\"\"\"\n    return cast(pd.DataFrame, node_df[node_df[schemas.NODE_LEVEL] == level])\ndef filter_edges_to_nodes(edge_df: pd.DataFrame, nodes: list[str]) -> pd.DataFrame:\n    \"\"\"Filter edges to nodes.\"\"\"\n    return cast(",
        "detail": "graphrag.index.graph.extractors.community_reports.utils",
        "documentation": {}
    },
    {
        "label": "filter_nodes_to_level",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.utils",
        "description": "graphrag.index.graph.extractors.community_reports.utils",
        "peekOfCode": "def filter_nodes_to_level(node_df: pd.DataFrame, level: int) -> pd.DataFrame:\n    \"\"\"Filter nodes to level.\"\"\"\n    return cast(pd.DataFrame, node_df[node_df[schemas.NODE_LEVEL] == level])\ndef filter_edges_to_nodes(edge_df: pd.DataFrame, nodes: list[str]) -> pd.DataFrame:\n    \"\"\"Filter edges to nodes.\"\"\"\n    return cast(\n        pd.DataFrame,\n        edge_df[\n            edge_df[schemas.EDGE_SOURCE].isin(nodes)\n            & edge_df[schemas.EDGE_TARGET].isin(nodes)",
        "detail": "graphrag.index.graph.extractors.community_reports.utils",
        "documentation": {}
    },
    {
        "label": "filter_edges_to_nodes",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.utils",
        "description": "graphrag.index.graph.extractors.community_reports.utils",
        "peekOfCode": "def filter_edges_to_nodes(edge_df: pd.DataFrame, nodes: list[str]) -> pd.DataFrame:\n    \"\"\"Filter edges to nodes.\"\"\"\n    return cast(\n        pd.DataFrame,\n        edge_df[\n            edge_df[schemas.EDGE_SOURCE].isin(nodes)\n            & edge_df[schemas.EDGE_TARGET].isin(nodes)\n        ],\n    )\ndef filter_claims_to_nodes(claims_df: pd.DataFrame, nodes: list[str]) -> pd.DataFrame:",
        "detail": "graphrag.index.graph.extractors.community_reports.utils",
        "documentation": {}
    },
    {
        "label": "filter_claims_to_nodes",
        "kind": 2,
        "importPath": "graphrag.index.graph.extractors.community_reports.utils",
        "description": "graphrag.index.graph.extractors.community_reports.utils",
        "peekOfCode": "def filter_claims_to_nodes(claims_df: pd.DataFrame, nodes: list[str]) -> pd.DataFrame:\n    \"\"\"Filter edges to nodes.\"\"\"\n    return cast(\n        pd.DataFrame,\n        claims_df[claims_df[schemas.CLAIM_SUBJECT].isin(nodes)],\n    )",
        "detail": "graphrag.index.graph.extractors.community_reports.utils",
        "documentation": {}
    },
    {
        "label": "GraphExtractionResult",
        "kind": 6,
        "importPath": "graphrag.index.graph.extractors.graph.graph_extractor",
        "description": "graphrag.index.graph.extractors.graph.graph_extractor",
        "peekOfCode": "class GraphExtractionResult:\n    \"\"\"Unipartite graph extraction result class definition.\"\"\"\n    output: nx.Graph\n    source_docs: dict[Any, Any]\nclass GraphExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _join_descriptions: bool\n    _tuple_delimiter_key: str\n    _record_delimiter_key: str",
        "detail": "graphrag.index.graph.extractors.graph.graph_extractor",
        "documentation": {}
    },
    {
        "label": "GraphExtractor",
        "kind": 6,
        "importPath": "graphrag.index.graph.extractors.graph.graph_extractor",
        "description": "graphrag.index.graph.extractors.graph.graph_extractor",
        "peekOfCode": "class GraphExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _join_descriptions: bool\n    _tuple_delimiter_key: str\n    _record_delimiter_key: str\n    _entity_types_key: str\n    _input_text_key: str\n    _completion_delimiter_key: str\n    _entity_name_key: str",
        "detail": "graphrag.index.graph.extractors.graph.graph_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TUPLE_DELIMITER",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.graph.graph_extractor",
        "description": "graphrag.index.graph.extractors.graph.graph_extractor",
        "peekOfCode": "DEFAULT_TUPLE_DELIMITER = \"<|>\"\nDEFAULT_RECORD_DELIMITER = \"##\"\nDEFAULT_COMPLETION_DELIMITER = \"<|COMPLETE|>\"\nDEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\n@dataclass\nclass GraphExtractionResult:\n    \"\"\"Unipartite graph extraction result class definition.\"\"\"\n    output: nx.Graph\n    source_docs: dict[Any, Any]\nclass GraphExtractor:",
        "detail": "graphrag.index.graph.extractors.graph.graph_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RECORD_DELIMITER",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.graph.graph_extractor",
        "description": "graphrag.index.graph.extractors.graph.graph_extractor",
        "peekOfCode": "DEFAULT_RECORD_DELIMITER = \"##\"\nDEFAULT_COMPLETION_DELIMITER = \"<|COMPLETE|>\"\nDEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\n@dataclass\nclass GraphExtractionResult:\n    \"\"\"Unipartite graph extraction result class definition.\"\"\"\n    output: nx.Graph\n    source_docs: dict[Any, Any]\nclass GraphExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"",
        "detail": "graphrag.index.graph.extractors.graph.graph_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_COMPLETION_DELIMITER",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.graph.graph_extractor",
        "description": "graphrag.index.graph.extractors.graph.graph_extractor",
        "peekOfCode": "DEFAULT_COMPLETION_DELIMITER = \"<|COMPLETE|>\"\nDEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\n@dataclass\nclass GraphExtractionResult:\n    \"\"\"Unipartite graph extraction result class definition.\"\"\"\n    output: nx.Graph\n    source_docs: dict[Any, Any]\nclass GraphExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"\n    _llm: CompletionLLM",
        "detail": "graphrag.index.graph.extractors.graph.graph_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENTITY_TYPES",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.graph.graph_extractor",
        "description": "graphrag.index.graph.extractors.graph.graph_extractor",
        "peekOfCode": "DEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\n@dataclass\nclass GraphExtractionResult:\n    \"\"\"Unipartite graph extraction result class definition.\"\"\"\n    output: nx.Graph\n    source_docs: dict[Any, Any]\nclass GraphExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _join_descriptions: bool",
        "detail": "graphrag.index.graph.extractors.graph.graph_extractor",
        "documentation": {}
    },
    {
        "label": "GRAPH_EXTRACTION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.graph.prompts",
        "description": "graphrag.index.graph.extractors.graph.prompts",
        "peekOfCode": "GRAPH_EXTRACTION_PROMPT = \"\"\"\n-Goal-\nGiven a text document that is potentially relevant to this activity and a list of entity types, identify all entities of those types from the text and all relationships among the identified entities.\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: One of the following types: [{entity_types}]\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity as (\"entity\"{tuple_delimiter}<entity_name>{tuple_delimiter}<entity_type>{tuple_delimiter}<entity_description>)\n2. From the entities identified in step 1, identify all pairs of (source_entity, target_entity) that are *clearly related* to each other.",
        "detail": "graphrag.index.graph.extractors.graph.prompts",
        "documentation": {}
    },
    {
        "label": "CONTINUE_PROMPT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.graph.prompts",
        "description": "graphrag.index.graph.extractors.graph.prompts",
        "peekOfCode": "CONTINUE_PROMPT = \"MANY entities and relationships were missed in the last extraction. Remember to ONLY emit entities that match any of the previously extracted types. Add them below using the same format:\\n\"\nLOOP_PROMPT = \"It appears some entities and relationships may have still been missed.  Answer YES | NO if there are still entities or relationships that need to be added.\\n\"",
        "detail": "graphrag.index.graph.extractors.graph.prompts",
        "documentation": {}
    },
    {
        "label": "LOOP_PROMPT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.graph.prompts",
        "description": "graphrag.index.graph.extractors.graph.prompts",
        "peekOfCode": "LOOP_PROMPT = \"It appears some entities and relationships may have still been missed.  Answer YES | NO if there are still entities or relationships that need to be added.\\n\"",
        "detail": "graphrag.index.graph.extractors.graph.prompts",
        "documentation": {}
    },
    {
        "label": "SummarizationResult",
        "kind": 6,
        "importPath": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "description": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "peekOfCode": "class SummarizationResult:\n    \"\"\"Unipartite graph extraction result class definition.\"\"\"\n    items: str | tuple[str, str]\n    description: str\nclass SummarizeExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _entity_name_key: str\n    _input_descriptions_key: str\n    _summarization_prompt: str",
        "detail": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "documentation": {}
    },
    {
        "label": "SummarizeExtractor",
        "kind": 6,
        "importPath": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "description": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "peekOfCode": "class SummarizeExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _entity_name_key: str\n    _input_descriptions_key: str\n    _summarization_prompt: str\n    _on_error: ErrorHandlerFn\n    _max_summary_length: int\n    _max_input_tokens: int\n    def __init__(",
        "detail": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MAX_INPUT_TOKENS",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "description": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "peekOfCode": "DEFAULT_MAX_INPUT_TOKENS = 4_000\n# Max token count for LLM answers\nDEFAULT_MAX_SUMMARY_LENGTH = 500\n@dataclass\nclass SummarizationResult:\n    \"\"\"Unipartite graph extraction result class definition.\"\"\"\n    items: str | tuple[str, str]\n    description: str\nclass SummarizeExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"",
        "detail": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MAX_SUMMARY_LENGTH",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "description": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "peekOfCode": "DEFAULT_MAX_SUMMARY_LENGTH = 500\n@dataclass\nclass SummarizationResult:\n    \"\"\"Unipartite graph extraction result class definition.\"\"\"\n    items: str | tuple[str, str]\n    description: str\nclass SummarizeExtractor:\n    \"\"\"Unipartite graph extractor class definition.\"\"\"\n    _llm: CompletionLLM\n    _entity_name_key: str",
        "detail": "graphrag.index.graph.extractors.summarize.description_summary_extractor",
        "documentation": {}
    },
    {
        "label": "SUMMARIZE_PROMPT",
        "kind": 5,
        "importPath": "graphrag.index.graph.extractors.summarize.prompts",
        "description": "graphrag.index.graph.extractors.summarize.prompts",
        "peekOfCode": "SUMMARIZE_PROMPT = \"\"\"\nYou are a helpful assistant responsible for generating a comprehensive summary of the data provided below.\nGiven one or two entities, and a list of descriptions, all related to the same entity or group of entities.\nPlease concatenate all of these into a single, comprehensive description. Make sure to include information collected from all the descriptions.\nIf the provided descriptions are contradictory, please resolve the contradictions and provide a single, coherent summary.\nMake sure it is written in third person, and include the entity names so we have the full context.\n#######\n-Data-\nEntities: {entity_name}\nDescription List: {description_list}",
        "detail": "graphrag.index.graph.extractors.summarize.prompts",
        "documentation": {}
    },
    {
        "label": "normalize_node_names",
        "kind": 2,
        "importPath": "graphrag.index.graph.utils.normalize_node_names",
        "description": "graphrag.index.graph.utils.normalize_node_names",
        "peekOfCode": "def normalize_node_names(graph: nx.Graph | nx.DiGraph) -> nx.Graph | nx.DiGraph:\n    \"\"\"Normalize node names.\"\"\"\n    node_mapping = {node: html.unescape(node.upper().strip()) for node in graph.nodes()}  # type: ignore\n    return nx.relabel_nodes(graph, node_mapping)",
        "detail": "graphrag.index.graph.utils.normalize_node_names",
        "documentation": {}
    },
    {
        "label": "stable_largest_connected_component",
        "kind": 2,
        "importPath": "graphrag.index.graph.utils.stable_lcc",
        "description": "graphrag.index.graph.utils.stable_lcc",
        "peekOfCode": "def stable_largest_connected_component(graph: nx.Graph) -> nx.Graph:\n    \"\"\"Return the largest connected component of the graph, with nodes and edges sorted in a stable way.\"\"\"\n    graph = graph.copy()\n    graph = cast(nx.Graph, largest_connected_component(graph))\n    graph = normalize_node_names(graph)\n    return _stabilize_graph(graph)\ndef _stabilize_graph(graph: nx.Graph) -> nx.Graph:\n    \"\"\"Ensure an undirected graph with the same relationships will always be read the same way.\"\"\"\n    fixed_graph = nx.DiGraph() if graph.is_directed() else nx.Graph()\n    sorted_nodes = graph.nodes(data=True)",
        "detail": "graphrag.index.graph.utils.stable_lcc",
        "documentation": {}
    },
    {
        "label": "get_zero_positions",
        "kind": 2,
        "importPath": "graphrag.index.graph.visualization.compute_umap_positions",
        "description": "graphrag.index.graph.visualization.compute_umap_positions",
        "peekOfCode": "def get_zero_positions(\n    node_labels: list[str],\n    node_categories: list[int] | None = None,\n    node_sizes: list[int] | None = None,\n    three_d: bool | None = False,\n) -> list[NodePosition]:\n    \"\"\"Project embedding vectors down to 2D/3D using UMAP.\"\"\"\n    embedding_position_data: list[NodePosition] = []\n    for index, node_name in enumerate(node_labels):\n        node_category = 1 if node_categories is None else node_categories[index]",
        "detail": "graphrag.index.graph.visualization.compute_umap_positions",
        "documentation": {}
    },
    {
        "label": "compute_umap_positions",
        "kind": 2,
        "importPath": "graphrag.index.graph.visualization.compute_umap_positions",
        "description": "graphrag.index.graph.visualization.compute_umap_positions",
        "peekOfCode": "def compute_umap_positions(\n    embedding_vectors: np.ndarray,\n    node_labels: list[str],\n    node_categories: list[int] | None = None,\n    node_sizes: list[int] | None = None,\n    min_dist: float = 0.75,\n    n_neighbors: int = 25,\n    spread: int = 1,\n    metric: str = \"euclidean\",\n    n_components: int = 2,",
        "detail": "graphrag.index.graph.visualization.compute_umap_positions",
        "documentation": {}
    },
    {
        "label": "visualize_embedding",
        "kind": 2,
        "importPath": "graphrag.index.graph.visualization.compute_umap_positions",
        "description": "graphrag.index.graph.visualization.compute_umap_positions",
        "peekOfCode": "def visualize_embedding(\n    graph,\n    umap_positions: list[dict],\n):\n    \"\"\"Project embedding down to 2D using UMAP and visualize.\"\"\"\n    # rendering\n    plt.clf()\n    figure = plt.gcf()\n    ax = plt.gca()\n    ax.set_axis_off()",
        "detail": "graphrag.index.graph.visualization.compute_umap_positions",
        "documentation": {}
    },
    {
        "label": "NodePosition",
        "kind": 6,
        "importPath": "graphrag.index.graph.visualization.typing",
        "description": "graphrag.index.graph.visualization.typing",
        "peekOfCode": "class NodePosition:\n    \"\"\"Node position class definition.\"\"\"\n    label: str\n    cluster: str\n    size: float\n    x: float\n    y: float\n    z: float | None = None\n    def to_pandas(self) -> tuple[str, float, float, str, float]:\n        \"\"\"To pandas method definition.\"\"\"",
        "detail": "graphrag.index.graph.visualization.typing",
        "documentation": {}
    },
    {
        "label": "GraphLayout",
        "kind": 5,
        "importPath": "graphrag.index.graph.visualization.typing",
        "description": "graphrag.index.graph.visualization.typing",
        "peekOfCode": "GraphLayout = list[NodePosition]",
        "detail": "graphrag.index.graph.visualization.typing",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.input.csv",
        "description": "graphrag.index.input.csv",
        "peekOfCode": "log = logging.getLogger(__name__)\nDEFAULT_FILE_PATTERN = re.compile(r\"(?P<filename>[^\\\\/]).csv$\")\ninput_type = \"csv\"\nasync def load(\n    config: PipelineInputConfig,\n    progress: ProgressReporter | None,\n    storage: PipelineStorage,\n) -> pd.DataFrame:\n    \"\"\"Load csv inputs from a directory.\"\"\"\n    csv_config = cast(PipelineCSVInputConfig, config)",
        "detail": "graphrag.index.input.csv",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FILE_PATTERN",
        "kind": 5,
        "importPath": "graphrag.index.input.csv",
        "description": "graphrag.index.input.csv",
        "peekOfCode": "DEFAULT_FILE_PATTERN = re.compile(r\"(?P<filename>[^\\\\/]).csv$\")\ninput_type = \"csv\"\nasync def load(\n    config: PipelineInputConfig,\n    progress: ProgressReporter | None,\n    storage: PipelineStorage,\n) -> pd.DataFrame:\n    \"\"\"Load csv inputs from a directory.\"\"\"\n    csv_config = cast(PipelineCSVInputConfig, config)\n    log.info(\"Loading csv files from %s\", csv_config.base_dir)",
        "detail": "graphrag.index.input.csv",
        "documentation": {}
    },
    {
        "label": "input_type",
        "kind": 5,
        "importPath": "graphrag.index.input.csv",
        "description": "graphrag.index.input.csv",
        "peekOfCode": "input_type = \"csv\"\nasync def load(\n    config: PipelineInputConfig,\n    progress: ProgressReporter | None,\n    storage: PipelineStorage,\n) -> pd.DataFrame:\n    \"\"\"Load csv inputs from a directory.\"\"\"\n    csv_config = cast(PipelineCSVInputConfig, config)\n    log.info(\"Loading csv files from %s\", csv_config.base_dir)\n    async def load_file(path: str, group: dict | None) -> pd.DataFrame:",
        "detail": "graphrag.index.input.csv",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.input.load_input",
        "description": "graphrag.index.input.load_input",
        "peekOfCode": "log = logging.getLogger(__name__)\nloaders: dict[str, Callable[..., Awaitable[pd.DataFrame]]] = {\n    text: load_text,\n    csv: load_csv,\n}\nasync def load_input(\n    config: PipelineInputConfig | InputConfig,\n    progress_reporter: ProgressReporter | None = None,\n    root_dir: str | None = None,\n) -> pd.DataFrame:",
        "detail": "graphrag.index.input.load_input",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FILE_PATTERN",
        "kind": 5,
        "importPath": "graphrag.index.input.text",
        "description": "graphrag.index.input.text",
        "peekOfCode": "DEFAULT_FILE_PATTERN = re.compile(\n    r\".*[\\\\/](?P<source>[^\\\\/]+)[\\\\/](?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})_(?P<author>[^_]+)_\\d+\\.txt\"\n)\ninput_type = \"text\"\nlog = logging.getLogger(__name__)\nasync def load(\n    config: PipelineInputConfig,\n    progress: ProgressReporter | None,\n    storage: PipelineStorage,\n) -> pd.DataFrame:",
        "detail": "graphrag.index.input.text",
        "documentation": {}
    },
    {
        "label": "input_type",
        "kind": 5,
        "importPath": "graphrag.index.input.text",
        "description": "graphrag.index.input.text",
        "peekOfCode": "input_type = \"text\"\nlog = logging.getLogger(__name__)\nasync def load(\n    config: PipelineInputConfig,\n    progress: ProgressReporter | None,\n    storage: PipelineStorage,\n) -> pd.DataFrame:\n    \"\"\"Load text inputs from a directory.\"\"\"\n    async def load_file(\n        path: str, group: dict | None = None, _encoding: str = \"utf-8\"",
        "detail": "graphrag.index.input.text",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.input.text",
        "description": "graphrag.index.input.text",
        "peekOfCode": "log = logging.getLogger(__name__)\nasync def load(\n    config: PipelineInputConfig,\n    progress: ProgressReporter | None,\n    storage: PipelineStorage,\n) -> pd.DataFrame:\n    \"\"\"Load text inputs from a directory.\"\"\"\n    async def load_file(\n        path: str, group: dict | None = None, _encoding: str = \"utf-8\"\n    ) -> dict[str, Any]:",
        "detail": "graphrag.index.input.text",
        "documentation": {}
    },
    {
        "label": "load_llm",
        "kind": 2,
        "importPath": "graphrag.index.llm.load_llm",
        "description": "graphrag.index.llm.load_llm",
        "peekOfCode": "def load_llm(\n    name: str,\n    llm_type: LLMType,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache | None,\n    llm_config: dict[str, Any] | None = None,\n    chat_only=False,\n) -> CompletionLLM:\n    \"\"\"Load the LLM for the entity extraction chain.\"\"\"\n    on_error = _create_error_handler(callbacks)",
        "detail": "graphrag.index.llm.load_llm",
        "documentation": {}
    },
    {
        "label": "load_llm_embeddings",
        "kind": 2,
        "importPath": "graphrag.index.llm.load_llm",
        "description": "graphrag.index.llm.load_llm",
        "peekOfCode": "def load_llm_embeddings(\n    name: str,\n    llm_type: LLMType,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache | None,\n    llm_config: dict[str, Any] | None = None,\n    chat_only=False,\n) -> EmbeddingLLM:\n    \"\"\"Load the LLM for the entity extraction chain.\"\"\"\n    on_error = _create_error_handler(callbacks)",
        "detail": "graphrag.index.llm.load_llm",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.llm.load_llm",
        "description": "graphrag.index.llm.load_llm",
        "peekOfCode": "log = logging.getLogger(__name__)\n_semaphores: dict[str, asyncio.Semaphore] = {}\n_rate_limiters: dict[str, LLMLimiter] = {}\ndef load_llm(\n    name: str,\n    llm_type: LLMType,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache | None,\n    llm_config: dict[str, Any] | None = None,\n    chat_only=False,",
        "detail": "graphrag.index.llm.load_llm",
        "documentation": {}
    },
    {
        "label": "loaders",
        "kind": 5,
        "importPath": "graphrag.index.llm.load_llm",
        "description": "graphrag.index.llm.load_llm",
        "peekOfCode": "loaders = {\n    LLMType.OpenAI: {\n        \"load\": _load_openai_completion_llm,\n        \"chat\": False,\n    },\n    LLMType.AzureOpenAI: {\n        \"load\": _load_azure_openai_completion_llm,\n        \"chat\": False,\n    },\n    LLMType.OpenAIChat: {",
        "detail": "graphrag.index.llm.load_llm",
        "documentation": {}
    },
    {
        "label": "chunk_text",
        "kind": 2,
        "importPath": "graphrag.index.operations.chunk_text.chunk_text",
        "description": "graphrag.index.operations.chunk_text.chunk_text",
        "peekOfCode": "def chunk_text(\n    input: pd.DataFrame,\n    column: str,\n    to: str,\n    callbacks: VerbCallbacks,\n    strategy: dict[str, Any] | None = None,\n) -> pd.DataFrame:\n    \"\"\"\n    Chunk a piece of text into smaller pieces.\n    ## Usage",
        "detail": "graphrag.index.operations.chunk_text.chunk_text",
        "documentation": {}
    },
    {
        "label": "run_strategy",
        "kind": 2,
        "importPath": "graphrag.index.operations.chunk_text.chunk_text",
        "description": "graphrag.index.operations.chunk_text.chunk_text",
        "peekOfCode": "def run_strategy(\n    strategy: ChunkStrategy,\n    input: ChunkInput,\n    strategy_args: dict[str, Any],\n    tick: ProgressTicker,\n) -> list[str | tuple[list[str] | None, str, int]]:\n    \"\"\"Run strategy method definition.\"\"\"\n    if isinstance(input, str):\n        return [item.text_chunk for item in strategy([input], {**strategy_args}, tick)]\n    # We can work with both just a list of text content",
        "detail": "graphrag.index.operations.chunk_text.chunk_text",
        "documentation": {}
    },
    {
        "label": "load_strategy",
        "kind": 2,
        "importPath": "graphrag.index.operations.chunk_text.chunk_text",
        "description": "graphrag.index.operations.chunk_text.chunk_text",
        "peekOfCode": "def load_strategy(strategy: ChunkStrategyType) -> ChunkStrategy:\n    \"\"\"Load strategy method definition.\"\"\"\n    match strategy:\n        case ChunkStrategyType.tokens:\n            from .strategies import run_tokens\n            return run_tokens\n        case ChunkStrategyType.sentence:\n            # NLTK\n            from graphrag.index.bootstrap import bootstrap\n            from .strategies import run_sentences",
        "detail": "graphrag.index.operations.chunk_text.chunk_text",
        "documentation": {}
    },
    {
        "label": "run_tokens",
        "kind": 2,
        "importPath": "graphrag.index.operations.chunk_text.strategies",
        "description": "graphrag.index.operations.chunk_text.strategies",
        "peekOfCode": "def run_tokens(\n    input: list[str], args: dict[str, Any], tick: ProgressTicker\n) -> Iterable[TextChunk]:\n    \"\"\"Chunks text into chunks based on encoding tokens.\"\"\"\n    tokens_per_chunk = args.get(\"chunk_size\", defs.CHUNK_SIZE)\n    chunk_overlap = args.get(\"chunk_overlap\", defs.CHUNK_OVERLAP)\n    encoding_name = args.get(\"encoding_name\", defs.ENCODING_MODEL)\n    enc = tiktoken.get_encoding(encoding_name)\n    def encode(text: str) -> list[int]:\n        if not isinstance(text, str):",
        "detail": "graphrag.index.operations.chunk_text.strategies",
        "documentation": {}
    },
    {
        "label": "run_sentences",
        "kind": 2,
        "importPath": "graphrag.index.operations.chunk_text.strategies",
        "description": "graphrag.index.operations.chunk_text.strategies",
        "peekOfCode": "def run_sentences(\n    input: list[str], _args: dict[str, Any], tick: ProgressTicker\n) -> Iterable[TextChunk]:\n    \"\"\"Chunks text into multiple parts by sentence.\"\"\"\n    for doc_idx, text in enumerate(input):\n        sentences = nltk.sent_tokenize(text)\n        for sentence in sentences:\n            yield TextChunk(\n                text_chunk=sentence,\n                source_doc_indices=[doc_idx],",
        "detail": "graphrag.index.operations.chunk_text.strategies",
        "documentation": {}
    },
    {
        "label": "TextChunk",
        "kind": 6,
        "importPath": "graphrag.index.operations.chunk_text.typing",
        "description": "graphrag.index.operations.chunk_text.typing",
        "peekOfCode": "class TextChunk:\n    \"\"\"Text chunk class definition.\"\"\"\n    text_chunk: str\n    source_doc_indices: list[int]\n    n_tokens: int | None = None\nChunkInput = str | list[str] | list[tuple[str, str]]\n\"\"\"Input to a chunking strategy. Can be a string, a list of strings, or a list of tuples of (id, text).\"\"\"\nChunkStrategy = Callable[\n    [list[str], dict[str, Any], ProgressTicker], Iterable[TextChunk]\n]",
        "detail": "graphrag.index.operations.chunk_text.typing",
        "documentation": {}
    },
    {
        "label": "ChunkStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.chunk_text.typing",
        "description": "graphrag.index.operations.chunk_text.typing",
        "peekOfCode": "class ChunkStrategyType(str, Enum):\n    \"\"\"ChunkStrategy class definition.\"\"\"\n    tokens = \"tokens\"\n    sentence = \"sentence\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'",
        "detail": "graphrag.index.operations.chunk_text.typing",
        "documentation": {}
    },
    {
        "label": "ChunkInput",
        "kind": 5,
        "importPath": "graphrag.index.operations.chunk_text.typing",
        "description": "graphrag.index.operations.chunk_text.typing",
        "peekOfCode": "ChunkInput = str | list[str] | list[tuple[str, str]]\n\"\"\"Input to a chunking strategy. Can be a string, a list of strings, or a list of tuples of (id, text).\"\"\"\nChunkStrategy = Callable[\n    [list[str], dict[str, Any], ProgressTicker], Iterable[TextChunk]\n]\nclass ChunkStrategyType(str, Enum):\n    \"\"\"ChunkStrategy class definition.\"\"\"\n    tokens = \"tokens\"\n    sentence = \"sentence\"\n    def __repr__(self):",
        "detail": "graphrag.index.operations.chunk_text.typing",
        "documentation": {}
    },
    {
        "label": "ChunkStrategy",
        "kind": 5,
        "importPath": "graphrag.index.operations.chunk_text.typing",
        "description": "graphrag.index.operations.chunk_text.typing",
        "peekOfCode": "ChunkStrategy = Callable[\n    [list[str], dict[str, Any], ProgressTicker], Iterable[TextChunk]\n]\nclass ChunkStrategyType(str, Enum):\n    \"\"\"ChunkStrategy class definition.\"\"\"\n    tokens = \"tokens\"\n    sentence = \"sentence\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'",
        "detail": "graphrag.index.operations.chunk_text.typing",
        "documentation": {}
    },
    {
        "label": "EmbedGraphStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.embed_graph.embed_graph",
        "description": "graphrag.index.operations.embed_graph.embed_graph",
        "peekOfCode": "class EmbedGraphStrategyType(str, Enum):\n    \"\"\"EmbedGraphStrategyType class definition.\"\"\"\n    node2vec = \"node2vec\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nasync def embed_graph(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    strategy: dict[str, Any],",
        "detail": "graphrag.index.operations.embed_graph.embed_graph",
        "documentation": {}
    },
    {
        "label": "run_embeddings",
        "kind": 2,
        "importPath": "graphrag.index.operations.embed_graph.embed_graph",
        "description": "graphrag.index.operations.embed_graph.embed_graph",
        "peekOfCode": "def run_embeddings(\n    strategy: EmbedGraphStrategyType,\n    graphml_or_graph: str | nx.Graph,\n    args: dict[str, Any],\n) -> NodeEmbeddings:\n    \"\"\"Run embeddings method definition.\"\"\"\n    graph = load_graph(graphml_or_graph)\n    match strategy:\n        case EmbedGraphStrategyType.node2vec:\n            return run_node_2_vec(graph, args)",
        "detail": "graphrag.index.operations.embed_graph.embed_graph",
        "documentation": {}
    },
    {
        "label": "run_node_2_vec",
        "kind": 2,
        "importPath": "graphrag.index.operations.embed_graph.embed_graph",
        "description": "graphrag.index.operations.embed_graph.embed_graph",
        "peekOfCode": "def run_node_2_vec(graph: nx.Graph, args: dict[str, Any]) -> NodeEmbeddings:\n    \"\"\"Run method definition.\"\"\"\n    if args.get(\"use_lcc\", True):\n        graph = stable_largest_connected_component(graph)\n    # create graph embedding using node2vec\n    embeddings = embed_nod2vec(\n        graph=graph,\n        dimensions=args.get(\"dimensions\", 1536),\n        num_walks=args.get(\"num_walks\", 10),\n        walk_length=args.get(\"walk_length\", 40),",
        "detail": "graphrag.index.operations.embed_graph.embed_graph",
        "documentation": {}
    },
    {
        "label": "NodeList",
        "kind": 5,
        "importPath": "graphrag.index.operations.embed_graph.typing",
        "description": "graphrag.index.operations.embed_graph.typing",
        "peekOfCode": "NodeList = list[str]\nEmbeddingList = list[Any]\nNodeEmbeddings = dict[str, list[float]]\n\"\"\"Label -> Embedding\"\"\"",
        "detail": "graphrag.index.operations.embed_graph.typing",
        "documentation": {}
    },
    {
        "label": "EmbeddingList",
        "kind": 5,
        "importPath": "graphrag.index.operations.embed_graph.typing",
        "description": "graphrag.index.operations.embed_graph.typing",
        "peekOfCode": "EmbeddingList = list[Any]\nNodeEmbeddings = dict[str, list[float]]\n\"\"\"Label -> Embedding\"\"\"",
        "detail": "graphrag.index.operations.embed_graph.typing",
        "documentation": {}
    },
    {
        "label": "NodeEmbeddings",
        "kind": 5,
        "importPath": "graphrag.index.operations.embed_graph.typing",
        "description": "graphrag.index.operations.embed_graph.typing",
        "peekOfCode": "NodeEmbeddings = dict[str, list[float]]\n\"\"\"Label -> Embedding\"\"\"",
        "detail": "graphrag.index.operations.embed_graph.typing",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.embed_text.strategies.openai",
        "description": "graphrag.index.operations.embed_text.strategies.openai",
        "peekOfCode": "log = logging.getLogger(__name__)\nasync def run(\n    input: list[str],\n    callbacks: VerbCallbacks,\n    cache: PipelineCache,\n    args: dict[str, Any],\n) -> TextEmbeddingResult:\n    \"\"\"Run the Claim extraction chain.\"\"\"\n    if is_null(input):\n        return TextEmbeddingResult(embeddings=None)",
        "detail": "graphrag.index.operations.embed_text.strategies.openai",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingResult",
        "kind": 6,
        "importPath": "graphrag.index.operations.embed_text.strategies.typing",
        "description": "graphrag.index.operations.embed_text.strategies.typing",
        "peekOfCode": "class TextEmbeddingResult:\n    \"\"\"Text embedding result class definition.\"\"\"\n    embeddings: list[list[float] | None] | None\nTextEmbeddingStrategy = Callable[\n    [\n        list[str],\n        VerbCallbacks,\n        PipelineCache,\n        dict,\n    ],",
        "detail": "graphrag.index.operations.embed_text.strategies.typing",
        "documentation": {}
    },
    {
        "label": "TextEmbeddingStrategy",
        "kind": 5,
        "importPath": "graphrag.index.operations.embed_text.strategies.typing",
        "description": "graphrag.index.operations.embed_text.strategies.typing",
        "peekOfCode": "TextEmbeddingStrategy = Callable[\n    [\n        list[str],\n        VerbCallbacks,\n        PipelineCache,\n        dict,\n    ],\n    Awaitable[TextEmbeddingResult],\n]",
        "detail": "graphrag.index.operations.embed_text.strategies.typing",
        "documentation": {}
    },
    {
        "label": "TextEmbedStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.embed_text.embed_text",
        "description": "graphrag.index.operations.embed_text.embed_text",
        "peekOfCode": "class TextEmbedStrategyType(str, Enum):\n    \"\"\"TextEmbedStrategyType class definition.\"\"\"\n    openai = \"openai\"\n    mock = \"mock\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nasync def embed_text(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,",
        "detail": "graphrag.index.operations.embed_text.embed_text",
        "documentation": {}
    },
    {
        "label": "load_strategy",
        "kind": 2,
        "importPath": "graphrag.index.operations.embed_text.embed_text",
        "description": "graphrag.index.operations.embed_text.embed_text",
        "peekOfCode": "def load_strategy(strategy: TextEmbedStrategyType) -> TextEmbeddingStrategy:\n    \"\"\"Load strategy method definition.\"\"\"\n    match strategy:\n        case TextEmbedStrategyType.openai:\n            from .strategies.openai import run as run_openai\n            return run_openai\n        case TextEmbedStrategyType.mock:\n            from .strategies.mock import run as run_mock\n            return run_mock\n        case _:",
        "detail": "graphrag.index.operations.embed_text.embed_text",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.embed_text.embed_text",
        "description": "graphrag.index.operations.embed_text.embed_text",
        "peekOfCode": "log = logging.getLogger(__name__)\n# Per Azure OpenAI Limits\n# https://learn.microsoft.com/en-us/azure/ai-services/openai/reference\nDEFAULT_EMBEDDING_BATCH_SIZE = 500\nclass TextEmbedStrategyType(str, Enum):\n    \"\"\"TextEmbedStrategyType class definition.\"\"\"\n    openai = \"openai\"\n    mock = \"mock\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"",
        "detail": "graphrag.index.operations.embed_text.embed_text",
        "documentation": {}
    },
    {
        "label": "DEFAULT_EMBEDDING_BATCH_SIZE",
        "kind": 5,
        "importPath": "graphrag.index.operations.embed_text.embed_text",
        "description": "graphrag.index.operations.embed_text.embed_text",
        "peekOfCode": "DEFAULT_EMBEDDING_BATCH_SIZE = 500\nclass TextEmbedStrategyType(str, Enum):\n    \"\"\"TextEmbedStrategyType class definition.\"\"\"\n    openai = \"openai\"\n    mock = \"mock\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nasync def embed_text(\n    input: pd.DataFrame,",
        "detail": "graphrag.index.operations.embed_text.embed_text",
        "documentation": {}
    },
    {
        "label": "load_strategy",
        "kind": 2,
        "importPath": "graphrag.index.operations.extract_covariates.extract_covariates",
        "description": "graphrag.index.operations.extract_covariates.extract_covariates",
        "peekOfCode": "def load_strategy(strategy_type: ExtractClaimsStrategyType) -> CovariateExtractStrategy:\n    \"\"\"Load strategy method definition.\"\"\"\n    match strategy_type:\n        case ExtractClaimsStrategyType.graph_intelligence:\n            from .strategies import run_graph_intelligence\n            return run_graph_intelligence\n        case _:\n            msg = f\"Unknown strategy: {strategy_type}\"\n            raise ValueError(msg)\ndef create_row_from_claim_data(row, covariate_data: Covariate, covariate_type: str):",
        "detail": "graphrag.index.operations.extract_covariates.extract_covariates",
        "documentation": {}
    },
    {
        "label": "create_row_from_claim_data",
        "kind": 2,
        "importPath": "graphrag.index.operations.extract_covariates.extract_covariates",
        "description": "graphrag.index.operations.extract_covariates.extract_covariates",
        "peekOfCode": "def create_row_from_claim_data(row, covariate_data: Covariate, covariate_type: str):\n    \"\"\"Create a row from the claim data and the input row.\"\"\"\n    return {**row, **asdict(covariate_data), \"covariate_type\": covariate_type}",
        "detail": "graphrag.index.operations.extract_covariates.extract_covariates",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_covariates.extract_covariates",
        "description": "graphrag.index.operations.extract_covariates.extract_covariates",
        "peekOfCode": "log = logging.getLogger(__name__)\nDEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nasync def extract_covariates(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache,\n    column: str,\n    covariate_type: str,\n    strategy: dict[str, Any] | None,\n    async_mode: AsyncType = AsyncType.AsyncIO,",
        "detail": "graphrag.index.operations.extract_covariates.extract_covariates",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENTITY_TYPES",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_covariates.extract_covariates",
        "description": "graphrag.index.operations.extract_covariates.extract_covariates",
        "peekOfCode": "DEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nasync def extract_covariates(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache,\n    column: str,\n    covariate_type: str,\n    strategy: dict[str, Any] | None,\n    async_mode: AsyncType = AsyncType.AsyncIO,\n    entity_types: list[str] | None = None,",
        "detail": "graphrag.index.operations.extract_covariates.extract_covariates",
        "documentation": {}
    },
    {
        "label": "create_covariate",
        "kind": 2,
        "importPath": "graphrag.index.operations.extract_covariates.strategies",
        "description": "graphrag.index.operations.extract_covariates.strategies",
        "peekOfCode": "def create_covariate(item: dict[str, Any]) -> Covariate:\n    \"\"\"Create a covariate from the item.\"\"\"\n    return Covariate(\n        subject_id=item.get(\"subject_id\"),\n        object_id=item.get(\"object_id\"),\n        type=item.get(\"type\"),\n        status=item.get(\"status\"),\n        start_date=item.get(\"start_date\"),\n        end_date=item.get(\"end_date\"),\n        description=item.get(\"description\"),",
        "detail": "graphrag.index.operations.extract_covariates.strategies",
        "documentation": {}
    },
    {
        "label": "Covariate",
        "kind": 6,
        "importPath": "graphrag.index.operations.extract_covariates.typing",
        "description": "graphrag.index.operations.extract_covariates.typing",
        "peekOfCode": "class Covariate:\n    \"\"\"Covariate class definition.\"\"\"\n    covariate_type: str | None = None\n    subject_id: str | None = None\n    object_id: str | None = None\n    type: str | None = None\n    status: str | None = None\n    start_date: str | None = None\n    end_date: str | None = None\n    description: str | None = None",
        "detail": "graphrag.index.operations.extract_covariates.typing",
        "documentation": {}
    },
    {
        "label": "CovariateExtractionResult",
        "kind": 6,
        "importPath": "graphrag.index.operations.extract_covariates.typing",
        "description": "graphrag.index.operations.extract_covariates.typing",
        "peekOfCode": "class CovariateExtractionResult:\n    \"\"\"Covariate extraction result class definition.\"\"\"\n    covariate_data: list[Covariate]\nCovariateExtractStrategy = Callable[\n    [\n        Iterable[str],\n        list[str],\n        dict[str, str],\n        VerbCallbacks,\n        PipelineCache,",
        "detail": "graphrag.index.operations.extract_covariates.typing",
        "documentation": {}
    },
    {
        "label": "ExtractClaimsStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.extract_covariates.typing",
        "description": "graphrag.index.operations.extract_covariates.typing",
        "peekOfCode": "class ExtractClaimsStrategyType(str, Enum):\n    \"\"\"ExtractClaimsStrategyType class definition.\"\"\"\n    graph_intelligence = \"graph_intelligence\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'",
        "detail": "graphrag.index.operations.extract_covariates.typing",
        "documentation": {}
    },
    {
        "label": "CovariateExtractStrategy",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_covariates.typing",
        "description": "graphrag.index.operations.extract_covariates.typing",
        "peekOfCode": "CovariateExtractStrategy = Callable[\n    [\n        Iterable[str],\n        list[str],\n        dict[str, str],\n        VerbCallbacks,\n        PipelineCache,\n        dict[str, Any],\n    ],\n    Awaitable[CovariateExtractionResult],",
        "detail": "graphrag.index.operations.extract_covariates.typing",
        "documentation": {}
    },
    {
        "label": "Document",
        "kind": 6,
        "importPath": "graphrag.index.operations.extract_entities.strategies.typing",
        "description": "graphrag.index.operations.extract_entities.strategies.typing",
        "peekOfCode": "class Document:\n    \"\"\"Document class definition.\"\"\"\n    text: str\n    id: str\n@dataclass\nclass EntityExtractionResult:\n    \"\"\"Entity extraction result class definition.\"\"\"\n    entities: list[ExtractedEntity]\n    graphml_graph: str | None\nEntityExtractStrategy = Callable[",
        "detail": "graphrag.index.operations.extract_entities.strategies.typing",
        "documentation": {}
    },
    {
        "label": "EntityExtractionResult",
        "kind": 6,
        "importPath": "graphrag.index.operations.extract_entities.strategies.typing",
        "description": "graphrag.index.operations.extract_entities.strategies.typing",
        "peekOfCode": "class EntityExtractionResult:\n    \"\"\"Entity extraction result class definition.\"\"\"\n    entities: list[ExtractedEntity]\n    graphml_graph: str | None\nEntityExtractStrategy = Callable[\n    [\n        list[Document],\n        EntityTypes,\n        VerbCallbacks,\n        PipelineCache,",
        "detail": "graphrag.index.operations.extract_entities.strategies.typing",
        "documentation": {}
    },
    {
        "label": "ExtractedEntity",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_entities.strategies.typing",
        "description": "graphrag.index.operations.extract_entities.strategies.typing",
        "peekOfCode": "ExtractedEntity = dict[str, Any]\nStrategyConfig = dict[str, Any]\nEntityTypes = list[str]\n@dataclass\nclass Document:\n    \"\"\"Document class definition.\"\"\"\n    text: str\n    id: str\n@dataclass\nclass EntityExtractionResult:",
        "detail": "graphrag.index.operations.extract_entities.strategies.typing",
        "documentation": {}
    },
    {
        "label": "StrategyConfig",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_entities.strategies.typing",
        "description": "graphrag.index.operations.extract_entities.strategies.typing",
        "peekOfCode": "StrategyConfig = dict[str, Any]\nEntityTypes = list[str]\n@dataclass\nclass Document:\n    \"\"\"Document class definition.\"\"\"\n    text: str\n    id: str\n@dataclass\nclass EntityExtractionResult:\n    \"\"\"Entity extraction result class definition.\"\"\"",
        "detail": "graphrag.index.operations.extract_entities.strategies.typing",
        "documentation": {}
    },
    {
        "label": "EntityTypes",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_entities.strategies.typing",
        "description": "graphrag.index.operations.extract_entities.strategies.typing",
        "peekOfCode": "EntityTypes = list[str]\n@dataclass\nclass Document:\n    \"\"\"Document class definition.\"\"\"\n    text: str\n    id: str\n@dataclass\nclass EntityExtractionResult:\n    \"\"\"Entity extraction result class definition.\"\"\"\n    entities: list[ExtractedEntity]",
        "detail": "graphrag.index.operations.extract_entities.strategies.typing",
        "documentation": {}
    },
    {
        "label": "EntityExtractStrategy",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_entities.strategies.typing",
        "description": "graphrag.index.operations.extract_entities.strategies.typing",
        "peekOfCode": "EntityExtractStrategy = Callable[\n    [\n        list[Document],\n        EntityTypes,\n        VerbCallbacks,\n        PipelineCache,\n        StrategyConfig,\n    ],\n    Awaitable[EntityExtractionResult],\n]",
        "detail": "graphrag.index.operations.extract_entities.strategies.typing",
        "documentation": {}
    },
    {
        "label": "ExtractEntityStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.extract_entities.extract_entities",
        "description": "graphrag.index.operations.extract_entities.extract_entities",
        "peekOfCode": "class ExtractEntityStrategyType(str, Enum):\n    \"\"\"ExtractEntityStrategyType class definition.\"\"\"\n    graph_intelligence = \"graph_intelligence\"\n    graph_intelligence_json = \"graph_intelligence_json\"\n    nltk = \"nltk\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nDEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nasync def extract_entities(",
        "detail": "graphrag.index.operations.extract_entities.extract_entities",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_entities.extract_entities",
        "description": "graphrag.index.operations.extract_entities.extract_entities",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass ExtractEntityStrategyType(str, Enum):\n    \"\"\"ExtractEntityStrategyType class definition.\"\"\"\n    graph_intelligence = \"graph_intelligence\"\n    graph_intelligence_json = \"graph_intelligence_json\"\n    nltk = \"nltk\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nDEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]",
        "detail": "graphrag.index.operations.extract_entities.extract_entities",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENTITY_TYPES",
        "kind": 5,
        "importPath": "graphrag.index.operations.extract_entities.extract_entities",
        "description": "graphrag.index.operations.extract_entities.extract_entities",
        "peekOfCode": "DEFAULT_ENTITY_TYPES = [\"organization\", \"person\", \"geo\", \"event\"]\nasync def extract_entities(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache,\n    column: str,\n    id_column: str,\n    to: str,\n    strategy: dict[str, Any] | None,\n    graph_to: str | None = None,",
        "detail": "graphrag.index.operations.extract_entities.extract_entities",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "graphrag.index.operations.layout_graph.methods.umap",
        "description": "graphrag.index.operations.layout_graph.methods.umap",
        "peekOfCode": "def run(\n    graph: nx.Graph,\n    embeddings: NodeEmbeddings,\n    args: dict[str, Any],\n    on_error: ErrorHandlerFn,\n) -> GraphLayout:\n    \"\"\"Run method definition.\"\"\"\n    node_clusters = []\n    node_sizes = []\n    embeddings = _filter_raw_embeddings(embeddings)",
        "detail": "graphrag.index.operations.layout_graph.methods.umap",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.layout_graph.methods.umap",
        "description": "graphrag.index.operations.layout_graph.methods.umap",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef run(\n    graph: nx.Graph,\n    embeddings: NodeEmbeddings,\n    args: dict[str, Any],\n    on_error: ErrorHandlerFn,\n) -> GraphLayout:\n    \"\"\"Run method definition.\"\"\"\n    node_clusters = []\n    node_sizes = []",
        "detail": "graphrag.index.operations.layout_graph.methods.umap",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "graphrag.index.operations.layout_graph.methods.zero",
        "description": "graphrag.index.operations.layout_graph.methods.zero",
        "peekOfCode": "def run(\n    graph: nx.Graph,\n    _args: dict[str, Any],\n    on_error: ErrorHandlerFn,\n) -> GraphLayout:\n    \"\"\"Run method definition.\"\"\"\n    node_clusters = []\n    node_sizes = []\n    nodes = list(graph.nodes)\n    for node_id in nodes:",
        "detail": "graphrag.index.operations.layout_graph.methods.zero",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.layout_graph.methods.zero",
        "description": "graphrag.index.operations.layout_graph.methods.zero",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef run(\n    graph: nx.Graph,\n    _args: dict[str, Any],\n    on_error: ErrorHandlerFn,\n) -> GraphLayout:\n    \"\"\"Run method definition.\"\"\"\n    node_clusters = []\n    node_sizes = []\n    nodes = list(graph.nodes)",
        "detail": "graphrag.index.operations.layout_graph.methods.zero",
        "documentation": {}
    },
    {
        "label": "LayoutGraphStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.layout_graph.layout_graph",
        "description": "graphrag.index.operations.layout_graph.layout_graph",
        "peekOfCode": "class LayoutGraphStrategyType(str, Enum):\n    \"\"\"LayoutGraphStrategyType class definition.\"\"\"\n    umap = \"umap\"\n    zero = \"zero\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\ndef layout_graph(\n    input_df: pd.DataFrame,\n    callbacks: VerbCallbacks,",
        "detail": "graphrag.index.operations.layout_graph.layout_graph",
        "documentation": {}
    },
    {
        "label": "layout_graph",
        "kind": 2,
        "importPath": "graphrag.index.operations.layout_graph.layout_graph",
        "description": "graphrag.index.operations.layout_graph.layout_graph",
        "peekOfCode": "def layout_graph(\n    input_df: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    strategy: dict[str, Any],\n    embeddings_column: str,\n    graph_column: str,\n    to: str,\n    graph_to: str | None = None,\n):\n    \"\"\"",
        "detail": "graphrag.index.operations.layout_graph.layout_graph",
        "documentation": {}
    },
    {
        "label": "merge_graphs",
        "kind": 2,
        "importPath": "graphrag.index.operations.merge_graphs.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs.merge_graphs",
        "peekOfCode": "def merge_graphs(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    column: str,\n    to: str,\n    nodes: dict[str, Any] = DEFAULT_NODE_OPERATIONS,\n    edges: dict[str, Any] = DEFAULT_EDGE_OPERATIONS,\n) -> pd.DataFrame:\n    \"\"\"\n    Merge multiple graphs together. The graphs are expected to be in graphml format. The verb outputs a new column containing the merged graph.",
        "detail": "graphrag.index.operations.merge_graphs.merge_graphs",
        "documentation": {}
    },
    {
        "label": "merge_nodes",
        "kind": 2,
        "importPath": "graphrag.index.operations.merge_graphs.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs.merge_graphs",
        "peekOfCode": "def merge_nodes(\n    target: nx.Graph,\n    subgraph: nx.Graph,\n    node_ops: dict[str, DetailedAttributeMergeOperation],\n):\n    \"\"\"Merge nodes from subgraph into target using the operations defined in node_ops.\"\"\"\n    for node in subgraph.nodes:\n        if node not in target.nodes:\n            target.add_node(node, **(subgraph.nodes[node] or {}))\n        else:",
        "detail": "graphrag.index.operations.merge_graphs.merge_graphs",
        "documentation": {}
    },
    {
        "label": "merge_edges",
        "kind": 2,
        "importPath": "graphrag.index.operations.merge_graphs.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs.merge_graphs",
        "peekOfCode": "def merge_edges(\n    target_graph: nx.Graph,\n    subgraph: nx.Graph,\n    edge_ops: dict[str, DetailedAttributeMergeOperation],\n):\n    \"\"\"Merge edges from subgraph into target using the operations defined in edge_ops.\"\"\"\n    for source, target, edge_data in subgraph.edges(data=True):  # type: ignore\n        if not target_graph.has_edge(source, target):\n            target_graph.add_edge(source, target, **(edge_data or {}))\n        else:",
        "detail": "graphrag.index.operations.merge_graphs.merge_graphs",
        "documentation": {}
    },
    {
        "label": "merge_attributes",
        "kind": 2,
        "importPath": "graphrag.index.operations.merge_graphs.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs.merge_graphs",
        "peekOfCode": "def merge_attributes(\n    target_item: dict[str, Any] | None,\n    source_item: dict[str, Any] | None,\n    ops: dict[str, DetailedAttributeMergeOperation],\n):\n    \"\"\"Merge attributes from source_item into target_item using the operations defined in ops.\"\"\"\n    source_item = source_item or {}\n    target_item = target_item or {}\n    for op_attrib, op in ops.items():\n        if op_attrib == \"*\":",
        "detail": "graphrag.index.operations.merge_graphs.merge_graphs",
        "documentation": {}
    },
    {
        "label": "apply_merge_operation",
        "kind": 2,
        "importPath": "graphrag.index.operations.merge_graphs.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs.merge_graphs",
        "peekOfCode": "def apply_merge_operation(\n    target_item: dict[str, Any] | None,\n    source_item: dict[str, Any] | None,\n    attrib: str,\n    op: DetailedAttributeMergeOperation,\n):\n    \"\"\"Apply the merge operation to the attribute.\"\"\"\n    source_item = source_item or {}\n    target_item = target_item or {}\n    if (",
        "detail": "graphrag.index.operations.merge_graphs.merge_graphs",
        "documentation": {}
    },
    {
        "label": "DEFAULT_NODE_OPERATIONS",
        "kind": 5,
        "importPath": "graphrag.index.operations.merge_graphs.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs.merge_graphs",
        "peekOfCode": "DEFAULT_NODE_OPERATIONS = {\n    \"*\": {\n        \"operation\": BasicMergeOperation.Replace,\n    }\n}\nDEFAULT_EDGE_OPERATIONS = {\n    \"*\": {\n        \"operation\": BasicMergeOperation.Replace,\n    },\n    \"weight\": \"sum\",",
        "detail": "graphrag.index.operations.merge_graphs.merge_graphs",
        "documentation": {}
    },
    {
        "label": "DEFAULT_EDGE_OPERATIONS",
        "kind": 5,
        "importPath": "graphrag.index.operations.merge_graphs.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs.merge_graphs",
        "peekOfCode": "DEFAULT_EDGE_OPERATIONS = {\n    \"*\": {\n        \"operation\": BasicMergeOperation.Replace,\n    },\n    \"weight\": \"sum\",\n}\nDEFAULT_CONCAT_SEPARATOR = \",\"\ndef merge_graphs(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,",
        "detail": "graphrag.index.operations.merge_graphs.merge_graphs",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONCAT_SEPARATOR",
        "kind": 5,
        "importPath": "graphrag.index.operations.merge_graphs.merge_graphs",
        "description": "graphrag.index.operations.merge_graphs.merge_graphs",
        "peekOfCode": "DEFAULT_CONCAT_SEPARATOR = \",\"\ndef merge_graphs(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    column: str,\n    to: str,\n    nodes: dict[str, Any] = DEFAULT_NODE_OPERATIONS,\n    edges: dict[str, Any] = DEFAULT_EDGE_OPERATIONS,\n) -> pd.DataFrame:\n    \"\"\"",
        "detail": "graphrag.index.operations.merge_graphs.merge_graphs",
        "documentation": {}
    },
    {
        "label": "BasicMergeOperation",
        "kind": 6,
        "importPath": "graphrag.index.operations.merge_graphs.typing",
        "description": "graphrag.index.operations.merge_graphs.typing",
        "peekOfCode": "class BasicMergeOperation(str, Enum):\n    \"\"\"Basic Merge Operation class definition.\"\"\"\n    Replace = \"replace\"\n    Skip = \"skip\"\nclass StringOperation(str, Enum):\n    \"\"\"String Operation class definition.\"\"\"\n    Concat = \"concat\"\n    Replace = \"replace\"\n    Skip = \"skip\"\nclass NumericOperation(str, Enum):",
        "detail": "graphrag.index.operations.merge_graphs.typing",
        "documentation": {}
    },
    {
        "label": "StringOperation",
        "kind": 6,
        "importPath": "graphrag.index.operations.merge_graphs.typing",
        "description": "graphrag.index.operations.merge_graphs.typing",
        "peekOfCode": "class StringOperation(str, Enum):\n    \"\"\"String Operation class definition.\"\"\"\n    Concat = \"concat\"\n    Replace = \"replace\"\n    Skip = \"skip\"\nclass NumericOperation(str, Enum):\n    \"\"\"Numeric Operation class definition.\"\"\"\n    Sum = \"sum\"\n    Average = \"average\"\n    Max = \"max\"",
        "detail": "graphrag.index.operations.merge_graphs.typing",
        "documentation": {}
    },
    {
        "label": "NumericOperation",
        "kind": 6,
        "importPath": "graphrag.index.operations.merge_graphs.typing",
        "description": "graphrag.index.operations.merge_graphs.typing",
        "peekOfCode": "class NumericOperation(str, Enum):\n    \"\"\"Numeric Operation class definition.\"\"\"\n    Sum = \"sum\"\n    Average = \"average\"\n    Max = \"max\"\n    Min = \"min\"\n    Multiply = \"multiply\"\n    Replace = \"replace\"\n    Skip = \"skip\"\n@dataclass",
        "detail": "graphrag.index.operations.merge_graphs.typing",
        "documentation": {}
    },
    {
        "label": "DetailedAttributeMergeOperation",
        "kind": 6,
        "importPath": "graphrag.index.operations.merge_graphs.typing",
        "description": "graphrag.index.operations.merge_graphs.typing",
        "peekOfCode": "class DetailedAttributeMergeOperation:\n    \"\"\"Detailed attribute merge operation class definition.\"\"\"\n    operation: str  # StringOperation | NumericOperation\n    # concat\n    separator: str | None = None\n    delimiter: str | None = None\n    distinct: bool = False\nAttributeMergeOperation = str | DetailedAttributeMergeOperation",
        "detail": "graphrag.index.operations.merge_graphs.typing",
        "documentation": {}
    },
    {
        "label": "AttributeMergeOperation",
        "kind": 5,
        "importPath": "graphrag.index.operations.merge_graphs.typing",
        "description": "graphrag.index.operations.merge_graphs.typing",
        "peekOfCode": "AttributeMergeOperation = str | DetailedAttributeMergeOperation",
        "detail": "graphrag.index.operations.merge_graphs.typing",
        "documentation": {}
    },
    {
        "label": "prepare_community_reports",
        "kind": 2,
        "importPath": "graphrag.index.operations.summarize_communities.prepare_community_reports",
        "description": "graphrag.index.operations.summarize_communities.prepare_community_reports",
        "peekOfCode": "def prepare_community_reports(\n    nodes,\n    edges,\n    claims,\n    callbacks: VerbCallbacks,\n    max_tokens: int = 16_000,\n):\n    \"\"\"Prep communities for report generation.\"\"\"\n    levels = get_levels(nodes, schemas.NODE_LEVEL)\n    dfs = []",
        "detail": "graphrag.index.operations.summarize_communities.prepare_community_reports",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.prepare_community_reports",
        "description": "graphrag.index.operations.summarize_communities.prepare_community_reports",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef prepare_community_reports(\n    nodes,\n    edges,\n    claims,\n    callbacks: VerbCallbacks,\n    max_tokens: int = 16_000,\n):\n    \"\"\"Prep communities for report generation.\"\"\"\n    levels = get_levels(nodes, schemas.NODE_LEVEL)",
        "detail": "graphrag.index.operations.summarize_communities.prepare_community_reports",
        "documentation": {}
    },
    {
        "label": "restore_community_hierarchy",
        "kind": 2,
        "importPath": "graphrag.index.operations.summarize_communities.restore_community_hierarchy",
        "description": "graphrag.index.operations.summarize_communities.restore_community_hierarchy",
        "peekOfCode": "def restore_community_hierarchy(\n    input: pd.DataFrame,\n    name_column: str = schemas.NODE_NAME,\n    community_column: str = schemas.NODE_COMMUNITY,\n    level_column: str = schemas.NODE_LEVEL,\n) -> pd.DataFrame:\n    \"\"\"Restore the community hierarchy from the node data.\"\"\"\n    community_df = (\n        input.groupby([community_column, level_column])\n        .agg({name_column: list})",
        "detail": "graphrag.index.operations.summarize_communities.restore_community_hierarchy",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.restore_community_hierarchy",
        "description": "graphrag.index.operations.summarize_communities.restore_community_hierarchy",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef restore_community_hierarchy(\n    input: pd.DataFrame,\n    name_column: str = schemas.NODE_NAME,\n    community_column: str = schemas.NODE_COMMUNITY,\n    level_column: str = schemas.NODE_LEVEL,\n) -> pd.DataFrame:\n    \"\"\"Restore the community hierarchy from the node data.\"\"\"\n    community_df = (\n        input.groupby([community_column, level_column])",
        "detail": "graphrag.index.operations.summarize_communities.restore_community_hierarchy",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CHUNK_SIZE",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.strategies",
        "description": "graphrag.index.operations.summarize_communities.strategies",
        "peekOfCode": "DEFAULT_CHUNK_SIZE = 3000\nlog = logging.getLogger(__name__)\nasync def run_graph_intelligence(\n    community: str | int,\n    input: str,\n    level: int,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache,\n    args: StrategyConfig,\n) -> CommunityReport | None:",
        "detail": "graphrag.index.operations.summarize_communities.strategies",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.strategies",
        "description": "graphrag.index.operations.summarize_communities.strategies",
        "peekOfCode": "log = logging.getLogger(__name__)\nasync def run_graph_intelligence(\n    community: str | int,\n    input: str,\n    level: int,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache,\n    args: StrategyConfig,\n) -> CommunityReport | None:\n    \"\"\"Run the graph intelligence entity extraction strategy.\"\"\"",
        "detail": "graphrag.index.operations.summarize_communities.strategies",
        "documentation": {}
    },
    {
        "label": "load_strategy",
        "kind": 2,
        "importPath": "graphrag.index.operations.summarize_communities.summarize_communities",
        "description": "graphrag.index.operations.summarize_communities.summarize_communities",
        "peekOfCode": "def load_strategy(\n    strategy: CreateCommunityReportsStrategyType,\n) -> CommunityReportsStrategy:\n    \"\"\"Load strategy method definition.\"\"\"\n    match strategy:\n        case CreateCommunityReportsStrategyType.graph_intelligence:\n            from .strategies import run_graph_intelligence\n            return run_graph_intelligence\n        case _:\n            msg = f\"Unknown strategy: {strategy}\"",
        "detail": "graphrag.index.operations.summarize_communities.summarize_communities",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.summarize_communities",
        "description": "graphrag.index.operations.summarize_communities.summarize_communities",
        "peekOfCode": "log = logging.getLogger(__name__)\nasync def summarize_communities(\n    local_contexts,\n    nodes,\n    community_hierarchy,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache,\n    strategy: dict,\n    async_mode: AsyncType = AsyncType.AsyncIO,\n    num_threads: int = 4,",
        "detail": "graphrag.index.operations.summarize_communities.summarize_communities",
        "documentation": {}
    },
    {
        "label": "Finding",
        "kind": 6,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "class Finding(TypedDict):\n    \"\"\"Finding class definition.\"\"\"\n    summary: str\n    explanation: str\nclass CommunityReport(TypedDict):\n    \"\"\"Community report class definition.\"\"\"\n    community: str | int\n    title: str\n    summary: str\n    full_content: str",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "kind": 6,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "class CommunityReport(TypedDict):\n    \"\"\"Community report class definition.\"\"\"\n    community: str | int\n    title: str\n    summary: str\n    full_content: str\n    full_content_json: str\n    rank: float\n    level: int\n    rank_explanation: str",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "CreateCommunityReportsStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "class CreateCommunityReportsStrategyType(str, Enum):\n    \"\"\"CreateCommunityReportsStrategyType class definition.\"\"\"\n    graph_intelligence = \"graph_intelligence\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "ExtractedEntity",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "ExtractedEntity = dict[str, Any]\nStrategyConfig = dict[str, Any]\nRowContext = dict[str, Any]\nEntityTypes = list[str]\nClaim = dict[str, Any]\nclass Finding(TypedDict):\n    \"\"\"Finding class definition.\"\"\"\n    summary: str\n    explanation: str\nclass CommunityReport(TypedDict):",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "StrategyConfig",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "StrategyConfig = dict[str, Any]\nRowContext = dict[str, Any]\nEntityTypes = list[str]\nClaim = dict[str, Any]\nclass Finding(TypedDict):\n    \"\"\"Finding class definition.\"\"\"\n    summary: str\n    explanation: str\nclass CommunityReport(TypedDict):\n    \"\"\"Community report class definition.\"\"\"",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "RowContext",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "RowContext = dict[str, Any]\nEntityTypes = list[str]\nClaim = dict[str, Any]\nclass Finding(TypedDict):\n    \"\"\"Finding class definition.\"\"\"\n    summary: str\n    explanation: str\nclass CommunityReport(TypedDict):\n    \"\"\"Community report class definition.\"\"\"\n    community: str | int",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "EntityTypes",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "EntityTypes = list[str]\nClaim = dict[str, Any]\nclass Finding(TypedDict):\n    \"\"\"Finding class definition.\"\"\"\n    summary: str\n    explanation: str\nclass CommunityReport(TypedDict):\n    \"\"\"Community report class definition.\"\"\"\n    community: str | int\n    title: str",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "Claim",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "Claim = dict[str, Any]\nclass Finding(TypedDict):\n    \"\"\"Finding class definition.\"\"\"\n    summary: str\n    explanation: str\nclass CommunityReport(TypedDict):\n    \"\"\"Community report class definition.\"\"\"\n    community: str | int\n    title: str\n    summary: str",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "CommunityReportsStrategy",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_communities.typing",
        "description": "graphrag.index.operations.summarize_communities.typing",
        "peekOfCode": "CommunityReportsStrategy = Callable[\n    [\n        str | int,\n        str,\n        int,\n        VerbCallbacks,\n        PipelineCache,\n        StrategyConfig,\n    ],\n    Awaitable[CommunityReport | None],",
        "detail": "graphrag.index.operations.summarize_communities.typing",
        "documentation": {}
    },
    {
        "label": "load_strategy",
        "kind": 2,
        "importPath": "graphrag.index.operations.summarize_descriptions.summarize_descriptions",
        "description": "graphrag.index.operations.summarize_descriptions.summarize_descriptions",
        "peekOfCode": "def load_strategy(strategy_type: SummarizeStrategyType) -> SummarizationStrategy:\n    \"\"\"Load strategy method definition.\"\"\"\n    match strategy_type:\n        case SummarizeStrategyType.graph_intelligence:\n            from .strategies import run_graph_intelligence\n            return run_graph_intelligence\n        case _:\n            msg = f\"Unknown strategy: {strategy_type}\"\n            raise ValueError(msg)",
        "detail": "graphrag.index.operations.summarize_descriptions.summarize_descriptions",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_descriptions.summarize_descriptions",
        "description": "graphrag.index.operations.summarize_descriptions.summarize_descriptions",
        "peekOfCode": "log = logging.getLogger(__name__)\nasync def summarize_descriptions(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    cache: PipelineCache,\n    column: str,\n    to: str,\n    strategy: dict[str, Any] | None = None,\n    **kwargs,\n) -> pd.DataFrame:",
        "detail": "graphrag.index.operations.summarize_descriptions.summarize_descriptions",
        "documentation": {}
    },
    {
        "label": "SummarizedDescriptionResult",
        "kind": 6,
        "importPath": "graphrag.index.operations.summarize_descriptions.typing",
        "description": "graphrag.index.operations.summarize_descriptions.typing",
        "peekOfCode": "class SummarizedDescriptionResult:\n    \"\"\"Entity summarization result class definition.\"\"\"\n    items: str | tuple[str, str]\n    description: str\nSummarizationStrategy = Callable[\n    [\n        str | tuple[str, str],\n        list[str],\n        VerbCallbacks,\n        PipelineCache,",
        "detail": "graphrag.index.operations.summarize_descriptions.typing",
        "documentation": {}
    },
    {
        "label": "DescriptionSummarizeRow",
        "kind": 6,
        "importPath": "graphrag.index.operations.summarize_descriptions.typing",
        "description": "graphrag.index.operations.summarize_descriptions.typing",
        "peekOfCode": "class DescriptionSummarizeRow(NamedTuple):\n    \"\"\"DescriptionSummarizeRow class definition.\"\"\"\n    graph: Any\nclass SummarizeStrategyType(str, Enum):\n    \"\"\"SummarizeStrategyType class definition.\"\"\"\n    graph_intelligence = \"graph_intelligence\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'",
        "detail": "graphrag.index.operations.summarize_descriptions.typing",
        "documentation": {}
    },
    {
        "label": "SummarizeStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.summarize_descriptions.typing",
        "description": "graphrag.index.operations.summarize_descriptions.typing",
        "peekOfCode": "class SummarizeStrategyType(str, Enum):\n    \"\"\"SummarizeStrategyType class definition.\"\"\"\n    graph_intelligence = \"graph_intelligence\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'",
        "detail": "graphrag.index.operations.summarize_descriptions.typing",
        "documentation": {}
    },
    {
        "label": "StrategyConfig",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_descriptions.typing",
        "description": "graphrag.index.operations.summarize_descriptions.typing",
        "peekOfCode": "StrategyConfig = dict[str, Any]\n@dataclass\nclass SummarizedDescriptionResult:\n    \"\"\"Entity summarization result class definition.\"\"\"\n    items: str | tuple[str, str]\n    description: str\nSummarizationStrategy = Callable[\n    [\n        str | tuple[str, str],\n        list[str],",
        "detail": "graphrag.index.operations.summarize_descriptions.typing",
        "documentation": {}
    },
    {
        "label": "SummarizationStrategy",
        "kind": 5,
        "importPath": "graphrag.index.operations.summarize_descriptions.typing",
        "description": "graphrag.index.operations.summarize_descriptions.typing",
        "peekOfCode": "SummarizationStrategy = Callable[\n    [\n        str | tuple[str, str],\n        list[str],\n        VerbCallbacks,\n        PipelineCache,\n        StrategyConfig,\n    ],\n    Awaitable[SummarizedDescriptionResult],\n]",
        "detail": "graphrag.index.operations.summarize_descriptions.typing",
        "documentation": {}
    },
    {
        "label": "GraphCommunityStrategyType",
        "kind": 6,
        "importPath": "graphrag.index.operations.cluster_graph",
        "description": "graphrag.index.operations.cluster_graph",
        "peekOfCode": "class GraphCommunityStrategyType(str, Enum):\n    \"\"\"GraphCommunityStrategyType class definition.\"\"\"\n    leiden = \"leiden\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nlog = logging.getLogger(__name__)\ndef cluster_graph(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,",
        "detail": "graphrag.index.operations.cluster_graph",
        "documentation": {}
    },
    {
        "label": "cluster_graph",
        "kind": 2,
        "importPath": "graphrag.index.operations.cluster_graph",
        "description": "graphrag.index.operations.cluster_graph",
        "peekOfCode": "def cluster_graph(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    strategy: dict[str, Any],\n    column: str,\n    to: str,\n    level_to: str | None = None,\n) -> pd.DataFrame:\n    \"\"\"Apply a hierarchical clustering algorithm to a graph.\"\"\"\n    results = input[column].apply(lambda graph: run_layout(strategy, graph))",
        "detail": "graphrag.index.operations.cluster_graph",
        "documentation": {}
    },
    {
        "label": "apply_clustering",
        "kind": 2,
        "importPath": "graphrag.index.operations.cluster_graph",
        "description": "graphrag.index.operations.cluster_graph",
        "peekOfCode": "def apply_clustering(\n    graphml: str, communities: Communities, level: int = 0, seed: int | None = None\n) -> nx.Graph:\n    \"\"\"Apply clustering to a graphml string.\"\"\"\n    random = Random(seed)  # noqa S311\n    graph = nx.parse_graphml(graphml)\n    for community_level, community_id, nodes in communities:\n        if level == community_level:\n            for node in nodes:\n                graph.nodes[node][\"cluster\"] = community_id",
        "detail": "graphrag.index.operations.cluster_graph",
        "documentation": {}
    },
    {
        "label": "run_layout",
        "kind": 2,
        "importPath": "graphrag.index.operations.cluster_graph",
        "description": "graphrag.index.operations.cluster_graph",
        "peekOfCode": "def run_layout(\n    strategy: dict[str, Any], graphml_or_graph: str | nx.Graph\n) -> Communities:\n    \"\"\"Run layout method definition.\"\"\"\n    graph = load_graph(graphml_or_graph)\n    if len(graph.nodes) == 0:\n        log.warning(\"Graph has no nodes\")\n        return []\n    clusters: dict[int, dict[str, list[str]]] = {}\n    strategy_type = strategy.get(\"type\", GraphCommunityStrategyType.leiden)",
        "detail": "graphrag.index.operations.cluster_graph",
        "documentation": {}
    },
    {
        "label": "run_leiden",
        "kind": 2,
        "importPath": "graphrag.index.operations.cluster_graph",
        "description": "graphrag.index.operations.cluster_graph",
        "peekOfCode": "def run_leiden(\n    graph: nx.Graph, args: dict[str, Any]\n) -> dict[int, dict[str, list[str]]]:\n    \"\"\"Run method definition.\"\"\"\n    max_cluster_size = args.get(\"max_cluster_size\", 10)\n    use_lcc = args.get(\"use_lcc\", True)\n    if args.get(\"verbose\", False):\n        log.info(\n            \"Running leiden with max_cluster_size=%s, lcc=%s\", max_cluster_size, use_lcc\n        )",
        "detail": "graphrag.index.operations.cluster_graph",
        "documentation": {}
    },
    {
        "label": "Communities",
        "kind": 5,
        "importPath": "graphrag.index.operations.cluster_graph",
        "description": "graphrag.index.operations.cluster_graph",
        "peekOfCode": "Communities = list[tuple[int, str, list[str]]]\nclass GraphCommunityStrategyType(str, Enum):\n    \"\"\"GraphCommunityStrategyType class definition.\"\"\"\n    leiden = \"leiden\"\n    def __repr__(self):\n        \"\"\"Get a string representation.\"\"\"\n        return f'\"{self.value}\"'\nlog = logging.getLogger(__name__)\ndef cluster_graph(\n    input: pd.DataFrame,",
        "detail": "graphrag.index.operations.cluster_graph",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.operations.cluster_graph",
        "description": "graphrag.index.operations.cluster_graph",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef cluster_graph(\n    input: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    strategy: dict[str, Any],\n    column: str,\n    to: str,\n    level_to: str | None = None,\n) -> pd.DataFrame:\n    \"\"\"Apply a hierarchical clustering algorithm to a graph.\"\"\"",
        "detail": "graphrag.index.operations.cluster_graph",
        "documentation": {}
    },
    {
        "label": "compute_edge_combined_degree",
        "kind": 2,
        "importPath": "graphrag.index.operations.compute_edge_combined_degree",
        "description": "graphrag.index.operations.compute_edge_combined_degree",
        "peekOfCode": "def compute_edge_combined_degree(\n    edge_df: pd.DataFrame,\n    node_degree_df: pd.DataFrame,\n    to: str,\n    node_name_column: str,\n    node_degree_column: str,\n    edge_source_column: str,\n    edge_target_column: str,\n) -> pd.DataFrame:\n    \"\"\"Compute the combined degree for each edge in a graph.\"\"\"",
        "detail": "graphrag.index.operations.compute_edge_combined_degree",
        "documentation": {}
    },
    {
        "label": "FormatSpecifier",
        "kind": 6,
        "importPath": "graphrag.index.operations.snapshot_rows",
        "description": "graphrag.index.operations.snapshot_rows",
        "peekOfCode": "class FormatSpecifier:\n    \"\"\"Format specifier class definition.\"\"\"\n    format: str\n    extension: str\nasync def snapshot_rows(\n    input: pd.DataFrame,\n    column: str | None,\n    base_name: str,\n    storage: PipelineStorage,\n    formats: list[str | dict[str, Any]],",
        "detail": "graphrag.index.operations.snapshot_rows",
        "documentation": {}
    },
    {
        "label": "split_text",
        "kind": 2,
        "importPath": "graphrag.index.operations.split_text",
        "description": "graphrag.index.operations.split_text",
        "peekOfCode": "def split_text(\n    input: pd.DataFrame, column: str, to: str, separator: str = \",\"\n) -> pd.DataFrame:\n    \"\"\"Split a column into a list of strings.\"\"\"\n    output = input\n    def _apply_split(row):\n        if row[column] is None or isinstance(row[column], list):\n            return row[column]\n        if row[column] == \"\":\n            return []",
        "detail": "graphrag.index.operations.split_text",
        "documentation": {}
    },
    {
        "label": "unpack_graph",
        "kind": 2,
        "importPath": "graphrag.index.operations.unpack_graph",
        "description": "graphrag.index.operations.unpack_graph",
        "peekOfCode": "def unpack_graph(\n    input_df: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    column: str,\n    type: str,  # noqa A002\n    copy: list[str] | None = None,\n    embeddings_column: str = \"embeddings\",\n) -> pd.DataFrame:\n    \"\"\"Unpack nodes or edges from a graphml graph, into a list of nodes or edges.\"\"\"\n    if copy is None:",
        "detail": "graphrag.index.operations.unpack_graph",
        "documentation": {}
    },
    {
        "label": "default_copy",
        "kind": 5,
        "importPath": "graphrag.index.operations.unpack_graph",
        "description": "graphrag.index.operations.unpack_graph",
        "peekOfCode": "default_copy = [\"level\"]\ndef unpack_graph(\n    input_df: pd.DataFrame,\n    callbacks: VerbCallbacks,\n    column: str,\n    type: str,  # noqa A002\n    copy: list[str] | None = None,\n    embeddings_column: str = \"embeddings\",\n) -> pd.DataFrame:\n    \"\"\"Unpack nodes or edges from a graphml graph, into a list of nodes or edges.\"\"\"",
        "detail": "graphrag.index.operations.unpack_graph",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.run.profiling",
        "description": "graphrag.index.run.profiling",
        "peekOfCode": "log = logging.getLogger(__name__)\nasync def _save_profiler_stats(\n    storage: PipelineStorage, workflow_name: str, profile: MemoryProfile\n):\n    \"\"\"Save the profiler stats to the storage.\"\"\"\n    await storage.set(\n        f\"{workflow_name}_profiling.peak_stats.csv\",\n        profile.peak_stats.to_csv(index=True),\n    )\n    await storage.set(",
        "detail": "graphrag.index.run.profiling",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.run.run",
        "description": "graphrag.index.run.run",
        "peekOfCode": "log = logging.getLogger(__name__)\nasync def run_pipeline_with_config(\n    config_or_path: PipelineConfig | str,\n    workflows: list[PipelineWorkflowReference] | None = None,\n    dataset: pd.DataFrame | None = None,\n    storage: PipelineStorage | None = None,\n    cache: PipelineCache | None = None,\n    callbacks: WorkflowCallbacks | None = None,\n    progress_reporter: ProgressReporter | None = None,\n    input_post_process_steps: list[PipelineWorkflowStep] | None = None,",
        "detail": "graphrag.index.run.run",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.run.utils",
        "description": "graphrag.index.run.utils",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef _create_reporter(\n    config: PipelineReportingConfigTypes | None, root_dir: str\n) -> WorkflowCallbacks | None:\n    \"\"\"Create the reporter for the pipeline.\"\"\"\n    return create_pipeline_reporter(config, root_dir) if config else None\nasync def _create_input(\n    config: PipelineInputConfigTypes | None,\n    progress_reporter: ProgressReporter | None,\n    root_dir: str,",
        "detail": "graphrag.index.run.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.run.workflow",
        "description": "graphrag.index.run.workflow",
        "peekOfCode": "log = logging.getLogger(__name__)\nasync def _inject_workflow_data_dependencies(\n    workflow: Workflow,\n    workflow_dependencies: dict[str, list[str]],\n    dataset: pd.DataFrame,\n    storage: PipelineStorage,\n) -> None:\n    \"\"\"Inject the data dependencies into the workflow.\"\"\"\n    workflow.add_table(DEFAULT_INPUT_NAME, dataset)\n    deps = workflow_dependencies[workflow.name]",
        "detail": "graphrag.index.run.workflow",
        "documentation": {}
    },
    {
        "label": "BlobPipelineStorage",
        "kind": 6,
        "importPath": "graphrag.index.storage.blob_pipeline_storage",
        "description": "graphrag.index.storage.blob_pipeline_storage",
        "peekOfCode": "class BlobPipelineStorage(PipelineStorage):\n    \"\"\"The Blob-Storage implementation.\"\"\"\n    _connection_string: str | None\n    _container_name: str\n    _path_prefix: str\n    _encoding: str\n    _storage_account_blob_url: str | None\n    def __init__(\n        self,\n        connection_string: str | None,",
        "detail": "graphrag.index.storage.blob_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "create_blob_storage",
        "kind": 2,
        "importPath": "graphrag.index.storage.blob_pipeline_storage",
        "description": "graphrag.index.storage.blob_pipeline_storage",
        "peekOfCode": "def create_blob_storage(\n    connection_string: str | None,\n    storage_account_blob_url: str | None,\n    container_name: str,\n    base_dir: str | None,\n) -> PipelineStorage:\n    \"\"\"Create a blob based storage.\"\"\"\n    log.info(\"Creating blob storage at %s\", container_name)\n    if container_name is None:\n        msg = \"No container name provided for blob storage.\"",
        "detail": "graphrag.index.storage.blob_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "validate_blob_container_name",
        "kind": 2,
        "importPath": "graphrag.index.storage.blob_pipeline_storage",
        "description": "graphrag.index.storage.blob_pipeline_storage",
        "peekOfCode": "def validate_blob_container_name(container_name: str):\n    \"\"\"\n    Check if the provided blob container name is valid based on Azure rules.\n        - A blob container name must be between 3 and 63 characters in length.\n        - Start with a letter or number\n        - All letters used in blob container names must be lowercase.\n        - Contain only letters, numbers, or the hyphen.\n        - Consecutive hyphens are not permitted.\n        - Cannot end with a hyphen.\n    Args:",
        "detail": "graphrag.index.storage.blob_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.storage.blob_pipeline_storage",
        "description": "graphrag.index.storage.blob_pipeline_storage",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass BlobPipelineStorage(PipelineStorage):\n    \"\"\"The Blob-Storage implementation.\"\"\"\n    _connection_string: str | None\n    _container_name: str\n    _path_prefix: str\n    _encoding: str\n    _storage_account_blob_url: str | None\n    def __init__(\n        self,",
        "detail": "graphrag.index.storage.blob_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "FilePipelineStorage",
        "kind": 6,
        "importPath": "graphrag.index.storage.file_pipeline_storage",
        "description": "graphrag.index.storage.file_pipeline_storage",
        "peekOfCode": "class FilePipelineStorage(PipelineStorage):\n    \"\"\"File storage class definition.\"\"\"\n    _root_dir: str\n    _encoding: str\n    def __init__(self, root_dir: str | None = None, encoding: str | None = None):\n        \"\"\"Init method definition.\"\"\"\n        self._root_dir = root_dir or \"\"\n        self._encoding = encoding or \"utf-8\"\n        Path(self._root_dir).mkdir(parents=True, exist_ok=True)\n    def find(",
        "detail": "graphrag.index.storage.file_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "join_path",
        "kind": 2,
        "importPath": "graphrag.index.storage.file_pipeline_storage",
        "description": "graphrag.index.storage.file_pipeline_storage",
        "peekOfCode": "def join_path(file_path: str, file_name: str) -> Path:\n    \"\"\"Join a path and a file. Independent of the OS.\"\"\"\n    return Path(file_path) / Path(file_name).parent / Path(file_name).name\ndef create_file_storage(out_dir: str | None) -> PipelineStorage:\n    \"\"\"Create a file based storage.\"\"\"\n    log.info(\"Creating file storage at %s\", out_dir)\n    return FilePipelineStorage(out_dir)\ndef _create_progress_status(\n    num_loaded: int, num_filtered: int, num_total: int\n) -> Progress:",
        "detail": "graphrag.index.storage.file_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "create_file_storage",
        "kind": 2,
        "importPath": "graphrag.index.storage.file_pipeline_storage",
        "description": "graphrag.index.storage.file_pipeline_storage",
        "peekOfCode": "def create_file_storage(out_dir: str | None) -> PipelineStorage:\n    \"\"\"Create a file based storage.\"\"\"\n    log.info(\"Creating file storage at %s\", out_dir)\n    return FilePipelineStorage(out_dir)\ndef _create_progress_status(\n    num_loaded: int, num_filtered: int, num_total: int\n) -> Progress:\n    return Progress(\n        total_items=num_total,\n        completed_items=num_loaded + num_filtered,",
        "detail": "graphrag.index.storage.file_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.storage.file_pipeline_storage",
        "description": "graphrag.index.storage.file_pipeline_storage",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass FilePipelineStorage(PipelineStorage):\n    \"\"\"File storage class definition.\"\"\"\n    _root_dir: str\n    _encoding: str\n    def __init__(self, root_dir: str | None = None, encoding: str | None = None):\n        \"\"\"Init method definition.\"\"\"\n        self._root_dir = root_dir or \"\"\n        self._encoding = encoding or \"utf-8\"\n        Path(self._root_dir).mkdir(parents=True, exist_ok=True)",
        "detail": "graphrag.index.storage.file_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "load_storage",
        "kind": 2,
        "importPath": "graphrag.index.storage.load_storage",
        "description": "graphrag.index.storage.load_storage",
        "peekOfCode": "def load_storage(config: PipelineStorageConfig):\n    \"\"\"Load the storage for a pipeline.\"\"\"\n    match config.type:\n        case StorageType.memory:\n            return create_memory_storage()\n        case StorageType.blob:\n            config = cast(PipelineBlobStorageConfig, config)\n            return create_blob_storage(\n                config.connection_string,\n                config.storage_account_blob_url,",
        "detail": "graphrag.index.storage.load_storage",
        "documentation": {}
    },
    {
        "label": "MemoryPipelineStorage",
        "kind": 6,
        "importPath": "graphrag.index.storage.memory_pipeline_storage",
        "description": "graphrag.index.storage.memory_pipeline_storage",
        "peekOfCode": "class MemoryPipelineStorage(FilePipelineStorage):\n    \"\"\"In memory storage class definition.\"\"\"\n    _storage: dict[str, Any]\n    def __init__(self):\n        \"\"\"Init method definition.\"\"\"\n        super().__init__(root_dir=\".output\")\n        self._storage = {}\n    async def get(\n        self, key: str, as_bytes: bool | None = None, encoding: str | None = None\n    ) -> Any:",
        "detail": "graphrag.index.storage.memory_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "create_memory_storage",
        "kind": 2,
        "importPath": "graphrag.index.storage.memory_pipeline_storage",
        "description": "graphrag.index.storage.memory_pipeline_storage",
        "peekOfCode": "def create_memory_storage() -> PipelineStorage:\n    \"\"\"Create memory storage.\"\"\"\n    return MemoryPipelineStorage()",
        "detail": "graphrag.index.storage.memory_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "PipelineStorage",
        "kind": 6,
        "importPath": "graphrag.index.storage.typing",
        "description": "graphrag.index.storage.typing",
        "peekOfCode": "class PipelineStorage(metaclass=ABCMeta):\n    \"\"\"Provide a storage interface for the pipeline. This is where the pipeline will store its output data.\"\"\"\n    @abstractmethod\n    def find(\n        self,\n        file_pattern: re.Pattern[str],\n        base_dir: str | None = None,\n        progress: ProgressReporter | None = None,\n        file_filter: dict[str, Any] | None = None,\n        max_count=-1,",
        "detail": "graphrag.index.storage.typing",
        "documentation": {}
    },
    {
        "label": "check_token_limit",
        "kind": 2,
        "importPath": "graphrag.index.text_splitting.check_token_limit",
        "description": "graphrag.index.text_splitting.check_token_limit",
        "peekOfCode": "def check_token_limit(text, max_token):\n    \"\"\"Check token limit.\"\"\"\n    text_splitter = TokenTextSplitter(chunk_size=max_token, chunk_overlap=0)\n    docs = text_splitter.split_text(text)\n    if len(docs) > 1:\n        return 0\n    return 1",
        "detail": "graphrag.index.text_splitting.check_token_limit",
        "documentation": {}
    },
    {
        "label": "Tokenizer",
        "kind": 6,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "class Tokenizer:\n    \"\"\"Tokenizer data class.\"\"\"\n    chunk_overlap: int\n    \"\"\"Overlap in tokens between chunks\"\"\"\n    tokens_per_chunk: int\n    \"\"\"Maximum number of tokens per chunk\"\"\"\n    decode: DecodeFn\n    \"\"\" Function to decode a list of token ids to a string\"\"\"\n    encode: EncodeFn\n    \"\"\" Function to encode a string to a list of token ids\"\"\"",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "TextSplitter",
        "kind": 6,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "class TextSplitter(ABC):\n    \"\"\"Text splitter class definition.\"\"\"\n    _chunk_size: int\n    _chunk_overlap: int\n    _length_function: LengthFn\n    _keep_separator: bool\n    _add_start_index: bool\n    _strip_whitespace: bool\n    def __init__(\n        self,",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "NoopTextSplitter",
        "kind": 6,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "class NoopTextSplitter(TextSplitter):\n    \"\"\"Noop text splitter class definition.\"\"\"\n    def split_text(self, text: str | list[str]) -> Iterable[str]:\n        \"\"\"Split text method definition.\"\"\"\n        return [text] if isinstance(text, str) else text\nclass TokenTextSplitter(TextSplitter):\n    \"\"\"Token text splitter class definition.\"\"\"\n    _allowed_special: Literal[\"all\"] | set[str]\n    _disallowed_special: Literal[\"all\"] | Collection[str]\n    def __init__(",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "TokenTextSplitter",
        "kind": 6,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "class TokenTextSplitter(TextSplitter):\n    \"\"\"Token text splitter class definition.\"\"\"\n    _allowed_special: Literal[\"all\"] | set[str]\n    _disallowed_special: Literal[\"all\"] | Collection[str]\n    def __init__(\n        self,\n        encoding_name: str = \"cl100k_base\",\n        model_name: str | None = None,\n        allowed_special: Literal[\"all\"] | set[str] | None = None,\n        disallowed_special: Literal[\"all\"] | Collection[str] = \"all\",",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "TextListSplitterType",
        "kind": 6,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "class TextListSplitterType(str, Enum):\n    \"\"\"Enum for the type of the TextListSplitter.\"\"\"\n    DELIMITED_STRING = \"delimited_string\"\n    JSON = \"json\"\nclass TextListSplitter(TextSplitter):\n    \"\"\"Text list splitter class definition.\"\"\"\n    def __init__(\n        self,\n        chunk_size: int,\n        splitter_type: TextListSplitterType = TextListSplitterType.JSON,",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "TextListSplitter",
        "kind": 6,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "class TextListSplitter(TextSplitter):\n    \"\"\"Text list splitter class definition.\"\"\"\n    def __init__(\n        self,\n        chunk_size: int,\n        splitter_type: TextListSplitterType = TextListSplitterType.JSON,\n        input_delimiter: str | None = None,\n        output_delimiter: str | None = None,\n        model_name: str | None = None,\n        encoding_name: str | None = None,",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "split_text_on_tokens",
        "kind": 2,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "def split_text_on_tokens(*, text: str, tokenizer: Tokenizer) -> list[str]:\n    \"\"\"Split incoming text and return chunks using tokenizer.\"\"\"\n    splits: list[str] = []\n    input_ids = tokenizer.encode(text)\n    start_idx = 0\n    cur_idx = min(start_idx + tokenizer.tokens_per_chunk, len(input_ids))\n    chunk_ids = input_ids[start_idx:cur_idx]\n    while start_idx < len(input_ids):\n        splits.append(tokenizer.decode(chunk_ids))\n        start_idx += tokenizer.tokens_per_chunk - tokenizer.chunk_overlap",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "EncodedText",
        "kind": 5,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "EncodedText = list[int]\nDecodeFn = Callable[[EncodedText], str]\nEncodeFn = Callable[[str], EncodedText]\nLengthFn = Callable[[str], int]\nlog = logging.getLogger(__name__)\n@dataclass(frozen=True)\nclass Tokenizer:\n    \"\"\"Tokenizer data class.\"\"\"\n    chunk_overlap: int\n    \"\"\"Overlap in tokens between chunks\"\"\"",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "DecodeFn",
        "kind": 5,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "DecodeFn = Callable[[EncodedText], str]\nEncodeFn = Callable[[str], EncodedText]\nLengthFn = Callable[[str], int]\nlog = logging.getLogger(__name__)\n@dataclass(frozen=True)\nclass Tokenizer:\n    \"\"\"Tokenizer data class.\"\"\"\n    chunk_overlap: int\n    \"\"\"Overlap in tokens between chunks\"\"\"\n    tokens_per_chunk: int",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "EncodeFn",
        "kind": 5,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "EncodeFn = Callable[[str], EncodedText]\nLengthFn = Callable[[str], int]\nlog = logging.getLogger(__name__)\n@dataclass(frozen=True)\nclass Tokenizer:\n    \"\"\"Tokenizer data class.\"\"\"\n    chunk_overlap: int\n    \"\"\"Overlap in tokens between chunks\"\"\"\n    tokens_per_chunk: int\n    \"\"\"Maximum number of tokens per chunk\"\"\"",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "LengthFn",
        "kind": 5,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "LengthFn = Callable[[str], int]\nlog = logging.getLogger(__name__)\n@dataclass(frozen=True)\nclass Tokenizer:\n    \"\"\"Tokenizer data class.\"\"\"\n    chunk_overlap: int\n    \"\"\"Overlap in tokens between chunks\"\"\"\n    tokens_per_chunk: int\n    \"\"\"Maximum number of tokens per chunk\"\"\"\n    decode: DecodeFn",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.text_splitting.text_splitting",
        "description": "graphrag.index.text_splitting.text_splitting",
        "peekOfCode": "log = logging.getLogger(__name__)\n@dataclass(frozen=True)\nclass Tokenizer:\n    \"\"\"Tokenizer data class.\"\"\"\n    chunk_overlap: int\n    \"\"\"Overlap in tokens between chunks\"\"\"\n    tokens_per_chunk: int\n    \"\"\"Maximum number of tokens per chunk\"\"\"\n    decode: DecodeFn\n    \"\"\" Function to decode a list of token ids to a string\"\"\"",
        "detail": "graphrag.index.text_splitting.text_splitting",
        "documentation": {}
    },
    {
        "label": "InputDelta",
        "kind": 6,
        "importPath": "graphrag.index.update.dataframes",
        "description": "graphrag.index.update.dataframes",
        "peekOfCode": "class InputDelta:\n    \"\"\"Dataclass to hold the input delta.\n    Attributes\n    ----------\n    new_inputs : pd.DataFrame\n        The new inputs.\n    deleted_inputs : pd.DataFrame\n        The deleted inputs.\n    \"\"\"\n    new_inputs: pd.DataFrame",
        "detail": "graphrag.index.update.dataframes",
        "documentation": {}
    },
    {
        "label": "mergeable_outputs",
        "kind": 5,
        "importPath": "graphrag.index.update.dataframes",
        "description": "graphrag.index.update.dataframes",
        "peekOfCode": "mergeable_outputs = [\n    \"create_final_documents\",\n    \"create_final_entities\",\n    \"create_final_relationships\",\n]\n@dataclass\nclass InputDelta:\n    \"\"\"Dataclass to hold the input delta.\n    Attributes\n    ----------",
        "detail": "graphrag.index.update.dataframes",
        "documentation": {}
    },
    {
        "label": "drop_columns",
        "kind": 2,
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "peekOfCode": "def drop_columns(df: pd.DataFrame, *column: str) -> pd.DataFrame:\n    \"\"\"Drop columns from a dataframe.\"\"\"\n    return df.drop(list(column), axis=1)\ndef where_column_equals(df: pd.DataFrame, column: str, value: Any) -> pd.DataFrame:\n    \"\"\"Return a filtered DataFrame where a column equals a value.\"\"\"\n    return cast(pd.DataFrame, df[df[column] == value])\ndef antijoin(df: pd.DataFrame, exclude: pd.DataFrame, column: str) -> pd.DataFrame:\n    \"\"\"Return an anti-joined dataframe.\n    Arguments:\n    * df: The DataFrame to apply the exclusion to",
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "where_column_equals",
        "kind": 2,
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "peekOfCode": "def where_column_equals(df: pd.DataFrame, column: str, value: Any) -> pd.DataFrame:\n    \"\"\"Return a filtered DataFrame where a column equals a value.\"\"\"\n    return cast(pd.DataFrame, df[df[column] == value])\ndef antijoin(df: pd.DataFrame, exclude: pd.DataFrame, column: str) -> pd.DataFrame:\n    \"\"\"Return an anti-joined dataframe.\n    Arguments:\n    * df: The DataFrame to apply the exclusion to\n    * exclude: The DataFrame containing rows to remove.\n    * column: The join-on column.\n    \"\"\"",
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "antijoin",
        "kind": 2,
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "peekOfCode": "def antijoin(df: pd.DataFrame, exclude: pd.DataFrame, column: str) -> pd.DataFrame:\n    \"\"\"Return an anti-joined dataframe.\n    Arguments:\n    * df: The DataFrame to apply the exclusion to\n    * exclude: The DataFrame containing rows to remove.\n    * column: The join-on column.\n    \"\"\"\n    result = df.merge(\n        exclude[[column]],\n        on=column,",
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "transform_series",
        "kind": 2,
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "peekOfCode": "def transform_series(series: pd.Series, fn: Callable[[Any], Any]) -> pd.Series:\n    \"\"\"Apply a transformation function to a series.\"\"\"\n    return cast(pd.Series, series.apply(fn))\ndef join(\n    left: pd.DataFrame, right: pd.DataFrame, key: str, strategy: MergeHow = \"left\"\n) -> pd.DataFrame:\n    \"\"\"Perform a table join.\"\"\"\n    return left.merge(right, on=key, how=strategy)\ndef union(*frames: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Perform a union operation on the given set of dataframes.\"\"\"",
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "join",
        "kind": 2,
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "peekOfCode": "def join(\n    left: pd.DataFrame, right: pd.DataFrame, key: str, strategy: MergeHow = \"left\"\n) -> pd.DataFrame:\n    \"\"\"Perform a table join.\"\"\"\n    return left.merge(right, on=key, how=strategy)\ndef union(*frames: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Perform a union operation on the given set of dataframes.\"\"\"\n    return pd.concat(list(frames))\ndef select(df: pd.DataFrame, *columns: str) -> pd.DataFrame:\n    \"\"\"Select columns from a dataframe.\"\"\"",
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "union",
        "kind": 2,
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "peekOfCode": "def union(*frames: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Perform a union operation on the given set of dataframes.\"\"\"\n    return pd.concat(list(frames))\ndef select(df: pd.DataFrame, *columns: str) -> pd.DataFrame:\n    \"\"\"Select columns from a dataframe.\"\"\"\n    return cast(pd.DataFrame, df[list(columns)])",
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "select",
        "kind": 2,
        "importPath": "graphrag.index.utils.dataframes",
        "description": "graphrag.index.utils.dataframes",
        "peekOfCode": "def select(df: pd.DataFrame, *columns: str) -> pd.DataFrame:\n    \"\"\"Select columns from a dataframe.\"\"\"\n    return cast(pd.DataFrame, df[list(columns)])",
        "detail": "graphrag.index.utils.dataframes",
        "documentation": {}
    },
    {
        "label": "dict_has_keys_with_types",
        "kind": 2,
        "importPath": "graphrag.index.utils.dicts",
        "description": "graphrag.index.utils.dicts",
        "peekOfCode": "def dict_has_keys_with_types(\n    data: dict, expected_fields: list[tuple[str, type]], inplace: bool = False\n) -> bool:\n    \"\"\"Return True if the given dictionary has the given keys with the given types.\"\"\"\n    for field, field_type in expected_fields:\n        if field not in data:\n            return False\n        value = data[field]\n        try:\n            cast_value = field_type(value)",
        "detail": "graphrag.index.utils.dicts",
        "documentation": {}
    },
    {
        "label": "get_required_input_table",
        "kind": 2,
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "peekOfCode": "def get_required_input_table(input: VerbInput, name: str) -> TableContainer:\n    \"\"\"Get a required input table by name.\"\"\"\n    return cast(TableContainer, get_named_input_table(input, name, required=True))\ndef get_named_input_table(\n    input: VerbInput, name: str, required: bool = False\n) -> TableContainer | None:\n    \"\"\"Get an input table from datashaper verb-inputs by name.\"\"\"\n    named_inputs = input.named\n    if named_inputs is None:\n        if not required:",
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "get_named_input_table",
        "kind": 2,
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "peekOfCode": "def get_named_input_table(\n    input: VerbInput, name: str, required: bool = False\n) -> TableContainer | None:\n    \"\"\"Get an input table from datashaper verb-inputs by name.\"\"\"\n    named_inputs = input.named\n    if named_inputs is None:\n        if not required:\n            return None\n        raise ValueError(_NAMED_INPUTS_REQUIRED)\n    result = named_inputs.get(name)",
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "_NAMED_INPUTS_REQUIRED",
        "kind": 5,
        "importPath": "graphrag.index.utils.ds_util",
        "description": "graphrag.index.utils.ds_util",
        "peekOfCode": "_NAMED_INPUTS_REQUIRED = \"Named inputs are required\"\ndef get_required_input_table(input: VerbInput, name: str) -> TableContainer:\n    \"\"\"Get a required input table by name.\"\"\"\n    return cast(TableContainer, get_named_input_table(input, name, required=True))\ndef get_named_input_table(\n    input: VerbInput, name: str, required: bool = False\n) -> TableContainer | None:\n    \"\"\"Get an input table from datashaper verb-inputs by name.\"\"\"\n    named_inputs = input.named\n    if named_inputs is None:",
        "detail": "graphrag.index.utils.ds_util",
        "documentation": {}
    },
    {
        "label": "gen_md5_hash",
        "kind": 2,
        "importPath": "graphrag.index.utils.hashing",
        "description": "graphrag.index.utils.hashing",
        "peekOfCode": "def gen_md5_hash(item: dict[str, Any], hashcode: Iterable[str]):\n    \"\"\"Generate an md5 hash.\"\"\"\n    hashed = \"\".join([str(item[column]) for column in hashcode])\n    return f\"{md5(hashed.encode('utf-8'), usedforsecurity=False).hexdigest()}\"",
        "detail": "graphrag.index.utils.hashing",
        "documentation": {}
    },
    {
        "label": "is_null",
        "kind": 2,
        "importPath": "graphrag.index.utils.is_null",
        "description": "graphrag.index.utils.is_null",
        "peekOfCode": "def is_null(value: Any) -> bool:\n    \"\"\"Check if value is null or is nan.\"\"\"\n    def is_none() -> bool:\n        return value is None\n    def is_nan() -> bool:\n        return isinstance(value, float) and math.isnan(value)\n    return is_none() or is_nan()",
        "detail": "graphrag.index.utils.is_null",
        "documentation": {}
    },
    {
        "label": "load_graph",
        "kind": 2,
        "importPath": "graphrag.index.utils.load_graph",
        "description": "graphrag.index.utils.load_graph",
        "peekOfCode": "def load_graph(graphml: str | nx.Graph) -> nx.Graph:\n    \"\"\"Load a graph from a graphml file or a networkx graph.\"\"\"\n    return nx.parse_graphml(graphml) if isinstance(graphml, str) else graphml",
        "detail": "graphrag.index.utils.load_graph",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "kind": 6,
        "importPath": "graphrag.index.utils.rate_limiter",
        "description": "graphrag.index.utils.rate_limiter",
        "peekOfCode": "class RateLimiter:\n    \"\"\"\n    The original TpmRpmLLMLimiter strategy did not account for minute-based rate limiting when scheduled.\n    The RateLimiter was introduced to ensure that the CommunityReportsExtractor could be scheduled to adhere to rate configurations on a per-minute basis.\n    \"\"\"\n    # TODO: RateLimiter scheduled: using asyncio for async_mode\n    def __init__(self, rate: int, per: int):\n        self.rate = rate\n        self.per = per\n        self.allowance = rate",
        "detail": "graphrag.index.utils.rate_limiter",
        "documentation": {}
    },
    {
        "label": "clean_str",
        "kind": 2,
        "importPath": "graphrag.index.utils.string",
        "description": "graphrag.index.utils.string",
        "peekOfCode": "def clean_str(input: Any) -> str:\n    \"\"\"Clean an input string by removing HTML escapes, control characters, and other unwanted characters.\"\"\"\n    # If we get non-string input, just give it back\n    if not isinstance(input, str):\n        return input\n    result = html.unescape(input.strip())\n    # https://stackoverflow.com/questions/4324790/removing-control-characters-from-a-string-in-python\n    return re.sub(r\"[\\x00-\\x1f\\x7f-\\x9f]\", \"\", result)",
        "detail": "graphrag.index.utils.string",
        "documentation": {}
    },
    {
        "label": "num_tokens_from_string",
        "kind": 2,
        "importPath": "graphrag.index.utils.tokens",
        "description": "graphrag.index.utils.tokens",
        "peekOfCode": "def num_tokens_from_string(\n    string: str, model: str | None = None, encoding_name: str | None = None\n) -> int:\n    \"\"\"Return the number of tokens in a text string.\"\"\"\n    if model is not None:\n        try:\n            encoding = tiktoken.encoding_for_model(model)\n        except KeyError:\n            msg = f\"Failed to get encoding for {model} when getting num_tokens_from_string. Fall back to default encoding {DEFAULT_ENCODING_NAME}\"\n            log.warning(msg)",
        "detail": "graphrag.index.utils.tokens",
        "documentation": {}
    },
    {
        "label": "string_from_tokens",
        "kind": 2,
        "importPath": "graphrag.index.utils.tokens",
        "description": "graphrag.index.utils.tokens",
        "peekOfCode": "def string_from_tokens(\n    tokens: list[int], model: str | None = None, encoding_name: str | None = None\n) -> str:\n    \"\"\"Return a text string from a list of tokens.\"\"\"\n    if model is not None:\n        encoding = tiktoken.encoding_for_model(model)\n    elif encoding_name is not None:\n        encoding = tiktoken.get_encoding(encoding_name)\n    else:\n        msg = \"Either model or encoding_name must be specified.\"",
        "detail": "graphrag.index.utils.tokens",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENCODING_NAME",
        "kind": 5,
        "importPath": "graphrag.index.utils.tokens",
        "description": "graphrag.index.utils.tokens",
        "peekOfCode": "DEFAULT_ENCODING_NAME = \"cl100k_base\"\nlog = logging.getLogger(__name__)\ndef num_tokens_from_string(\n    string: str, model: str | None = None, encoding_name: str | None = None\n) -> int:\n    \"\"\"Return the number of tokens in a text string.\"\"\"\n    if model is not None:\n        try:\n            encoding = tiktoken.encoding_for_model(model)\n        except KeyError:",
        "detail": "graphrag.index.utils.tokens",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.utils.tokens",
        "description": "graphrag.index.utils.tokens",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef num_tokens_from_string(\n    string: str, model: str | None = None, encoding_name: str | None = None\n) -> int:\n    \"\"\"Return the number of tokens in a text string.\"\"\"\n    if model is not None:\n        try:\n            encoding = tiktoken.encoding_for_model(model)\n        except KeyError:\n            msg = f\"Failed to get encoding for {model} when getting num_tokens_from_string. Fall back to default encoding {DEFAULT_ENCODING_NAME}\"",
        "detail": "graphrag.index.utils.tokens",
        "documentation": {}
    },
    {
        "label": "topological_sort",
        "kind": 2,
        "importPath": "graphrag.index.utils.topological_sort",
        "description": "graphrag.index.utils.topological_sort",
        "peekOfCode": "def topological_sort(graph: dict[str, list[str]]) -> list[str]:\n    \"\"\"Topological sort.\"\"\"\n    ts = TopologicalSorter(graph)\n    return list(ts.static_order())",
        "detail": "graphrag.index.utils.topological_sort",
        "documentation": {}
    },
    {
        "label": "gen_uuid",
        "kind": 2,
        "importPath": "graphrag.index.utils.uuid",
        "description": "graphrag.index.utils.uuid",
        "peekOfCode": "def gen_uuid(rd: Random | None = None):\n    \"\"\"Generate a random UUID v4.\"\"\"\n    return uuid.UUID(\n        int=rd.getrandbits(128) if rd is not None else getrandbits(128), version=4\n    ).hex",
        "detail": "graphrag.index.utils.uuid",
        "documentation": {}
    },
    {
        "label": "create_base_documents",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.subflows.create_base_documents",
        "description": "graphrag.index.workflows.v1.subflows.create_base_documents",
        "peekOfCode": "def create_base_documents(\n    input: VerbInput,\n    document_attribute_columns: list[str] | None = None,\n    **_kwargs: dict,\n) -> VerbResult:\n    \"\"\"All the steps to transform base documents.\"\"\"\n    source = cast(pd.DataFrame, input.get_input())\n    text_units = cast(pd.DataFrame, get_required_input_table(input, \"text_units\").table)\n    output = create_base_documents_flow(\n        source, text_units, document_attribute_columns=document_attribute_columns",
        "detail": "graphrag.index.workflows.v1.subflows.create_base_documents",
        "documentation": {}
    },
    {
        "label": "create_base_text_units",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.subflows.create_base_text_units",
        "description": "graphrag.index.workflows.v1.subflows.create_base_text_units",
        "peekOfCode": "def create_base_text_units(\n    input: VerbInput,\n    callbacks: VerbCallbacks,\n    chunk_column_name: str,\n    n_tokens_column_name: str,\n    chunk_by_columns: list[str],\n    chunk_strategy: dict[str, Any] | None = None,\n    **_kwargs: dict,\n) -> VerbResult:\n    \"\"\"All the steps to transform base text_units.\"\"\"",
        "detail": "graphrag.index.workflows.v1.subflows.create_base_text_units",
        "documentation": {}
    },
    {
        "label": "create_final_communities",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.subflows.create_final_communities",
        "description": "graphrag.index.workflows.v1.subflows.create_final_communities",
        "peekOfCode": "def create_final_communities(\n    input: VerbInput,\n    callbacks: VerbCallbacks,\n    **_kwargs: dict,\n) -> VerbResult:\n    \"\"\"All the steps to transform final communities.\"\"\"\n    source = cast(pd.DataFrame, input.get_input())\n    output = create_final_communities_flow(\n        source,\n        callbacks,",
        "detail": "graphrag.index.workflows.v1.subflows.create_final_communities",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_base_documents",
        "description": "graphrag.index.workflows.v1.create_base_documents",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the documents table.\n    ## Dependencies\n    * `workflow:create_final_text_units`\n    \"\"\"\n    document_attribute_columns = config.get(\"document_attribute_columns\", [])\n    return [",
        "detail": "graphrag.index.workflows.v1.create_base_documents",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_base_documents",
        "description": "graphrag.index.workflows.v1.create_base_documents",
        "peekOfCode": "workflow_name = \"create_base_documents\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the documents table.\n    ## Dependencies\n    * `workflow:create_final_text_units`\n    \"\"\"\n    document_attribute_columns = config.get(\"document_attribute_columns\", [])",
        "detail": "graphrag.index.workflows.v1.create_base_documents",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_base_entity_graph",
        "description": "graphrag.index.workflows.v1.create_base_entity_graph",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for the entity graph.\n    ## Dependencies\n    * `workflow:create_base_extracted_entities`\n    \"\"\"\n    clustering_config = config.get(\n        \"cluster_graph\",",
        "detail": "graphrag.index.workflows.v1.create_base_entity_graph",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_base_entity_graph",
        "description": "graphrag.index.workflows.v1.create_base_entity_graph",
        "peekOfCode": "workflow_name = \"create_base_entity_graph\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for the entity graph.\n    ## Dependencies\n    * `workflow:create_base_extracted_entities`\n    \"\"\"\n    clustering_config = config.get(",
        "detail": "graphrag.index.workflows.v1.create_base_entity_graph",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "description": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for extracted entities.\n    ## Dependencies\n    * `workflow:create_base_text_units`\n    \"\"\"\n    entity_extraction_config = config.get(\"entity_extract\", {})\n    column = entity_extraction_config.get(\"text_column\", \"chunk\")",
        "detail": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "description": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "peekOfCode": "workflow_name = \"create_base_extracted_entities\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for extracted entities.\n    ## Dependencies\n    * `workflow:create_base_text_units`\n    \"\"\"\n    entity_extraction_config = config.get(\"entity_extract\", {})",
        "detail": "graphrag.index.workflows.v1.create_base_extracted_entities",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_base_text_units",
        "description": "graphrag.index.workflows.v1.create_base_text_units",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for text units.\n    ## Dependencies\n    None\n    \"\"\"\n    chunk_column_name = config.get(\"chunk_column\", \"chunk\")\n    chunk_by_columns = config.get(\"chunk_by\", []) or []",
        "detail": "graphrag.index.workflows.v1.create_base_text_units",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_base_text_units",
        "description": "graphrag.index.workflows.v1.create_base_text_units",
        "peekOfCode": "workflow_name = \"create_base_text_units\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for text units.\n    ## Dependencies\n    None\n    \"\"\"\n    chunk_column_name = config.get(\"chunk_column\", \"chunk\")",
        "detail": "graphrag.index.workflows.v1.create_base_text_units",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_final_communities",
        "description": "graphrag.index.workflows.v1.create_final_communities",
        "peekOfCode": "def build_steps(\n    _config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final communities table.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    \"\"\"\n    return [\n        {",
        "detail": "graphrag.index.workflows.v1.create_final_communities",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_final_communities",
        "description": "graphrag.index.workflows.v1.create_final_communities",
        "peekOfCode": "workflow_name = \"create_final_communities\"\ndef build_steps(\n    _config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final communities table.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    \"\"\"\n    return [",
        "detail": "graphrag.index.workflows.v1.create_final_communities",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_final_community_reports",
        "description": "graphrag.index.workflows.v1.create_final_community_reports",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final community reports table.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    \"\"\"\n    covariates_enabled = config.get(\"covariates_enabled\", False)\n    create_community_reports_config = config.get(\"create_community_reports\", {})",
        "detail": "graphrag.index.workflows.v1.create_final_community_reports",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_final_community_reports",
        "description": "graphrag.index.workflows.v1.create_final_community_reports",
        "peekOfCode": "workflow_name = \"create_final_community_reports\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final community reports table.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    \"\"\"\n    covariates_enabled = config.get(\"covariates_enabled\", False)",
        "detail": "graphrag.index.workflows.v1.create_final_community_reports",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_final_covariates",
        "description": "graphrag.index.workflows.v1.create_final_covariates",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final covariates table.\n    ## Dependencies\n    * `workflow:create_base_text_units`\n    * `workflow:create_base_extracted_entities`\n    \"\"\"\n    claim_extract_config = config.get(\"claim_extract\", {})",
        "detail": "graphrag.index.workflows.v1.create_final_covariates",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_final_covariates",
        "description": "graphrag.index.workflows.v1.create_final_covariates",
        "peekOfCode": "workflow_name = \"create_final_covariates\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final covariates table.\n    ## Dependencies\n    * `workflow:create_base_text_units`\n    * `workflow:create_base_extracted_entities`\n    \"\"\"",
        "detail": "graphrag.index.workflows.v1.create_final_covariates",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_final_documents",
        "description": "graphrag.index.workflows.v1.create_final_documents",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final documents table.\n    ## Dependencies\n    * `workflow:create_base_documents`\n    \"\"\"\n    base_text_embed = config.get(\"text_embed\", {})\n    document_raw_content_embed_config = config.get(",
        "detail": "graphrag.index.workflows.v1.create_final_documents",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_final_documents",
        "description": "graphrag.index.workflows.v1.create_final_documents",
        "peekOfCode": "workflow_name = \"create_final_documents\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final documents table.\n    ## Dependencies\n    * `workflow:create_base_documents`\n    \"\"\"\n    base_text_embed = config.get(\"text_embed\", {})",
        "detail": "graphrag.index.workflows.v1.create_final_documents",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_final_entities",
        "description": "graphrag.index.workflows.v1.create_final_entities",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final entities table.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    \"\"\"\n    base_text_embed = config.get(\"text_embed\", {})\n    entity_name_embed_config = config.get(\"entity_name_embed\", base_text_embed)",
        "detail": "graphrag.index.workflows.v1.create_final_entities",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_final_entities",
        "description": "graphrag.index.workflows.v1.create_final_entities",
        "peekOfCode": "workflow_name = \"create_final_entities\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final entities table.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    \"\"\"\n    base_text_embed = config.get(\"text_embed\", {})",
        "detail": "graphrag.index.workflows.v1.create_final_entities",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_final_nodes",
        "description": "graphrag.index.workflows.v1.create_final_nodes",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for the document graph.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    \"\"\"\n    snapshot_top_level_nodes = config.get(\"snapshot_top_level_nodes\", False)\n    layout_graph_enabled = config.get(\"layout_graph_enabled\", True)",
        "detail": "graphrag.index.workflows.v1.create_final_nodes",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_final_nodes",
        "description": "graphrag.index.workflows.v1.create_final_nodes",
        "peekOfCode": "workflow_name = \"create_final_nodes\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for the document graph.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    \"\"\"\n    snapshot_top_level_nodes = config.get(\"snapshot_top_level_nodes\", False)",
        "detail": "graphrag.index.workflows.v1.create_final_nodes",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_final_relationships",
        "description": "graphrag.index.workflows.v1.create_final_relationships",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final relationships table.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    * `workflow:create_final_nodes`\n    \"\"\"\n    base_text_embed = config.get(\"text_embed\", {})",
        "detail": "graphrag.index.workflows.v1.create_final_relationships",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_final_relationships",
        "description": "graphrag.index.workflows.v1.create_final_relationships",
        "peekOfCode": "workflow_name = \"create_final_relationships\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final relationships table.\n    ## Dependencies\n    * `workflow:create_base_entity_graph`\n    * `workflow:create_final_nodes`\n    \"\"\"",
        "detail": "graphrag.index.workflows.v1.create_final_relationships",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_final_text_units",
        "description": "graphrag.index.workflows.v1.create_final_text_units",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final text-units table.\n    ## Dependencies\n    * `workflow:create_base_text_units`\n    * `workflow:create_final_entities`\n    * `workflow:create_final_communities`\n    \"\"\"",
        "detail": "graphrag.index.workflows.v1.create_final_text_units",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_final_text_units",
        "description": "graphrag.index.workflows.v1.create_final_text_units",
        "peekOfCode": "workflow_name = \"create_final_text_units\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the final text-units table.\n    ## Dependencies\n    * `workflow:create_base_text_units`\n    * `workflow:create_final_entities`\n    * `workflow:create_final_communities`",
        "detail": "graphrag.index.workflows.v1.create_final_text_units",
        "documentation": {}
    },
    {
        "label": "build_steps",
        "kind": 2,
        "importPath": "graphrag.index.workflows.v1.create_summarized_entities",
        "description": "graphrag.index.workflows.v1.create_summarized_entities",
        "peekOfCode": "def build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for extracted entities.\n    ## Dependencies\n    * `workflow:create_base_text_units`\n    \"\"\"\n    summarize_descriptions_config = config.get(\"summarize_descriptions\", {})\n    summarization_strategy = summarize_descriptions_config.get(\"strategy\")",
        "detail": "graphrag.index.workflows.v1.create_summarized_entities",
        "documentation": {}
    },
    {
        "label": "workflow_name",
        "kind": 5,
        "importPath": "graphrag.index.workflows.v1.create_summarized_entities",
        "description": "graphrag.index.workflows.v1.create_summarized_entities",
        "peekOfCode": "workflow_name = \"create_summarized_entities\"\ndef build_steps(\n    config: PipelineWorkflowConfig,\n) -> list[PipelineWorkflowStep]:\n    \"\"\"\n    Create the base table for extracted entities.\n    ## Dependencies\n    * `workflow:create_base_text_units`\n    \"\"\"\n    summarize_descriptions_config = config.get(\"summarize_descriptions\", {})",
        "detail": "graphrag.index.workflows.v1.create_summarized_entities",
        "documentation": {}
    },
    {
        "label": "LoadWorkflowResult",
        "kind": 6,
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "peekOfCode": "class LoadWorkflowResult(NamedTuple):\n    \"\"\"A workflow loading result object.\"\"\"\n    workflows: list[WorkflowToRun]\n    \"\"\"The loaded workflow names in the order they should be run.\"\"\"\n    dependencies: dict[str, list[str]]\n    \"\"\"A dictionary of workflow name to workflow dependencies.\"\"\"\ndef load_workflows(\n    workflows_to_load: list[PipelineWorkflowReference],\n    additional_verbs: VerbDefinitions | None = None,\n    additional_workflows: WorkflowDefinitions | None = None,",
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "load_workflows",
        "kind": 2,
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "peekOfCode": "def load_workflows(\n    workflows_to_load: list[PipelineWorkflowReference],\n    additional_verbs: VerbDefinitions | None = None,\n    additional_workflows: WorkflowDefinitions | None = None,\n    memory_profile: bool = False,\n) -> LoadWorkflowResult:\n    \"\"\"Load the given workflows.\n    Args:\n        - workflows_to_load - The workflows to load\n        - additional_verbs - The list of custom verbs available to the workflows",
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "create_workflow",
        "kind": 2,
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "peekOfCode": "def create_workflow(\n    name: str,\n    steps: list[PipelineWorkflowStep] | None = None,\n    config: PipelineWorkflowConfig | None = None,\n    additional_verbs: VerbDefinitions | None = None,\n    additional_workflows: WorkflowDefinitions | None = None,\n    memory_profile: bool = False,\n) -> Workflow:\n    \"\"\"Create a workflow from the given config.\"\"\"\n    additional_workflows = {",
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "anonymous_workflow_count",
        "kind": 5,
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "peekOfCode": "anonymous_workflow_count = 0\nVerbFn = Callable[..., Any]\nlog = logging.getLogger(__name__)\nclass LoadWorkflowResult(NamedTuple):\n    \"\"\"A workflow loading result object.\"\"\"\n    workflows: list[WorkflowToRun]\n    \"\"\"The loaded workflow names in the order they should be run.\"\"\"\n    dependencies: dict[str, list[str]]\n    \"\"\"A dictionary of workflow name to workflow dependencies.\"\"\"\ndef load_workflows(",
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "VerbFn",
        "kind": 5,
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "peekOfCode": "VerbFn = Callable[..., Any]\nlog = logging.getLogger(__name__)\nclass LoadWorkflowResult(NamedTuple):\n    \"\"\"A workflow loading result object.\"\"\"\n    workflows: list[WorkflowToRun]\n    \"\"\"The loaded workflow names in the order they should be run.\"\"\"\n    dependencies: dict[str, list[str]]\n    \"\"\"A dictionary of workflow name to workflow dependencies.\"\"\"\ndef load_workflows(\n    workflows_to_load: list[PipelineWorkflowReference],",
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.workflows.load",
        "description": "graphrag.index.workflows.load",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass LoadWorkflowResult(NamedTuple):\n    \"\"\"A workflow loading result object.\"\"\"\n    workflows: list[WorkflowToRun]\n    \"\"\"The loaded workflow names in the order they should be run.\"\"\"\n    dependencies: dict[str, list[str]]\n    \"\"\"A dictionary of workflow name to workflow dependencies.\"\"\"\ndef load_workflows(\n    workflows_to_load: list[PipelineWorkflowReference],\n    additional_verbs: VerbDefinitions | None = None,",
        "detail": "graphrag.index.workflows.load",
        "documentation": {}
    },
    {
        "label": "WorkflowToRun",
        "kind": 6,
        "importPath": "graphrag.index.workflows.typing",
        "description": "graphrag.index.workflows.typing",
        "peekOfCode": "class WorkflowToRun:\n    \"\"\"Workflow to run class definition.\"\"\"\n    workflow: Workflow\n    config: dict[str, Any]",
        "detail": "graphrag.index.workflows.typing",
        "documentation": {}
    },
    {
        "label": "StepDefinition",
        "kind": 5,
        "importPath": "graphrag.index.workflows.typing",
        "description": "graphrag.index.workflows.typing",
        "peekOfCode": "StepDefinition = dict[str, Any]\n\"\"\"A step definition.\"\"\"\nVerbDefinitions = dict[str, Callable[..., TableContainer]]\n\"\"\"A mapping of verb names to their implementations.\"\"\"\nWorkflowConfig = dict[str, Any]\n\"\"\"A workflow configuration.\"\"\"\nWorkflowDefinitions = dict[str, Callable[[WorkflowConfig], list[StepDefinition]]]\n\"\"\"A mapping of workflow names to their implementations.\"\"\"\nVerbTiming = dict[str, float]\n\"\"\"The timings of verbs by id.\"\"\"",
        "detail": "graphrag.index.workflows.typing",
        "documentation": {}
    },
    {
        "label": "VerbDefinitions",
        "kind": 5,
        "importPath": "graphrag.index.workflows.typing",
        "description": "graphrag.index.workflows.typing",
        "peekOfCode": "VerbDefinitions = dict[str, Callable[..., TableContainer]]\n\"\"\"A mapping of verb names to their implementations.\"\"\"\nWorkflowConfig = dict[str, Any]\n\"\"\"A workflow configuration.\"\"\"\nWorkflowDefinitions = dict[str, Callable[[WorkflowConfig], list[StepDefinition]]]\n\"\"\"A mapping of workflow names to their implementations.\"\"\"\nVerbTiming = dict[str, float]\n\"\"\"The timings of verbs by id.\"\"\"\n@dc_dataclass\nclass WorkflowToRun:",
        "detail": "graphrag.index.workflows.typing",
        "documentation": {}
    },
    {
        "label": "WorkflowConfig",
        "kind": 5,
        "importPath": "graphrag.index.workflows.typing",
        "description": "graphrag.index.workflows.typing",
        "peekOfCode": "WorkflowConfig = dict[str, Any]\n\"\"\"A workflow configuration.\"\"\"\nWorkflowDefinitions = dict[str, Callable[[WorkflowConfig], list[StepDefinition]]]\n\"\"\"A mapping of workflow names to their implementations.\"\"\"\nVerbTiming = dict[str, float]\n\"\"\"The timings of verbs by id.\"\"\"\n@dc_dataclass\nclass WorkflowToRun:\n    \"\"\"Workflow to run class definition.\"\"\"\n    workflow: Workflow",
        "detail": "graphrag.index.workflows.typing",
        "documentation": {}
    },
    {
        "label": "WorkflowDefinitions",
        "kind": 5,
        "importPath": "graphrag.index.workflows.typing",
        "description": "graphrag.index.workflows.typing",
        "peekOfCode": "WorkflowDefinitions = dict[str, Callable[[WorkflowConfig], list[StepDefinition]]]\n\"\"\"A mapping of workflow names to their implementations.\"\"\"\nVerbTiming = dict[str, float]\n\"\"\"The timings of verbs by id.\"\"\"\n@dc_dataclass\nclass WorkflowToRun:\n    \"\"\"Workflow to run class definition.\"\"\"\n    workflow: Workflow\n    config: dict[str, Any]",
        "detail": "graphrag.index.workflows.typing",
        "documentation": {}
    },
    {
        "label": "VerbTiming",
        "kind": 5,
        "importPath": "graphrag.index.workflows.typing",
        "description": "graphrag.index.workflows.typing",
        "peekOfCode": "VerbTiming = dict[str, float]\n\"\"\"The timings of verbs by id.\"\"\"\n@dc_dataclass\nclass WorkflowToRun:\n    \"\"\"Workflow to run class definition.\"\"\"\n    workflow: Workflow\n    config: dict[str, Any]",
        "detail": "graphrag.index.workflows.typing",
        "documentation": {}
    },
    {
        "label": "bootstrap",
        "kind": 2,
        "importPath": "graphrag.index.bootstrap",
        "description": "graphrag.index.bootstrap",
        "peekOfCode": "def bootstrap():\n    \"\"\"Bootstrap definition.\"\"\"\n    global initialized_nltk\n    if not initialized_nltk:\n        import nltk\n        from nltk.corpus import wordnet as wn\n        nltk.download(\"punkt\")\n        nltk.download(\"punkt_tab\")\n        nltk.download(\"averaged_perceptron_tagger\")\n        nltk.download(\"averaged_perceptron_tagger_eng\")",
        "detail": "graphrag.index.bootstrap",
        "documentation": {}
    },
    {
        "label": "initialized_nltk",
        "kind": 5,
        "importPath": "graphrag.index.bootstrap",
        "description": "graphrag.index.bootstrap",
        "peekOfCode": "initialized_nltk = False\ndef bootstrap():\n    \"\"\"Bootstrap definition.\"\"\"\n    global initialized_nltk\n    if not initialized_nltk:\n        import nltk\n        from nltk.corpus import wordnet as wn\n        nltk.download(\"punkt\")\n        nltk.download(\"punkt_tab\")\n        nltk.download(\"averaged_perceptron_tagger\")",
        "detail": "graphrag.index.bootstrap",
        "documentation": {}
    },
    {
        "label": "index_cli",
        "kind": 2,
        "importPath": "graphrag.index.cli",
        "description": "graphrag.index.cli",
        "peekOfCode": "def index_cli(\n    root_dir: str,\n    init: bool,\n    verbose: bool,\n    resume: str,\n    update_index_id: str | None,\n    memprofile: bool,\n    nocache: bool,\n    reporter: ReporterType,\n    config_filepath: str | None,",
        "detail": "graphrag.index.cli",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.cli",
        "description": "graphrag.index.cli",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef _redact(input: dict) -> str:\n    \"\"\"Sanitize the config json.\"\"\"\n    # Redact any sensitive configuration\n    def redact_dict(input: dict) -> dict:\n        if not isinstance(input, dict):\n            return input\n        result = {}\n        for key, value in input.items():\n            if key in {",
        "detail": "graphrag.index.cli",
        "documentation": {}
    },
    {
        "label": "PipelineRunStats",
        "kind": 6,
        "importPath": "graphrag.index.context",
        "description": "graphrag.index.context",
        "peekOfCode": "class PipelineRunStats:\n    \"\"\"Pipeline running stats.\"\"\"\n    total_runtime: float = field(default=0)\n    \"\"\"Float representing the total runtime.\"\"\"\n    num_documents: int = field(default=0)\n    \"\"\"Number of documents.\"\"\"\n    input_load_time: float = field(default=0)\n    \"\"\"Float representing the input load time.\"\"\"\n    workflows: dict[str, dict[str, float]] = field(default_factory=dict)\n    \"\"\"A dictionary of workflows.\"\"\"",
        "detail": "graphrag.index.context",
        "documentation": {}
    },
    {
        "label": "PipelineRunContext",
        "kind": 6,
        "importPath": "graphrag.index.context",
        "description": "graphrag.index.context",
        "peekOfCode": "class PipelineRunContext:\n    \"\"\"Provides the context for the current pipeline run.\"\"\"\n    stats: PipelineRunStats\n    storage: PipelineStorage\n    cache: PipelineCache\n# TODO: For now, just has the same props available to it\nVerbRunContext = PipelineRunContext\n\"\"\"Provides the context for the current verb run.\"\"\"",
        "detail": "graphrag.index.context",
        "documentation": {}
    },
    {
        "label": "VerbRunContext",
        "kind": 5,
        "importPath": "graphrag.index.context",
        "description": "graphrag.index.context",
        "peekOfCode": "VerbRunContext = PipelineRunContext\n\"\"\"Provides the context for the current verb run.\"\"\"",
        "detail": "graphrag.index.context",
        "documentation": {}
    },
    {
        "label": "create_pipeline_config",
        "kind": 2,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "def create_pipeline_config(settings: GraphRagConfig, verbose=False) -> PipelineConfig:\n    \"\"\"Get the default config for the pipeline.\"\"\"\n    # relative to the root_dir\n    if verbose:\n        _log_llm_settings(settings)\n    skip_workflows = settings.skip_workflows\n    embedded_fields = _get_embedded_fields(settings)\n    covariates_enabled = (\n        settings.claim_extraction.enabled\n        and create_final_covariates not in skip_workflows",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "log = logging.getLogger(__name__)\nentity_name_embedding = \"entity.name\"\nentity_description_embedding = \"entity.description\"\nrelationship_description_embedding = \"relationship.description\"\ndocument_raw_content_embedding = \"document.raw_content\"\ncommunity_title_embedding = \"community.title\"\ncommunity_summary_embedding = \"community.summary\"\ncommunity_full_content_embedding = \"community.full_content\"\ntext_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "entity_name_embedding",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "entity_name_embedding = \"entity.name\"\nentity_description_embedding = \"entity.description\"\nrelationship_description_embedding = \"relationship.description\"\ndocument_raw_content_embedding = \"document.raw_content\"\ncommunity_title_embedding = \"community.title\"\ncommunity_summary_embedding = \"community.summary\"\ncommunity_full_content_embedding = \"community.full_content\"\ntext_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {\n    entity_name_embedding,",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "entity_description_embedding",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "entity_description_embedding = \"entity.description\"\nrelationship_description_embedding = \"relationship.description\"\ndocument_raw_content_embedding = \"document.raw_content\"\ncommunity_title_embedding = \"community.title\"\ncommunity_summary_embedding = \"community.summary\"\ncommunity_full_content_embedding = \"community.full_content\"\ntext_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {\n    entity_name_embedding,\n    entity_description_embedding,",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "relationship_description_embedding",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "relationship_description_embedding = \"relationship.description\"\ndocument_raw_content_embedding = \"document.raw_content\"\ncommunity_title_embedding = \"community.title\"\ncommunity_summary_embedding = \"community.summary\"\ncommunity_full_content_embedding = \"community.full_content\"\ntext_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {\n    entity_name_embedding,\n    entity_description_embedding,\n    relationship_description_embedding,",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "document_raw_content_embedding",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "document_raw_content_embedding = \"document.raw_content\"\ncommunity_title_embedding = \"community.title\"\ncommunity_summary_embedding = \"community.summary\"\ncommunity_full_content_embedding = \"community.full_content\"\ntext_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {\n    entity_name_embedding,\n    entity_description_embedding,\n    relationship_description_embedding,\n    document_raw_content_embedding,",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "community_title_embedding",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "community_title_embedding = \"community.title\"\ncommunity_summary_embedding = \"community.summary\"\ncommunity_full_content_embedding = \"community.full_content\"\ntext_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {\n    entity_name_embedding,\n    entity_description_embedding,\n    relationship_description_embedding,\n    document_raw_content_embedding,\n    community_title_embedding,",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "community_summary_embedding",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "community_summary_embedding = \"community.summary\"\ncommunity_full_content_embedding = \"community.full_content\"\ntext_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {\n    entity_name_embedding,\n    entity_description_embedding,\n    relationship_description_embedding,\n    document_raw_content_embedding,\n    community_title_embedding,\n    community_summary_embedding,",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "community_full_content_embedding",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "community_full_content_embedding = \"community.full_content\"\ntext_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {\n    entity_name_embedding,\n    entity_description_embedding,\n    relationship_description_embedding,\n    document_raw_content_embedding,\n    community_title_embedding,\n    community_summary_embedding,\n    community_full_content_embedding,",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "text_unit_text_embedding",
        "kind": 5,
        "importPath": "graphrag.index.create_pipeline_config",
        "description": "graphrag.index.create_pipeline_config",
        "peekOfCode": "text_unit_text_embedding = \"text_unit.text\"\nall_embeddings: set[str] = {\n    entity_name_embedding,\n    entity_description_embedding,\n    relationship_description_embedding,\n    document_raw_content_embedding,\n    community_title_embedding,\n    community_summary_embedding,\n    community_full_content_embedding,\n    text_unit_text_embedding,",
        "detail": "graphrag.index.create_pipeline_config",
        "documentation": {}
    },
    {
        "label": "NoWorkflowsDefinedError",
        "kind": 6,
        "importPath": "graphrag.index.errors",
        "description": "graphrag.index.errors",
        "peekOfCode": "class NoWorkflowsDefinedError(ValueError):\n    \"\"\"Exception for no workflows defined.\"\"\"\n    def __init__(self):\n        super().__init__(\"No workflows defined.\")\nclass UndefinedWorkflowError(ValueError):\n    \"\"\"Exception for invalid verb input.\"\"\"\n    def __init__(self):\n        super().__init__(\"Workflow name is undefined.\")\nclass UnknownWorkflowError(ValueError):\n    \"\"\"Exception for invalid verb input.\"\"\"",
        "detail": "graphrag.index.errors",
        "documentation": {}
    },
    {
        "label": "UndefinedWorkflowError",
        "kind": 6,
        "importPath": "graphrag.index.errors",
        "description": "graphrag.index.errors",
        "peekOfCode": "class UndefinedWorkflowError(ValueError):\n    \"\"\"Exception for invalid verb input.\"\"\"\n    def __init__(self):\n        super().__init__(\"Workflow name is undefined.\")\nclass UnknownWorkflowError(ValueError):\n    \"\"\"Exception for invalid verb input.\"\"\"\n    def __init__(self, name: str):\n        super().__init__(f\"Unknown workflow: {name}\")",
        "detail": "graphrag.index.errors",
        "documentation": {}
    },
    {
        "label": "UnknownWorkflowError",
        "kind": 6,
        "importPath": "graphrag.index.errors",
        "description": "graphrag.index.errors",
        "peekOfCode": "class UnknownWorkflowError(ValueError):\n    \"\"\"Exception for invalid verb input.\"\"\"\n    def __init__(self, name: str):\n        super().__init__(f\"Unknown workflow: {name}\")",
        "detail": "graphrag.index.errors",
        "documentation": {}
    },
    {
        "label": "INIT_YAML",
        "kind": 5,
        "importPath": "graphrag.index.init_content",
        "description": "graphrag.index.init_content",
        "peekOfCode": "INIT_YAML = f\"\"\"\nencoding_model: cl100k_base\nskip_workflows: []\nllm:\n  api_key: ${{GRAPHRAG_API_KEY}}\n  type: {defs.LLM_TYPE.value} # or azure_openai_chat\n  model: {defs.LLM_MODEL}\n  model_supports_json: true # recommended if this is available for your model.\n  # max_tokens: {defs.LLM_MAX_TOKENS}\n  # request_timeout: {defs.LLM_REQUEST_TIMEOUT}",
        "detail": "graphrag.index.init_content",
        "documentation": {}
    },
    {
        "label": "INIT_DOTENV",
        "kind": 5,
        "importPath": "graphrag.index.init_content",
        "description": "graphrag.index.init_content",
        "peekOfCode": "INIT_DOTENV = \"\"\"\nGRAPHRAG_API_KEY=<API_KEY>\n\"\"\"",
        "detail": "graphrag.index.init_content",
        "documentation": {}
    },
    {
        "label": "load_pipeline_config",
        "kind": 2,
        "importPath": "graphrag.index.load_pipeline_config",
        "description": "graphrag.index.load_pipeline_config",
        "peekOfCode": "def load_pipeline_config(config_or_path: str | PipelineConfig) -> PipelineConfig:\n    \"\"\"Load a pipeline config from a file path or a config object.\"\"\"\n    if isinstance(config_or_path, PipelineConfig):\n        config = config_or_path\n    elif config_or_path == \"default\":\n        config = create_pipeline_config(create_graphrag_config(root_dir=\".\"))\n    else:\n        # Is there a .env file in the same directory as the config?\n        read_dotenv(str(Path(config_or_path).parent))\n        if config_or_path.endswith(\".json\"):",
        "detail": "graphrag.index.load_pipeline_config",
        "documentation": {}
    },
    {
        "label": "PipelineRunResult",
        "kind": 6,
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "peekOfCode": "class PipelineRunResult:\n    \"\"\"Pipeline run result class definition.\"\"\"\n    workflow: str\n    result: pd.DataFrame | None\n    errors: list[BaseException] | None",
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "kind": 5,
        "importPath": "graphrag.index.typing",
        "description": "graphrag.index.typing",
        "peekOfCode": "ErrorHandlerFn = Callable[[BaseException | None, str | None, dict | None], None]\n@dataclass\nclass PipelineRunResult:\n    \"\"\"Pipeline run result class definition.\"\"\"\n    workflow: str\n    result: pd.DataFrame | None\n    errors: list[BaseException] | None",
        "detail": "graphrag.index.typing",
        "documentation": {}
    },
    {
        "label": "validate_config_names",
        "kind": 2,
        "importPath": "graphrag.index.validate_config",
        "description": "graphrag.index.validate_config",
        "peekOfCode": "def validate_config_names(\n    reporter: ProgressReporter, parameters: GraphRagConfig\n) -> None:\n    \"\"\"Validate config file for LLM deployment name typos.\"\"\"\n    # Validate Chat LLM configs\n    llm = load_llm(\n        \"test-llm\",\n        parameters.llm.type,\n        NoopVerbCallbacks(),\n        None,",
        "detail": "graphrag.index.validate_config",
        "documentation": {}
    },
    {
        "label": "create_hash_key",
        "kind": 2,
        "importPath": "graphrag.llm.base._create_cache_key",
        "description": "graphrag.llm.base._create_cache_key",
        "peekOfCode": "def create_hash_key(\n    operation: str, prompt: str, parameters: dict, history: list[dict] | None\n) -> str:\n    \"\"\"Compute cache key from prompt and associated model and settings.\n    Args:\n        prompt (str): The prompt run through the language model.\n        llm_string (str): The language model version and settings.\n    Returns\n    -------\n        str: The cache key.",
        "detail": "graphrag.llm.base._create_cache_key",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "kind": 6,
        "importPath": "graphrag.llm.base.base_llm",
        "description": "graphrag.llm.base.base_llm",
        "peekOfCode": "class BaseLLM(ABC, LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"LLM Implementation class definition.\"\"\"\n    _on_error: ErrorHandlerFn | None\n    def on_error(self, on_error: ErrorHandlerFn | None) -> None:\n        \"\"\"Set the error handler function.\"\"\"\n        self._on_error = on_error\n    @abstractmethod\n    async def _execute_llm(\n        self,\n        input: TIn,",
        "detail": "graphrag.llm.base.base_llm",
        "documentation": {}
    },
    {
        "label": "TIn",
        "kind": 5,
        "importPath": "graphrag.llm.base.base_llm",
        "description": "graphrag.llm.base.base_llm",
        "peekOfCode": "TIn = TypeVar(\"TIn\")\nTOut = TypeVar(\"TOut\")\nclass BaseLLM(ABC, LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"LLM Implementation class definition.\"\"\"\n    _on_error: ErrorHandlerFn | None\n    def on_error(self, on_error: ErrorHandlerFn | None) -> None:\n        \"\"\"Set the error handler function.\"\"\"\n        self._on_error = on_error\n    @abstractmethod\n    async def _execute_llm(",
        "detail": "graphrag.llm.base.base_llm",
        "documentation": {}
    },
    {
        "label": "TOut",
        "kind": 5,
        "importPath": "graphrag.llm.base.base_llm",
        "description": "graphrag.llm.base.base_llm",
        "peekOfCode": "TOut = TypeVar(\"TOut\")\nclass BaseLLM(ABC, LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"LLM Implementation class definition.\"\"\"\n    _on_error: ErrorHandlerFn | None\n    def on_error(self, on_error: ErrorHandlerFn | None) -> None:\n        \"\"\"Set the error handler function.\"\"\"\n        self._on_error = on_error\n    @abstractmethod\n    async def _execute_llm(\n        self,",
        "detail": "graphrag.llm.base.base_llm",
        "documentation": {}
    },
    {
        "label": "CachingLLM",
        "kind": 6,
        "importPath": "graphrag.llm.base.caching_llm",
        "description": "graphrag.llm.base.caching_llm",
        "peekOfCode": "class CachingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _cache: LLMCache\n    _delegate: LLM[TIn, TOut]\n    _operation: str\n    _llm_parameters: dict\n    _on_cache_hit: OnCacheActionFn\n    _on_cache_miss: OnCacheActionFn\n    def __init__(\n        self,",
        "detail": "graphrag.llm.base.caching_llm",
        "documentation": {}
    },
    {
        "label": "_cache_strategy_version",
        "kind": 5,
        "importPath": "graphrag.llm.base.caching_llm",
        "description": "graphrag.llm.base.caching_llm",
        "peekOfCode": "_cache_strategy_version = 2\nTIn = TypeVar(\"TIn\")\nTOut = TypeVar(\"TOut\")\ndef _noop_cache_fn(_k: str, _v: str | None):\n    pass\nclass CachingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _cache: LLMCache\n    _delegate: LLM[TIn, TOut]\n    _operation: str",
        "detail": "graphrag.llm.base.caching_llm",
        "documentation": {}
    },
    {
        "label": "TIn",
        "kind": 5,
        "importPath": "graphrag.llm.base.caching_llm",
        "description": "graphrag.llm.base.caching_llm",
        "peekOfCode": "TIn = TypeVar(\"TIn\")\nTOut = TypeVar(\"TOut\")\ndef _noop_cache_fn(_k: str, _v: str | None):\n    pass\nclass CachingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _cache: LLMCache\n    _delegate: LLM[TIn, TOut]\n    _operation: str\n    _llm_parameters: dict",
        "detail": "graphrag.llm.base.caching_llm",
        "documentation": {}
    },
    {
        "label": "TOut",
        "kind": 5,
        "importPath": "graphrag.llm.base.caching_llm",
        "description": "graphrag.llm.base.caching_llm",
        "peekOfCode": "TOut = TypeVar(\"TOut\")\ndef _noop_cache_fn(_k: str, _v: str | None):\n    pass\nclass CachingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _cache: LLMCache\n    _delegate: LLM[TIn, TOut]\n    _operation: str\n    _llm_parameters: dict\n    _on_cache_hit: OnCacheActionFn",
        "detail": "graphrag.llm.base.caching_llm",
        "documentation": {}
    },
    {
        "label": "RateLimitingLLM",
        "kind": 6,
        "importPath": "graphrag.llm.base.rate_limiting_llm",
        "description": "graphrag.llm.base.rate_limiting_llm",
        "peekOfCode": "class RateLimitingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _delegate: LLM[TIn, TOut]\n    _rate_limiter: LLMLimiter | None\n    _semaphore: asyncio.Semaphore | None\n    _count_tokens: Callable[[str], int]\n    _config: LLMConfig\n    _operation: str\n    _retryable_errors: list[type[Exception]]\n    _rate_limit_errors: list[type[Exception]]",
        "detail": "graphrag.llm.base.rate_limiting_llm",
        "documentation": {}
    },
    {
        "label": "TIn",
        "kind": 5,
        "importPath": "graphrag.llm.base.rate_limiting_llm",
        "description": "graphrag.llm.base.rate_limiting_llm",
        "peekOfCode": "TIn = TypeVar(\"TIn\")\nTOut = TypeVar(\"TOut\")\nTRateLimitError = TypeVar(\"TRateLimitError\", bound=BaseException)\n_CANNOT_MEASURE_INPUT_TOKENS_MSG = \"cannot measure input tokens\"\n_CANNOT_MEASURE_OUTPUT_TOKENS_MSG = \"cannot measure output tokens\"\nlog = logging.getLogger(__name__)\nclass RateLimitingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _delegate: LLM[TIn, TOut]\n    _rate_limiter: LLMLimiter | None",
        "detail": "graphrag.llm.base.rate_limiting_llm",
        "documentation": {}
    },
    {
        "label": "TOut",
        "kind": 5,
        "importPath": "graphrag.llm.base.rate_limiting_llm",
        "description": "graphrag.llm.base.rate_limiting_llm",
        "peekOfCode": "TOut = TypeVar(\"TOut\")\nTRateLimitError = TypeVar(\"TRateLimitError\", bound=BaseException)\n_CANNOT_MEASURE_INPUT_TOKENS_MSG = \"cannot measure input tokens\"\n_CANNOT_MEASURE_OUTPUT_TOKENS_MSG = \"cannot measure output tokens\"\nlog = logging.getLogger(__name__)\nclass RateLimitingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _delegate: LLM[TIn, TOut]\n    _rate_limiter: LLMLimiter | None\n    _semaphore: asyncio.Semaphore | None",
        "detail": "graphrag.llm.base.rate_limiting_llm",
        "documentation": {}
    },
    {
        "label": "TRateLimitError",
        "kind": 5,
        "importPath": "graphrag.llm.base.rate_limiting_llm",
        "description": "graphrag.llm.base.rate_limiting_llm",
        "peekOfCode": "TRateLimitError = TypeVar(\"TRateLimitError\", bound=BaseException)\n_CANNOT_MEASURE_INPUT_TOKENS_MSG = \"cannot measure input tokens\"\n_CANNOT_MEASURE_OUTPUT_TOKENS_MSG = \"cannot measure output tokens\"\nlog = logging.getLogger(__name__)\nclass RateLimitingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _delegate: LLM[TIn, TOut]\n    _rate_limiter: LLMLimiter | None\n    _semaphore: asyncio.Semaphore | None\n    _count_tokens: Callable[[str], int]",
        "detail": "graphrag.llm.base.rate_limiting_llm",
        "documentation": {}
    },
    {
        "label": "_CANNOT_MEASURE_INPUT_TOKENS_MSG",
        "kind": 5,
        "importPath": "graphrag.llm.base.rate_limiting_llm",
        "description": "graphrag.llm.base.rate_limiting_llm",
        "peekOfCode": "_CANNOT_MEASURE_INPUT_TOKENS_MSG = \"cannot measure input tokens\"\n_CANNOT_MEASURE_OUTPUT_TOKENS_MSG = \"cannot measure output tokens\"\nlog = logging.getLogger(__name__)\nclass RateLimitingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _delegate: LLM[TIn, TOut]\n    _rate_limiter: LLMLimiter | None\n    _semaphore: asyncio.Semaphore | None\n    _count_tokens: Callable[[str], int]\n    _config: LLMConfig",
        "detail": "graphrag.llm.base.rate_limiting_llm",
        "documentation": {}
    },
    {
        "label": "_CANNOT_MEASURE_OUTPUT_TOKENS_MSG",
        "kind": 5,
        "importPath": "graphrag.llm.base.rate_limiting_llm",
        "description": "graphrag.llm.base.rate_limiting_llm",
        "peekOfCode": "_CANNOT_MEASURE_OUTPUT_TOKENS_MSG = \"cannot measure output tokens\"\nlog = logging.getLogger(__name__)\nclass RateLimitingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _delegate: LLM[TIn, TOut]\n    _rate_limiter: LLMLimiter | None\n    _semaphore: asyncio.Semaphore | None\n    _count_tokens: Callable[[str], int]\n    _config: LLMConfig\n    _operation: str",
        "detail": "graphrag.llm.base.rate_limiting_llm",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.llm.base.rate_limiting_llm",
        "description": "graphrag.llm.base.rate_limiting_llm",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass RateLimitingLLM(LLM[TIn, TOut], Generic[TIn, TOut]):\n    \"\"\"A class to interact with the cache.\"\"\"\n    _delegate: LLM[TIn, TOut]\n    _rate_limiter: LLMLimiter | None\n    _semaphore: asyncio.Semaphore | None\n    _count_tokens: Callable[[str], int]\n    _config: LLMConfig\n    _operation: str\n    _retryable_errors: list[type[Exception]]",
        "detail": "graphrag.llm.base.rate_limiting_llm",
        "documentation": {}
    },
    {
        "label": "CompositeLLMLimiter",
        "kind": 6,
        "importPath": "graphrag.llm.limiting.composite_limiter",
        "description": "graphrag.llm.limiting.composite_limiter",
        "peekOfCode": "class CompositeLLMLimiter(LLMLimiter):\n    \"\"\"Composite Limiter class definition.\"\"\"\n    _limiters: list[LLMLimiter]\n    def __init__(self, limiters: list[LLMLimiter]):\n        \"\"\"Init method definition.\"\"\"\n        self._limiters = limiters\n    @property\n    def needs_token_count(self) -> bool:\n        \"\"\"Whether this limiter needs the token count to be passed in.\"\"\"\n        return any(limiter.needs_token_count for limiter in self._limiters)",
        "detail": "graphrag.llm.limiting.composite_limiter",
        "documentation": {}
    },
    {
        "label": "create_tpm_rpm_limiters",
        "kind": 2,
        "importPath": "graphrag.llm.limiting.create_limiters",
        "description": "graphrag.llm.limiting.create_limiters",
        "peekOfCode": "def create_tpm_rpm_limiters(\n    configuration: LLMConfig,\n) -> LLMLimiter:\n    \"\"\"Get the limiters for a given model name.\"\"\"\n    tpm = configuration.tokens_per_minute\n    rpm = configuration.requests_per_minute\n    return TpmRpmLLMLimiter(\n        None if tpm == 0 else AsyncLimiter(tpm or 50_000),\n        None if rpm == 0 else AsyncLimiter(rpm or 10_000),\n    )",
        "detail": "graphrag.llm.limiting.create_limiters",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.llm.limiting.create_limiters",
        "description": "graphrag.llm.limiting.create_limiters",
        "peekOfCode": "log = logging.getLogger(__name__)\n\"\"\"The global TPM limiters.\"\"\"\ndef create_tpm_rpm_limiters(\n    configuration: LLMConfig,\n) -> LLMLimiter:\n    \"\"\"Get the limiters for a given model name.\"\"\"\n    tpm = configuration.tokens_per_minute\n    rpm = configuration.requests_per_minute\n    return TpmRpmLLMLimiter(\n        None if tpm == 0 else AsyncLimiter(tpm or 50_000),",
        "detail": "graphrag.llm.limiting.create_limiters",
        "documentation": {}
    },
    {
        "label": "LLMLimiter",
        "kind": 6,
        "importPath": "graphrag.llm.limiting.llm_limiter",
        "description": "graphrag.llm.limiting.llm_limiter",
        "peekOfCode": "class LLMLimiter(ABC):\n    \"\"\"LLM Limiter Interface.\"\"\"\n    @property\n    @abstractmethod\n    def needs_token_count(self) -> bool:\n        \"\"\"Whether this limiter needs the token count to be passed in.\"\"\"\n    @abstractmethod\n    async def acquire(self, num_tokens: int = 1) -> None:\n        \"\"\"Acquire a pass through the limiter.\"\"\"",
        "detail": "graphrag.llm.limiting.llm_limiter",
        "documentation": {}
    },
    {
        "label": "NoopLLMLimiter",
        "kind": 6,
        "importPath": "graphrag.llm.limiting.noop_llm_limiter",
        "description": "graphrag.llm.limiting.noop_llm_limiter",
        "peekOfCode": "class NoopLLMLimiter(LLMLimiter):\n    \"\"\"TPM RPM Limiter class definition.\"\"\"\n    @property\n    def needs_token_count(self) -> bool:\n        \"\"\"Whether this limiter needs the token count to be passed in.\"\"\"\n        return False\n    async def acquire(self, num_tokens: int = 1) -> None:\n        \"\"\"Call method definition.\"\"\"\n        # do nothing",
        "detail": "graphrag.llm.limiting.noop_llm_limiter",
        "documentation": {}
    },
    {
        "label": "TpmRpmLLMLimiter",
        "kind": 6,
        "importPath": "graphrag.llm.limiting.tpm_rpm_limiter",
        "description": "graphrag.llm.limiting.tpm_rpm_limiter",
        "peekOfCode": "class TpmRpmLLMLimiter(LLMLimiter):\n    \"\"\"TPM RPM Limiter class definition.\"\"\"\n    _tpm_limiter: AsyncLimiter | None\n    _rpm_limiter: AsyncLimiter | None\n    def __init__(\n        self, tpm_limiter: AsyncLimiter | None, rpm_limiter: AsyncLimiter | None\n    ):\n        \"\"\"Init method definition.\"\"\"\n        self._tpm_limiter = tpm_limiter\n        self._rpm_limiter = rpm_limiter",
        "detail": "graphrag.llm.limiting.tpm_rpm_limiter",
        "documentation": {}
    },
    {
        "label": "MockChatLLM",
        "kind": 6,
        "importPath": "graphrag.llm.mock.mock_chat_llm",
        "description": "graphrag.llm.mock.mock_chat_llm",
        "peekOfCode": "class MockChatLLM(\n    BaseLLM[\n        CompletionInput,\n        CompletionOutput,\n    ]\n):\n    \"\"\"A mock LLM that returns the given responses.\"\"\"\n    responses: list[str]\n    i: int = 0\n    def __init__(self, responses: list[str]):",
        "detail": "graphrag.llm.mock.mock_chat_llm",
        "documentation": {}
    },
    {
        "label": "MockCompletionLLM",
        "kind": 6,
        "importPath": "graphrag.llm.mock.mock_completion_llm",
        "description": "graphrag.llm.mock.mock_completion_llm",
        "peekOfCode": "class MockCompletionLLM(\n    BaseLLM[\n        CompletionInput,\n        CompletionOutput,\n    ]\n):\n    \"\"\"Mock Completion LLM for testing purposes.\"\"\"\n    def __init__(self, responses: list[str]):\n        self.responses = responses\n        self._on_error = None",
        "detail": "graphrag.llm.mock.mock_completion_llm",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.llm.mock.mock_completion_llm",
        "description": "graphrag.llm.mock.mock_completion_llm",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass MockCompletionLLM(\n    BaseLLM[\n        CompletionInput,\n        CompletionOutput,\n    ]\n):\n    \"\"\"Mock Completion LLM for testing purposes.\"\"\"\n    def __init__(self, responses: list[str]):\n        self.responses = responses",
        "detail": "graphrag.llm.mock.mock_completion_llm",
        "documentation": {}
    },
    {
        "label": "JSON_CHECK_PROMPT",
        "kind": 5,
        "importPath": "graphrag.llm.openai._prompts",
        "description": "graphrag.llm.openai._prompts",
        "peekOfCode": "JSON_CHECK_PROMPT = \"\"\"\nYou are going to be given a malformed JSON string that threw an error during json.loads.\nIt probably contains unnecessary escape sequences, or it is missing a comma or colon somewhere.\nYour task is to fix this string and return a well-formed JSON string containing a single object.\nEliminate any unnecessary escape sequences.\nOnly return valid JSON, parseable with json.loads, without commentary.\n# Examples\n-----------\nText: {{ \\\\\"title\\\\\": \\\\\"abc\\\\\", \\\\\"summary\\\\\": \\\\\"def\\\\\" }}\nOutput: {{\"title\": \"abc\", \"summary\": \"def\"}}",
        "detail": "graphrag.llm.openai._prompts",
        "documentation": {}
    },
    {
        "label": "create_openai_client",
        "kind": 2,
        "importPath": "graphrag.llm.openai.create_openai_client",
        "description": "graphrag.llm.openai.create_openai_client",
        "peekOfCode": "def create_openai_client(\n    configuration: OpenAIConfiguration, azure: bool\n) -> OpenAIClientTypes:\n    \"\"\"Create a new OpenAI client instance.\"\"\"\n    if azure:\n        api_base = configuration.api_base\n        if api_base is None:\n            raise ValueError(API_BASE_REQUIRED_FOR_AZURE)\n        log.info(\n            \"Creating Azure OpenAI client api_base=%s, deployment_name=%s\",",
        "detail": "graphrag.llm.openai.create_openai_client",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.llm.openai.create_openai_client",
        "description": "graphrag.llm.openai.create_openai_client",
        "peekOfCode": "log = logging.getLogger(__name__)\nAPI_BASE_REQUIRED_FOR_AZURE = \"api_base is required for Azure OpenAI client\"\n@cache\ndef create_openai_client(\n    configuration: OpenAIConfiguration, azure: bool\n) -> OpenAIClientTypes:\n    \"\"\"Create a new OpenAI client instance.\"\"\"\n    if azure:\n        api_base = configuration.api_base\n        if api_base is None:",
        "detail": "graphrag.llm.openai.create_openai_client",
        "documentation": {}
    },
    {
        "label": "API_BASE_REQUIRED_FOR_AZURE",
        "kind": 5,
        "importPath": "graphrag.llm.openai.create_openai_client",
        "description": "graphrag.llm.openai.create_openai_client",
        "peekOfCode": "API_BASE_REQUIRED_FOR_AZURE = \"api_base is required for Azure OpenAI client\"\n@cache\ndef create_openai_client(\n    configuration: OpenAIConfiguration, azure: bool\n) -> OpenAIClientTypes:\n    \"\"\"Create a new OpenAI client instance.\"\"\"\n    if azure:\n        api_base = configuration.api_base\n        if api_base is None:\n            raise ValueError(API_BASE_REQUIRED_FOR_AZURE)",
        "detail": "graphrag.llm.openai.create_openai_client",
        "documentation": {}
    },
    {
        "label": "create_openai_chat_llm",
        "kind": 2,
        "importPath": "graphrag.llm.openai.factories",
        "description": "graphrag.llm.openai.factories",
        "peekOfCode": "def create_openai_chat_llm(\n    client: OpenAIClientTypes,\n    config: OpenAIConfiguration,\n    cache: LLMCache | None = None,\n    limiter: LLMLimiter | None = None,\n    semaphore: asyncio.Semaphore | None = None,\n    on_invoke: LLMInvocationFn | None = None,\n    on_error: ErrorHandlerFn | None = None,\n    on_cache_hit: OnCacheActionFn | None = None,\n    on_cache_miss: OnCacheActionFn | None = None,",
        "detail": "graphrag.llm.openai.factories",
        "documentation": {}
    },
    {
        "label": "create_openai_completion_llm",
        "kind": 2,
        "importPath": "graphrag.llm.openai.factories",
        "description": "graphrag.llm.openai.factories",
        "peekOfCode": "def create_openai_completion_llm(\n    client: OpenAIClientTypes,\n    config: OpenAIConfiguration,\n    cache: LLMCache | None = None,\n    limiter: LLMLimiter | None = None,\n    semaphore: asyncio.Semaphore | None = None,\n    on_invoke: LLMInvocationFn | None = None,\n    on_error: ErrorHandlerFn | None = None,\n    on_cache_hit: OnCacheActionFn | None = None,\n    on_cache_miss: OnCacheActionFn | None = None,",
        "detail": "graphrag.llm.openai.factories",
        "documentation": {}
    },
    {
        "label": "create_openai_embedding_llm",
        "kind": 2,
        "importPath": "graphrag.llm.openai.factories",
        "description": "graphrag.llm.openai.factories",
        "peekOfCode": "def create_openai_embedding_llm(\n    client: OpenAIClientTypes,\n    config: OpenAIConfiguration,\n    cache: LLMCache | None = None,\n    limiter: LLMLimiter | None = None,\n    semaphore: asyncio.Semaphore | None = None,\n    on_invoke: LLMInvocationFn | None = None,\n    on_error: ErrorHandlerFn | None = None,\n    on_cache_hit: OnCacheActionFn | None = None,\n    on_cache_miss: OnCacheActionFn | None = None,",
        "detail": "graphrag.llm.openai.factories",
        "documentation": {}
    },
    {
        "label": "JsonParsingLLM",
        "kind": 6,
        "importPath": "graphrag.llm.openai.json_parsing_llm",
        "description": "graphrag.llm.openai.json_parsing_llm",
        "peekOfCode": "class JsonParsingLLM(LLM[CompletionInput, CompletionOutput]):\n    \"\"\"An OpenAI History-Tracking LLM.\"\"\"\n    _delegate: CompletionLLM\n    def __init__(self, delegate: CompletionLLM):\n        self._delegate = delegate\n    async def __call__(\n        self,\n        input: CompletionInput,\n        **kwargs: Unpack[LLMInput],\n    ) -> LLMOutput[CompletionOutput]:",
        "detail": "graphrag.llm.openai.json_parsing_llm",
        "documentation": {}
    },
    {
        "label": "OpenAIChatLLM",
        "kind": 6,
        "importPath": "graphrag.llm.openai.openai_chat_llm",
        "description": "graphrag.llm.openai.openai_chat_llm",
        "peekOfCode": "class OpenAIChatLLM(BaseLLM[CompletionInput, CompletionOutput]):\n    \"\"\"A Chat-based LLM.\"\"\"\n    _client: OpenAIClientTypes\n    _configuration: OpenAIConfiguration\n    def __init__(self, client: OpenAIClientTypes, configuration: OpenAIConfiguration):\n        self.client = client\n        self.configuration = configuration\n    async def _execute_llm(\n        self, input: CompletionInput, **kwargs: Unpack[LLMInput]\n    ) -> CompletionOutput | None:",
        "detail": "graphrag.llm.openai.openai_chat_llm",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.llm.openai.openai_chat_llm",
        "description": "graphrag.llm.openai.openai_chat_llm",
        "peekOfCode": "log = logging.getLogger(__name__)\n_MAX_GENERATION_RETRIES = 3\nFAILED_TO_CREATE_JSON_ERROR = \"Failed to generate valid JSON output\"\nclass OpenAIChatLLM(BaseLLM[CompletionInput, CompletionOutput]):\n    \"\"\"A Chat-based LLM.\"\"\"\n    _client: OpenAIClientTypes\n    _configuration: OpenAIConfiguration\n    def __init__(self, client: OpenAIClientTypes, configuration: OpenAIConfiguration):\n        self.client = client\n        self.configuration = configuration",
        "detail": "graphrag.llm.openai.openai_chat_llm",
        "documentation": {}
    },
    {
        "label": "_MAX_GENERATION_RETRIES",
        "kind": 5,
        "importPath": "graphrag.llm.openai.openai_chat_llm",
        "description": "graphrag.llm.openai.openai_chat_llm",
        "peekOfCode": "_MAX_GENERATION_RETRIES = 3\nFAILED_TO_CREATE_JSON_ERROR = \"Failed to generate valid JSON output\"\nclass OpenAIChatLLM(BaseLLM[CompletionInput, CompletionOutput]):\n    \"\"\"A Chat-based LLM.\"\"\"\n    _client: OpenAIClientTypes\n    _configuration: OpenAIConfiguration\n    def __init__(self, client: OpenAIClientTypes, configuration: OpenAIConfiguration):\n        self.client = client\n        self.configuration = configuration\n    async def _execute_llm(",
        "detail": "graphrag.llm.openai.openai_chat_llm",
        "documentation": {}
    },
    {
        "label": "FAILED_TO_CREATE_JSON_ERROR",
        "kind": 5,
        "importPath": "graphrag.llm.openai.openai_chat_llm",
        "description": "graphrag.llm.openai.openai_chat_llm",
        "peekOfCode": "FAILED_TO_CREATE_JSON_ERROR = \"Failed to generate valid JSON output\"\nclass OpenAIChatLLM(BaseLLM[CompletionInput, CompletionOutput]):\n    \"\"\"A Chat-based LLM.\"\"\"\n    _client: OpenAIClientTypes\n    _configuration: OpenAIConfiguration\n    def __init__(self, client: OpenAIClientTypes, configuration: OpenAIConfiguration):\n        self.client = client\n        self.configuration = configuration\n    async def _execute_llm(\n        self, input: CompletionInput, **kwargs: Unpack[LLMInput]",
        "detail": "graphrag.llm.openai.openai_chat_llm",
        "documentation": {}
    },
    {
        "label": "OpenAICompletionLLM",
        "kind": 6,
        "importPath": "graphrag.llm.openai.openai_completion_llm",
        "description": "graphrag.llm.openai.openai_completion_llm",
        "peekOfCode": "class OpenAICompletionLLM(BaseLLM[CompletionInput, CompletionOutput]):\n    \"\"\"A text-completion based LLM.\"\"\"\n    _client: OpenAIClientTypes\n    _configuration: OpenAIConfiguration\n    def __init__(self, client: OpenAIClientTypes, configuration: OpenAIConfiguration):\n        self.client = client\n        self.configuration = configuration\n    async def _execute_llm(\n        self,\n        input: CompletionInput,",
        "detail": "graphrag.llm.openai.openai_completion_llm",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.llm.openai.openai_completion_llm",
        "description": "graphrag.llm.openai.openai_completion_llm",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass OpenAICompletionLLM(BaseLLM[CompletionInput, CompletionOutput]):\n    \"\"\"A text-completion based LLM.\"\"\"\n    _client: OpenAIClientTypes\n    _configuration: OpenAIConfiguration\n    def __init__(self, client: OpenAIClientTypes, configuration: OpenAIConfiguration):\n        self.client = client\n        self.configuration = configuration\n    async def _execute_llm(\n        self,",
        "detail": "graphrag.llm.openai.openai_completion_llm",
        "documentation": {}
    },
    {
        "label": "OpenAIConfiguration",
        "kind": 6,
        "importPath": "graphrag.llm.openai.openai_configuration",
        "description": "graphrag.llm.openai.openai_configuration",
        "peekOfCode": "class OpenAIConfiguration(Hashable, LLMConfig):\n    \"\"\"OpenAI Configuration class definition.\"\"\"\n    # Core Configuration\n    _api_key: str\n    _model: str\n    _api_base: str | None\n    _api_version: str | None\n    _cognitive_services_endpoint: str | None\n    _deployment_name: str | None\n    _organization: str | None",
        "detail": "graphrag.llm.openai.openai_configuration",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddingsLLM",
        "kind": 6,
        "importPath": "graphrag.llm.openai.openai_embeddings_llm",
        "description": "graphrag.llm.openai.openai_embeddings_llm",
        "peekOfCode": "class OpenAIEmbeddingsLLM(BaseLLM[EmbeddingInput, EmbeddingOutput]):\n    \"\"\"A text-embedding generator LLM.\"\"\"\n    _client: OpenAIClientTypes\n    _configuration: OpenAIConfiguration\n    def __init__(self, client: OpenAIClientTypes, configuration: OpenAIConfiguration):\n        self.client = client\n        self.configuration = configuration\n    async def _execute_llm(\n        self, input: EmbeddingInput, **kwargs: Unpack[LLMInput]\n    ) -> EmbeddingOutput | None:",
        "detail": "graphrag.llm.openai.openai_embeddings_llm",
        "documentation": {}
    },
    {
        "label": "OpenAIHistoryTrackingLLM",
        "kind": 6,
        "importPath": "graphrag.llm.openai.openai_history_tracking_llm",
        "description": "graphrag.llm.openai.openai_history_tracking_llm",
        "peekOfCode": "class OpenAIHistoryTrackingLLM(LLM[CompletionInput, CompletionOutput]):\n    \"\"\"An OpenAI History-Tracking LLM.\"\"\"\n    _delegate: CompletionLLM\n    def __init__(self, delegate: CompletionLLM):\n        self._delegate = delegate\n    async def __call__(\n        self,\n        input: CompletionInput,\n        **kwargs: Unpack[LLMInput],\n    ) -> LLMOutput[CompletionOutput]:",
        "detail": "graphrag.llm.openai.openai_history_tracking_llm",
        "documentation": {}
    },
    {
        "label": "OpenAITokenReplacingLLM",
        "kind": 6,
        "importPath": "graphrag.llm.openai.openai_token_replacing_llm",
        "description": "graphrag.llm.openai.openai_token_replacing_llm",
        "peekOfCode": "class OpenAITokenReplacingLLM(LLM[CompletionInput, CompletionOutput]):\n    \"\"\"An OpenAI History-Tracking LLM.\"\"\"\n    _delegate: CompletionLLM\n    def __init__(self, delegate: CompletionLLM):\n        self._delegate = delegate\n    async def __call__(\n        self,\n        input: CompletionInput,\n        **kwargs: Unpack[LLMInput],\n    ) -> LLMOutput[CompletionOutput]:",
        "detail": "graphrag.llm.openai.openai_token_replacing_llm",
        "documentation": {}
    },
    {
        "label": "OpenAIClientTypes",
        "kind": 5,
        "importPath": "graphrag.llm.openai.types",
        "description": "graphrag.llm.openai.types",
        "peekOfCode": "OpenAIClientTypes = AsyncOpenAI | AsyncAzureOpenAI",
        "detail": "graphrag.llm.openai.types",
        "documentation": {}
    },
    {
        "label": "get_token_counter",
        "kind": 2,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "def get_token_counter(config: OpenAIConfiguration) -> Callable[[str], int]:\n    \"\"\"Get a function that counts the number of tokens in a string.\"\"\"\n    model = config.encoding_model or \"cl100k_base\"\n    enc = _encoders.get(model)\n    if enc is None:\n        enc = tiktoken.get_encoding(model)\n        _encoders[model] = enc\n    return lambda s: len(enc.encode(s))\ndef perform_variable_replacements(\n    input: str, history: list[dict], variables: dict | None",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "perform_variable_replacements",
        "kind": 2,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "def perform_variable_replacements(\n    input: str, history: list[dict], variables: dict | None\n) -> str:\n    \"\"\"Perform variable replacements on the input string and in a chat log.\"\"\"\n    result = input\n    def replace_all(input: str) -> str:\n        result = input\n        if variables:\n            for entry in variables:\n                result = result.replace(f\"{{{entry}}}\", variables[entry])",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "get_completion_cache_args",
        "kind": 2,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "def get_completion_cache_args(configuration: OpenAIConfiguration) -> dict:\n    \"\"\"Get the cache arguments for a completion LLM.\"\"\"\n    return {\n        \"model\": configuration.model,\n        \"temperature\": configuration.temperature,\n        \"frequency_penalty\": configuration.frequency_penalty,\n        \"presence_penalty\": configuration.presence_penalty,\n        \"top_p\": configuration.top_p,\n        \"max_tokens\": configuration.max_tokens,\n        \"n\": configuration.n,",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "get_completion_llm_args",
        "kind": 2,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "def get_completion_llm_args(\n    parameters: dict | None, configuration: OpenAIConfiguration\n) -> dict:\n    \"\"\"Get the arguments for a completion LLM.\"\"\"\n    return {\n        **get_completion_cache_args(configuration),\n        **(parameters or {}),\n    }\ndef try_parse_json_object(input: str) -> tuple[str, dict]:\n    \"\"\"JSON cleaning and formatting utilities.\"\"\"",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "try_parse_json_object",
        "kind": 2,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "def try_parse_json_object(input: str) -> tuple[str, dict]:\n    \"\"\"JSON cleaning and formatting utilities.\"\"\"\n    # Sometimes, the LLM returns a json string with some extra description, this function will clean it up.\n    result = None\n    try:\n        # Try parse first\n        result = json.loads(input)\n    except json.JSONDecodeError:\n        log.info(\"Warning: Error decoding faulty json, attempting repair\")\n    if result:",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "get_sleep_time_from_error",
        "kind": 2,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "def get_sleep_time_from_error(e: Any) -> float:\n    \"\"\"Extract the sleep time value from a RateLimitError. This is usually only available in Azure.\"\"\"\n    sleep_time = 0.0\n    if isinstance(e, RateLimitError) and _please_retry_after in str(e):\n        # could be second or seconds\n        sleep_time = int(str(e).split(_please_retry_after)[1].split(\" second\")[0])\n    return sleep_time\n_please_retry_after = \"Please retry after \"",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ENCODING",
        "kind": 5,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "DEFAULT_ENCODING = \"cl100k_base\"\n_encoders: dict[str, tiktoken.Encoding] = {}\nRETRYABLE_ERRORS: list[type[Exception]] = [\n    RateLimitError,\n    APIConnectionError,\n    InternalServerError,\n]\nRATE_LIMIT_ERRORS: list[type[Exception]] = [RateLimitError]\nlog = logging.getLogger(__name__)\ndef get_token_counter(config: OpenAIConfiguration) -> Callable[[str], int]:",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef get_token_counter(config: OpenAIConfiguration) -> Callable[[str], int]:\n    \"\"\"Get a function that counts the number of tokens in a string.\"\"\"\n    model = config.encoding_model or \"cl100k_base\"\n    enc = _encoders.get(model)\n    if enc is None:\n        enc = tiktoken.get_encoding(model)\n        _encoders[model] = enc\n    return lambda s: len(enc.encode(s))\ndef perform_variable_replacements(",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "_please_retry_after",
        "kind": 5,
        "importPath": "graphrag.llm.openai.utils",
        "description": "graphrag.llm.openai.utils",
        "peekOfCode": "_please_retry_after = \"Please retry after \"",
        "detail": "graphrag.llm.openai.utils",
        "documentation": {}
    },
    {
        "label": "LLM",
        "kind": 6,
        "importPath": "graphrag.llm.types.llm",
        "description": "graphrag.llm.types.llm",
        "peekOfCode": "class LLM(Protocol, Generic[TIn, TOut]):\n    \"\"\"LLM Protocol definition.\"\"\"\n    async def __call__(\n        self,\n        input: TIn,\n        **kwargs: Unpack[LLMInput],\n    ) -> LLMOutput[TOut]:\n        \"\"\"Invoke the LLM, treating the LLM as a function.\"\"\"\n        ...",
        "detail": "graphrag.llm.types.llm",
        "documentation": {}
    },
    {
        "label": "TIn",
        "kind": 5,
        "importPath": "graphrag.llm.types.llm",
        "description": "graphrag.llm.types.llm",
        "peekOfCode": "TIn = TypeVar(\"TIn\", contravariant=True)\nTOut = TypeVar(\"TOut\")\nclass LLM(Protocol, Generic[TIn, TOut]):\n    \"\"\"LLM Protocol definition.\"\"\"\n    async def __call__(\n        self,\n        input: TIn,\n        **kwargs: Unpack[LLMInput],\n    ) -> LLMOutput[TOut]:\n        \"\"\"Invoke the LLM, treating the LLM as a function.\"\"\"",
        "detail": "graphrag.llm.types.llm",
        "documentation": {}
    },
    {
        "label": "TOut",
        "kind": 5,
        "importPath": "graphrag.llm.types.llm",
        "description": "graphrag.llm.types.llm",
        "peekOfCode": "TOut = TypeVar(\"TOut\")\nclass LLM(Protocol, Generic[TIn, TOut]):\n    \"\"\"LLM Protocol definition.\"\"\"\n    async def __call__(\n        self,\n        input: TIn,\n        **kwargs: Unpack[LLMInput],\n    ) -> LLMOutput[TOut]:\n        \"\"\"Invoke the LLM, treating the LLM as a function.\"\"\"\n        ...",
        "detail": "graphrag.llm.types.llm",
        "documentation": {}
    },
    {
        "label": "LLMCache",
        "kind": 6,
        "importPath": "graphrag.llm.types.llm_cache",
        "description": "graphrag.llm.types.llm_cache",
        "peekOfCode": "class LLMCache(Protocol):\n    \"\"\"LLM Cache interface.\"\"\"\n    async def has(self, key: str) -> bool:\n        \"\"\"Check if the cache has a value.\"\"\"\n        ...\n    async def get(self, key: str) -> Any | None:\n        \"\"\"Retrieve a value from the cache.\"\"\"\n        ...\n    async def set(self, key: str, value: Any, debug_data: dict | None = None) -> None:\n        \"\"\"Write a value into the cache.\"\"\"",
        "detail": "graphrag.llm.types.llm_cache",
        "documentation": {}
    },
    {
        "label": "ErrorHandlerFn",
        "kind": 5,
        "importPath": "graphrag.llm.types.llm_callbacks",
        "description": "graphrag.llm.types.llm_callbacks",
        "peekOfCode": "ErrorHandlerFn = Callable[[BaseException | None, str | None, dict | None], None]\n\"\"\"Error handler function type definition.\"\"\"\nLLMInvocationFn = Callable[[LLMInvocationResult], None]\n\"\"\"Handler for LLM invocation results\"\"\"\nOnCacheActionFn = Callable[[str, str | None], None]\n\"\"\"Handler for cache hits\"\"\"\nIsResponseValidFn = Callable[[dict], bool]\n\"\"\"A function that checks if an LLM response is valid.\"\"\"",
        "detail": "graphrag.llm.types.llm_callbacks",
        "documentation": {}
    },
    {
        "label": "LLMInvocationFn",
        "kind": 5,
        "importPath": "graphrag.llm.types.llm_callbacks",
        "description": "graphrag.llm.types.llm_callbacks",
        "peekOfCode": "LLMInvocationFn = Callable[[LLMInvocationResult], None]\n\"\"\"Handler for LLM invocation results\"\"\"\nOnCacheActionFn = Callable[[str, str | None], None]\n\"\"\"Handler for cache hits\"\"\"\nIsResponseValidFn = Callable[[dict], bool]\n\"\"\"A function that checks if an LLM response is valid.\"\"\"",
        "detail": "graphrag.llm.types.llm_callbacks",
        "documentation": {}
    },
    {
        "label": "OnCacheActionFn",
        "kind": 5,
        "importPath": "graphrag.llm.types.llm_callbacks",
        "description": "graphrag.llm.types.llm_callbacks",
        "peekOfCode": "OnCacheActionFn = Callable[[str, str | None], None]\n\"\"\"Handler for cache hits\"\"\"\nIsResponseValidFn = Callable[[dict], bool]\n\"\"\"A function that checks if an LLM response is valid.\"\"\"",
        "detail": "graphrag.llm.types.llm_callbacks",
        "documentation": {}
    },
    {
        "label": "IsResponseValidFn",
        "kind": 5,
        "importPath": "graphrag.llm.types.llm_callbacks",
        "description": "graphrag.llm.types.llm_callbacks",
        "peekOfCode": "IsResponseValidFn = Callable[[dict], bool]\n\"\"\"A function that checks if an LLM response is valid.\"\"\"",
        "detail": "graphrag.llm.types.llm_callbacks",
        "documentation": {}
    },
    {
        "label": "LLMConfig",
        "kind": 6,
        "importPath": "graphrag.llm.types.llm_config",
        "description": "graphrag.llm.types.llm_config",
        "peekOfCode": "class LLMConfig(Protocol):\n    \"\"\"LLM Configuration Protocol definition.\"\"\"\n    @property\n    def max_retries(self) -> int | None:\n        \"\"\"Get the maximum number of retries.\"\"\"\n        ...\n    @property\n    def max_retry_wait(self) -> float | None:\n        \"\"\"Get the maximum retry wait time.\"\"\"\n        ...",
        "detail": "graphrag.llm.types.llm_config",
        "documentation": {}
    },
    {
        "label": "LLMInvocationResult",
        "kind": 6,
        "importPath": "graphrag.llm.types.llm_invocation_result",
        "description": "graphrag.llm.types.llm_invocation_result",
        "peekOfCode": "class LLMInvocationResult(Generic[T]):\n    \"\"\"The result of an LLM invocation.\"\"\"\n    result: T | None\n    \"\"\"The result of the LLM invocation.\"\"\"\n    name: str\n    \"\"\"The operation name of the result\"\"\"\n    num_retries: int\n    \"\"\"The number of retries the invocation took.\"\"\"\n    total_time: float\n    \"\"\"The total time of the LLM invocation.\"\"\"",
        "detail": "graphrag.llm.types.llm_invocation_result",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "graphrag.llm.types.llm_invocation_result",
        "description": "graphrag.llm.types.llm_invocation_result",
        "peekOfCode": "T = TypeVar(\"T\")\n@dataclass\nclass LLMInvocationResult(Generic[T]):\n    \"\"\"The result of an LLM invocation.\"\"\"\n    result: T | None\n    \"\"\"The result of the LLM invocation.\"\"\"\n    name: str\n    \"\"\"The operation name of the result\"\"\"\n    num_retries: int\n    \"\"\"The number of retries the invocation took.\"\"\"",
        "detail": "graphrag.llm.types.llm_invocation_result",
        "documentation": {}
    },
    {
        "label": "LLMInput",
        "kind": 6,
        "importPath": "graphrag.llm.types.llm_io",
        "description": "graphrag.llm.types.llm_io",
        "peekOfCode": "class LLMInput(TypedDict):\n    \"\"\"The input of an LLM invocation.\"\"\"\n    name: NotRequired[str]\n    \"\"\"The name of the LLM invocation, if available.\"\"\"\n    json: NotRequired[bool]\n    \"\"\"If true, will attempt to elicit JSON from the LLM. Parsed JSON will be returned in the `json_output` field.\"\"\"\n    is_response_valid: NotRequired[IsResponseValidFn]\n    \"\"\"A function that checks if an LLM response is valid. Only valid if `json=True`.\"\"\"\n    variables: NotRequired[dict]\n    \"\"\"The variable replacements to use in the prompt.\"\"\"",
        "detail": "graphrag.llm.types.llm_io",
        "documentation": {}
    },
    {
        "label": "LLMOutput",
        "kind": 6,
        "importPath": "graphrag.llm.types.llm_io",
        "description": "graphrag.llm.types.llm_io",
        "peekOfCode": "class LLMOutput(Generic[T]):\n    \"\"\"The output of an LLM invocation.\"\"\"\n    output: T | None\n    \"\"\"The output of the LLM invocation.\"\"\"\n    json: dict | None = field(default=None)\n    \"\"\"The JSON output from the LLM, if available.\"\"\"\n    history: list[dict] | None = field(default=None)\n    \"\"\"The history of the LLM invocation, if available (e.g. chat mode)\"\"\"",
        "detail": "graphrag.llm.types.llm_io",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "graphrag.llm.types.llm_io",
        "description": "graphrag.llm.types.llm_io",
        "peekOfCode": "T = TypeVar(\"T\")\n@dataclass\nclass LLMOutput(Generic[T]):\n    \"\"\"The output of an LLM invocation.\"\"\"\n    output: T | None\n    \"\"\"The output of the LLM invocation.\"\"\"\n    json: dict | None = field(default=None)\n    \"\"\"The JSON output from the LLM, if available.\"\"\"\n    history: list[dict] | None = field(default=None)\n    \"\"\"The history of the LLM invocation, if available (e.g. chat mode)\"\"\"",
        "detail": "graphrag.llm.types.llm_io",
        "documentation": {}
    },
    {
        "label": "RetriesExhaustedError",
        "kind": 6,
        "importPath": "graphrag.llm.errors",
        "description": "graphrag.llm.errors",
        "peekOfCode": "class RetriesExhaustedError(RuntimeError):\n    \"\"\"Retries exhausted error.\"\"\"\n    def __init__(self, name: str, num_retries: int) -> None:\n        \"\"\"Init method definition.\"\"\"\n        super().__init__(f\"Operation '{name}' failed - {num_retries} retries exhausted\")",
        "detail": "graphrag.llm.errors",
        "documentation": {}
    },
    {
        "label": "ConsoleReporter",
        "kind": 6,
        "importPath": "graphrag.logging.console",
        "description": "graphrag.logging.console",
        "peekOfCode": "class ConsoleReporter(StatusLogger):\n    \"\"\"A reporter that writes to a console.\"\"\"\n    def error(self, message: str, details: dict[str, Any] | None = None):\n        \"\"\"Report an error.\"\"\"\n        print(message, details)  # noqa T201\n    def warning(self, message: str, details: dict[str, Any] | None = None):\n        \"\"\"Report a warning.\"\"\"\n        _print_warning(message)\n    def log(self, message: str, details: dict[str, Any] | None = None):\n        \"\"\"Report a log.\"\"\"",
        "detail": "graphrag.logging.console",
        "documentation": {}
    },
    {
        "label": "create_progress_reporter",
        "kind": 2,
        "importPath": "graphrag.logging.factories",
        "description": "graphrag.logging.factories",
        "peekOfCode": "def create_progress_reporter(\n    reporter_type: ReporterType = ReporterType.NONE,\n) -> ProgressReporter:\n    \"\"\"Load a progress reporter.\n    Parameters\n    ----------\n    reporter_type : {\"rich\", \"print\", \"none\"}, default=rich\n        The type of progress reporter to load.\n    Returns\n    -------",
        "detail": "graphrag.logging.factories",
        "documentation": {}
    },
    {
        "label": "NullProgressReporter",
        "kind": 6,
        "importPath": "graphrag.logging.null_progress",
        "description": "graphrag.logging.null_progress",
        "peekOfCode": "class NullProgressReporter(ProgressReporter):\n    \"\"\"A progress reporter that does nothing.\"\"\"\n    def __call__(self, update: Progress) -> None:\n        \"\"\"Update progress.\"\"\"\n    def dispose(self) -> None:\n        \"\"\"Dispose of the progress reporter.\"\"\"\n    def child(self, prefix: str, transient: bool = True) -> ProgressReporter:\n        \"\"\"Create a child progress bar.\"\"\"\n        return self\n    def force_refresh(self) -> None:",
        "detail": "graphrag.logging.null_progress",
        "documentation": {}
    },
    {
        "label": "PrintProgressReporter",
        "kind": 6,
        "importPath": "graphrag.logging.print_progress",
        "description": "graphrag.logging.print_progress",
        "peekOfCode": "class PrintProgressReporter(ProgressReporter):\n    \"\"\"A progress reporter that does nothing.\"\"\"\n    prefix: str\n    def __init__(self, prefix: str):\n        \"\"\"Create a new progress reporter.\"\"\"\n        self.prefix = prefix\n        print(f\"\\n{self.prefix}\", end=\"\")  # noqa T201\n    def __call__(self, update: Progress) -> None:\n        \"\"\"Update progress.\"\"\"\n        print(\".\", end=\"\")  # noqa T201",
        "detail": "graphrag.logging.print_progress",
        "documentation": {}
    },
    {
        "label": "RichProgressReporter",
        "kind": 6,
        "importPath": "graphrag.logging.rich_progress",
        "description": "graphrag.logging.rich_progress",
        "peekOfCode": "class RichProgressReporter(ProgressReporter):\n    \"\"\"A rich-based progress reporter for CLI use.\"\"\"\n    _console: Console\n    _group: Group\n    _tree: Tree\n    _live: Live\n    _task: TaskID | None = None\n    _prefix: str\n    _transient: bool\n    _disposing: bool = False",
        "detail": "graphrag.logging.rich_progress",
        "documentation": {}
    },
    {
        "label": "ReporterType",
        "kind": 6,
        "importPath": "graphrag.logging.types",
        "description": "graphrag.logging.types",
        "peekOfCode": "class ReporterType(Enum):\n    \"\"\"The type of reporter to use.\"\"\"\n    RICH = \"rich\"\n    PRINT = \"print\"\n    NONE = \"none\"\n    def __str__(self):\n        \"\"\"Return the string representation of the enum value.\"\"\"\n        return self.value\nclass StatusLogger(ABC):\n    \"\"\"Provides a way to report status updates from the pipeline.\"\"\"",
        "detail": "graphrag.logging.types",
        "documentation": {}
    },
    {
        "label": "StatusLogger",
        "kind": 6,
        "importPath": "graphrag.logging.types",
        "description": "graphrag.logging.types",
        "peekOfCode": "class StatusLogger(ABC):\n    \"\"\"Provides a way to report status updates from the pipeline.\"\"\"\n    @abstractmethod\n    def error(self, message: str, details: dict[str, Any] | None = None):\n        \"\"\"Report an error.\"\"\"\n    @abstractmethod\n    def warning(self, message: str, details: dict[str, Any] | None = None):\n        \"\"\"Report a warning.\"\"\"\n    @abstractmethod\n    def log(self, message: str, details: dict[str, Any] | None = None):",
        "detail": "graphrag.logging.types",
        "documentation": {}
    },
    {
        "label": "ProgressReporter",
        "kind": 6,
        "importPath": "graphrag.logging.types",
        "description": "graphrag.logging.types",
        "peekOfCode": "class ProgressReporter(ABC):\n    \"\"\"\n    Abstract base class for progress reporters.\n    This is used to report workflow processing progress via mechanisms like progress-bars.\n    \"\"\"\n    @abstractmethod\n    def __call__(self, update: Progress):\n        \"\"\"Update progress.\"\"\"\n    @abstractmethod\n    def dispose(self):",
        "detail": "graphrag.logging.types",
        "documentation": {}
    },
    {
        "label": "Community",
        "kind": 6,
        "importPath": "graphrag.model.community",
        "description": "graphrag.model.community",
        "peekOfCode": "class Community(Named):\n    \"\"\"A protocol for a community in the system.\"\"\"\n    level: str = \"\"\n    \"\"\"Community level.\"\"\"\n    entity_ids: list[str] | None = None\n    \"\"\"List of entity IDs related to the community (optional).\"\"\"\n    relationship_ids: list[str] | None = None\n    \"\"\"List of relationship IDs related to the community (optional).\"\"\"\n    covariate_ids: dict[str, list[str]] | None = None\n    \"\"\"Dictionary of different types of covariates related to the community (optional), e.g. claims\"\"\"",
        "detail": "graphrag.model.community",
        "documentation": {}
    },
    {
        "label": "CommunityReport",
        "kind": 6,
        "importPath": "graphrag.model.community_report",
        "description": "graphrag.model.community_report",
        "peekOfCode": "class CommunityReport(Named):\n    \"\"\"Defines an LLM-generated summary report of a community.\"\"\"\n    community_id: str\n    \"\"\"The ID of the community this report is associated with.\"\"\"\n    summary: str = \"\"\n    \"\"\"Summary of the report.\"\"\"\n    full_content: str = \"\"\n    \"\"\"Full content of the report.\"\"\"\n    rank: float | None = 1.0\n    \"\"\"Rank of the report, used for sorting (optional). Higher means more important\"\"\"",
        "detail": "graphrag.model.community_report",
        "documentation": {}
    },
    {
        "label": "Covariate",
        "kind": 6,
        "importPath": "graphrag.model.covariate",
        "description": "graphrag.model.covariate",
        "peekOfCode": "class Covariate(Identified):\n    \"\"\"\n    A protocol for a covariate in the system.\n    Covariates are metadata associated with a subject, e.g. entity claims.\n    Each subject (e.g. entity) may be associated with multiple types of covariates.\n    \"\"\"\n    subject_id: str\n    \"\"\"The subject id.\"\"\"\n    subject_type: str = \"entity\"\n    \"\"\"The subject type.\"\"\"",
        "detail": "graphrag.model.covariate",
        "documentation": {}
    },
    {
        "label": "Document",
        "kind": 6,
        "importPath": "graphrag.model.document",
        "description": "graphrag.model.document",
        "peekOfCode": "class Document(Named):\n    \"\"\"A protocol for a document in the system.\"\"\"\n    type: str = \"text\"\n    \"\"\"Type of the document.\"\"\"\n    text_unit_ids: list[str] = field(default_factory=list)\n    \"\"\"list of text units in the document.\"\"\"\n    raw_content: str = \"\"\n    \"\"\"The raw text content of the document.\"\"\"\n    summary: str | None = None\n    \"\"\"Summary of the document (optional).\"\"\"",
        "detail": "graphrag.model.document",
        "documentation": {}
    },
    {
        "label": "Entity",
        "kind": 6,
        "importPath": "graphrag.model.entity",
        "description": "graphrag.model.entity",
        "peekOfCode": "class Entity(Named):\n    \"\"\"A protocol for an entity in the system.\"\"\"\n    type: str | None = None\n    \"\"\"Type of the entity (can be any string, optional).\"\"\"\n    description: str | None = None\n    \"\"\"Description of the entity (optional).\"\"\"\n    description_embedding: list[float] | None = None\n    \"\"\"The semantic (i.e. text) embedding of the entity (optional).\"\"\"\n    name_embedding: list[float] | None = None\n    \"\"\"The semantic (i.e. text) embedding of the entity (optional).\"\"\"",
        "detail": "graphrag.model.entity",
        "documentation": {}
    },
    {
        "label": "Identified",
        "kind": 6,
        "importPath": "graphrag.model.identified",
        "description": "graphrag.model.identified",
        "peekOfCode": "class Identified:\n    \"\"\"A protocol for an item with an ID.\"\"\"\n    id: str\n    \"\"\"The ID of the item.\"\"\"\n    short_id: str | None\n    \"\"\"Human readable ID used to refer to this community in prompts or texts displayed to users, such as in a report text (optional).\"\"\"",
        "detail": "graphrag.model.identified",
        "documentation": {}
    },
    {
        "label": "Named",
        "kind": 6,
        "importPath": "graphrag.model.named",
        "description": "graphrag.model.named",
        "peekOfCode": "class Named(Identified):\n    \"\"\"A protocol for an item with a name/title.\"\"\"\n    title: str\n    \"\"\"The name/title of the item.\"\"\"",
        "detail": "graphrag.model.named",
        "documentation": {}
    },
    {
        "label": "Relationship",
        "kind": 6,
        "importPath": "graphrag.model.relationship",
        "description": "graphrag.model.relationship",
        "peekOfCode": "class Relationship(Identified):\n    \"\"\"A relationship between two entities. This is a generic relationship, and can be used to represent any type of relationship between any two entities.\"\"\"\n    source: str\n    \"\"\"The source entity name.\"\"\"\n    target: str\n    \"\"\"The target entity name.\"\"\"\n    weight: float | None = 1.0\n    \"\"\"The edge weight.\"\"\"\n    description: str | None = None\n    \"\"\"A description of the relationship (optional).\"\"\"",
        "detail": "graphrag.model.relationship",
        "documentation": {}
    },
    {
        "label": "TextUnit",
        "kind": 6,
        "importPath": "graphrag.model.text_unit",
        "description": "graphrag.model.text_unit",
        "peekOfCode": "class TextUnit(Identified):\n    \"\"\"A protocol for a TextUnit item in a Document database.\"\"\"\n    text: str\n    \"\"\"The text of the unit.\"\"\"\n    text_embedding: list[float] | None = None\n    \"\"\"The text embedding for the text unit (optional).\"\"\"\n    entity_ids: list[str] | None = None\n    \"\"\"List of entity IDs related to the text unit (optional).\"\"\"\n    relationship_ids: list[str] | None = None\n    \"\"\"List of relationship IDs related to the text unit (optional).\"\"\"",
        "detail": "graphrag.model.text_unit",
        "documentation": {}
    },
    {
        "label": "TextEmbedder",
        "kind": 5,
        "importPath": "graphrag.model.types",
        "description": "graphrag.model.types",
        "peekOfCode": "TextEmbedder = Callable[[str], list[float]]",
        "detail": "graphrag.model.types",
        "documentation": {}
    },
    {
        "label": "create_community_summarization_prompt",
        "kind": 2,
        "importPath": "graphrag.prompt_tune.generator.community_report_summarization",
        "description": "graphrag.prompt_tune.generator.community_report_summarization",
        "peekOfCode": "def create_community_summarization_prompt(\n    persona: str,\n    role: str,\n    report_rating_description: str,\n    language: str,\n    output_path: Path | None = None,\n) -> str:\n    \"\"\"Create a prompt for community summarization. If output_path is provided, write the prompt to a file.\n    Parameters\n    ----------",
        "detail": "graphrag.prompt_tune.generator.community_report_summarization",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_SUMMARIZATION_FILENAME",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.generator.community_report_summarization",
        "description": "graphrag.prompt_tune.generator.community_report_summarization",
        "peekOfCode": "COMMUNITY_SUMMARIZATION_FILENAME = \"community_report.txt\"\ndef create_community_summarization_prompt(\n    persona: str,\n    role: str,\n    report_rating_description: str,\n    language: str,\n    output_path: Path | None = None,\n) -> str:\n    \"\"\"Create a prompt for community summarization. If output_path is provided, write the prompt to a file.\n    Parameters",
        "detail": "graphrag.prompt_tune.generator.community_report_summarization",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TASK",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.generator.defaults",
        "description": "graphrag.prompt_tune.generator.defaults",
        "peekOfCode": "DEFAULT_TASK = \"\"\"\nIdentify the relations and structure of the community of interest, specifically within the {domain} domain.\n\"\"\"\nMAX_TOKEN_COUNT = 2000",
        "detail": "graphrag.prompt_tune.generator.defaults",
        "documentation": {}
    },
    {
        "label": "MAX_TOKEN_COUNT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.generator.defaults",
        "description": "graphrag.prompt_tune.generator.defaults",
        "peekOfCode": "MAX_TOKEN_COUNT = 2000",
        "detail": "graphrag.prompt_tune.generator.defaults",
        "documentation": {}
    },
    {
        "label": "create_entity_extraction_prompt",
        "kind": 2,
        "importPath": "graphrag.prompt_tune.generator.entity_extraction_prompt",
        "description": "graphrag.prompt_tune.generator.entity_extraction_prompt",
        "peekOfCode": "def create_entity_extraction_prompt(\n    entity_types: str | list[str] | None,\n    docs: list[str],\n    examples: list[str],\n    language: str,\n    max_token_count: int,\n    encoding_model: str = defs.ENCODING_MODEL,\n    json_mode: bool = False,\n    output_path: Path | None = None,\n    min_examples_required: int = 2,",
        "detail": "graphrag.prompt_tune.generator.entity_extraction_prompt",
        "documentation": {}
    },
    {
        "label": "ENTITY_EXTRACTION_FILENAME",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.generator.entity_extraction_prompt",
        "description": "graphrag.prompt_tune.generator.entity_extraction_prompt",
        "peekOfCode": "ENTITY_EXTRACTION_FILENAME = \"entity_extraction.txt\"\ndef create_entity_extraction_prompt(\n    entity_types: str | list[str] | None,\n    docs: list[str],\n    examples: list[str],\n    language: str,\n    max_token_count: int,\n    encoding_model: str = defs.ENCODING_MODEL,\n    json_mode: bool = False,\n    output_path: Path | None = None,",
        "detail": "graphrag.prompt_tune.generator.entity_extraction_prompt",
        "documentation": {}
    },
    {
        "label": "MAX_EXAMPLES",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.generator.entity_relationship",
        "description": "graphrag.prompt_tune.generator.entity_relationship",
        "peekOfCode": "MAX_EXAMPLES = 5\nasync def generate_entity_relationship_examples(\n    llm: CompletionLLM,\n    persona: str,\n    entity_types: str | list[str] | None,\n    docs: str | list[str],\n    language: str,\n    json_mode: bool = False,\n) -> list[str]:\n    \"\"\"Generate a list of entity/relationships examples for use in generating an entity configuration.",
        "detail": "graphrag.prompt_tune.generator.entity_relationship",
        "documentation": {}
    },
    {
        "label": "create_entity_summarization_prompt",
        "kind": 2,
        "importPath": "graphrag.prompt_tune.generator.entity_summarization_prompt",
        "description": "graphrag.prompt_tune.generator.entity_summarization_prompt",
        "peekOfCode": "def create_entity_summarization_prompt(\n    persona: str,\n    language: str,\n    output_path: Path | None = None,\n) -> str:\n    \"\"\"\n    Create a prompt for entity summarization.\n    Parameters\n    ----------\n    - persona (str): The persona to use for the entity summarization prompt",
        "detail": "graphrag.prompt_tune.generator.entity_summarization_prompt",
        "documentation": {}
    },
    {
        "label": "ENTITY_SUMMARIZATION_FILENAME",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.generator.entity_summarization_prompt",
        "description": "graphrag.prompt_tune.generator.entity_summarization_prompt",
        "peekOfCode": "ENTITY_SUMMARIZATION_FILENAME = \"summarize_descriptions.txt\"\ndef create_entity_summarization_prompt(\n    persona: str,\n    language: str,\n    output_path: Path | None = None,\n) -> str:\n    \"\"\"\n    Create a prompt for entity summarization.\n    Parameters\n    ----------",
        "detail": "graphrag.prompt_tune.generator.entity_summarization_prompt",
        "documentation": {}
    },
    {
        "label": "MIN_CHUNK_OVERLAP",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.loader.input",
        "description": "graphrag.prompt_tune.loader.input",
        "peekOfCode": "MIN_CHUNK_OVERLAP = 0\nMIN_CHUNK_SIZE = 200\nN_SUBSET_MAX = 300\nK = 15\nasync def _embed_chunks(\n    text_chunks: pd.DataFrame,\n    embedding_llm: EmbeddingLLM,\n    n_subset_max: int = N_SUBSET_MAX,\n) -> tuple[pd.DataFrame, np.ndarray]:\n    \"\"\"Convert text chunks into dense text embeddings.\"\"\"",
        "detail": "graphrag.prompt_tune.loader.input",
        "documentation": {}
    },
    {
        "label": "MIN_CHUNK_SIZE",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.loader.input",
        "description": "graphrag.prompt_tune.loader.input",
        "peekOfCode": "MIN_CHUNK_SIZE = 200\nN_SUBSET_MAX = 300\nK = 15\nasync def _embed_chunks(\n    text_chunks: pd.DataFrame,\n    embedding_llm: EmbeddingLLM,\n    n_subset_max: int = N_SUBSET_MAX,\n) -> tuple[pd.DataFrame, np.ndarray]:\n    \"\"\"Convert text chunks into dense text embeddings.\"\"\"\n    sampled_text_chunks = text_chunks.sample(n=min(n_subset_max, len(text_chunks)))",
        "detail": "graphrag.prompt_tune.loader.input",
        "documentation": {}
    },
    {
        "label": "N_SUBSET_MAX",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.loader.input",
        "description": "graphrag.prompt_tune.loader.input",
        "peekOfCode": "N_SUBSET_MAX = 300\nK = 15\nasync def _embed_chunks(\n    text_chunks: pd.DataFrame,\n    embedding_llm: EmbeddingLLM,\n    n_subset_max: int = N_SUBSET_MAX,\n) -> tuple[pd.DataFrame, np.ndarray]:\n    \"\"\"Convert text chunks into dense text embeddings.\"\"\"\n    sampled_text_chunks = text_chunks.sample(n=min(n_subset_max, len(text_chunks)))\n    embeddings = await embedding_llm(sampled_text_chunks[\"chunks\"].tolist())",
        "detail": "graphrag.prompt_tune.loader.input",
        "documentation": {}
    },
    {
        "label": "K",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.loader.input",
        "description": "graphrag.prompt_tune.loader.input",
        "peekOfCode": "K = 15\nasync def _embed_chunks(\n    text_chunks: pd.DataFrame,\n    embedding_llm: EmbeddingLLM,\n    n_subset_max: int = N_SUBSET_MAX,\n) -> tuple[pd.DataFrame, np.ndarray]:\n    \"\"\"Convert text chunks into dense text embeddings.\"\"\"\n    sampled_text_chunks = text_chunks.sample(n=min(n_subset_max, len(text_chunks)))\n    embeddings = await embedding_llm(sampled_text_chunks[\"chunks\"].tolist())\n    return text_chunks, np.array(embeddings.output)",
        "detail": "graphrag.prompt_tune.loader.input",
        "documentation": {}
    },
    {
        "label": "GENERATE_REPORT_RATING_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.community_report_rating",
        "description": "graphrag.prompt_tune.prompt.community_report_rating",
        "peekOfCode": "GENERATE_REPORT_RATING_PROMPT = \"\"\"\nYou are a helpful agent tasked with rating the importance of a given text in the context of the provided domain and persona. Your goal is to provide a rating that reflects the relevance and significance of the text to the specified domain and persona. Use your expertise to evaluate the text based on the importance criteria and assign a float score between 0-10. Only respond with the text description of the importance criteria. Use the provided example data format to guide your response. Ignore the content of the example data and focus on the structure.\n######################\n-Examples-\n######################\n### Example 1\n# Domain\nPersonal and Family Communication\n# Persona\nYou are an expert in Social Network Analysis with a focus on the Personal and Family Communication domain. You are skilled at mapping and interpreting complex social networks, understanding the dynamics of interpersonal relationships, and identifying patterns of communication within communities. You are adept at helping people understand the structure and relations within their personal and family networks, providing insights into how information flows, how strong various connections are, and how these networks influence individual and group behavior.",
        "detail": "graphrag.prompt_tune.prompt.community_report_rating",
        "documentation": {}
    },
    {
        "label": "GENERATE_COMMUNITY_REPORTER_ROLE_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.community_reporter_role",
        "description": "graphrag.prompt_tune.prompt.community_reporter_role",
        "peekOfCode": "GENERATE_COMMUNITY_REPORTER_ROLE_PROMPT = \"\"\"\n{persona}\nGiven a sample text, help the user by creating a role definition that will be tasked with community analysis.\nTake a look at this example, determine its key parts, and using the domain provided and your expertise, create a new role definition for the provided inputs that follows the same pattern as the example.\nRemember, your output should look just like the provided example in structure and content.\nExample:\nA technologist reporter that is analyzing Kevin Scott's \"Behind the Tech Podcast\", given a list of entities\nthat belong to the community as well as their relationships and optional associated claims.\nThe report will be used to inform decision-makers about significant developments associated with the community and their potential impact.\nDomain: {domain}",
        "detail": "graphrag.prompt_tune.prompt.community_reporter_role",
        "documentation": {}
    },
    {
        "label": "GENERATE_DOMAIN_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.domain",
        "description": "graphrag.prompt_tune.prompt.domain",
        "peekOfCode": "GENERATE_DOMAIN_PROMPT = \"\"\"\nYou are an intelligent assistant that helps a human to analyze the information in a text document.\nGiven a sample text, help the user by assigning a descriptive domain that summarizes what the text is about.\nExample domains are: \"Social studies\", \"Algorithmic analysis\", \"Medical science\", among others.\nText: {input_text}\nDomain:\"\"\"",
        "detail": "graphrag.prompt_tune.prompt.domain",
        "documentation": {}
    },
    {
        "label": "ENTITY_RELATIONSHIPS_GENERATION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.entity_relationship",
        "description": "graphrag.prompt_tune.prompt.entity_relationship",
        "peekOfCode": "ENTITY_RELATIONSHIPS_GENERATION_PROMPT = \"\"\"\n-Goal-\nGiven a text document that is potentially relevant to this activity and a list of entity types, identify all entities of those types from the text and all relationships among the identified entities.\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: One of the following types: [{entity_types}]\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity as (\"entity\"{{tuple_delimiter}}<entity_name>{{tuple_delimiter}}<entity_type>{{tuple_delimiter}}<entity_description>)\n2. From the entities identified in step 1, identify all pairs of (source_entity, target_entity) that are *clearly related* to each other.",
        "detail": "graphrag.prompt_tune.prompt.entity_relationship",
        "documentation": {}
    },
    {
        "label": "ENTITY_RELATIONSHIPS_GENERATION_JSON_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.entity_relationship",
        "description": "graphrag.prompt_tune.prompt.entity_relationship",
        "peekOfCode": "ENTITY_RELATIONSHIPS_GENERATION_JSON_PROMPT = \"\"\"\n-Goal-\nGiven a text document that is potentially relevant to this activity and a list of entity types, identify all entities of those types from the text and all relationships among the identified entities.\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: One of the following types: [{entity_types}]\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity output as a JSON entry with the following format:\n{{\"name\": <entity name>, \"type\": <type>, \"description\": <entity description>}}",
        "detail": "graphrag.prompt_tune.prompt.entity_relationship",
        "documentation": {}
    },
    {
        "label": "UNTYPED_ENTITY_RELATIONSHIPS_GENERATION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.entity_relationship",
        "description": "graphrag.prompt_tune.prompt.entity_relationship",
        "peekOfCode": "UNTYPED_ENTITY_RELATIONSHIPS_GENERATION_PROMPT = \"\"\"\n-Goal-\nGiven a text document that is potentially relevant to this activity, first identify all entities needed from the text in order to capture the information and ideas in the text.\nNext, report all relationships among the identified entities.\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: Suggest several labels or categories for the entity. The categories should not be specific, but should be as general as possible.\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity as (\"entity\"{{tuple_delimiter}}<entity_name>{{tuple_delimiter}}<entity_type>{{tuple_delimiter}}<entity_description>)",
        "detail": "graphrag.prompt_tune.prompt.entity_relationship",
        "documentation": {}
    },
    {
        "label": "ENTITY_TYPE_GENERATION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.entity_types",
        "description": "graphrag.prompt_tune.prompt.entity_types",
        "peekOfCode": "ENTITY_TYPE_GENERATION_PROMPT = \"\"\"\nThe goal is to study the connections and relations between the entity types and their features in order to understand all available information from the text.\nThe user's task is to {task}.\nAs part of the analysis, you want to identify the entity types present in the following text.\nThe entity types must be relevant to the user task.\nAvoid general entity types such as \"other\" or \"unknown\".\nThis is VERY IMPORTANT: Do not generate redundant or overlapping entity types. For example, if the text contains \"company\" and \"organization\" entity types, you should return only one of them.\nDon't worry about quantity, always choose quality over quantity. And make sure EVERYTHING in your answer is relevant to the context of entity extraction.\nAnd remember, it is ENTITY TYPES what we need.\nReturn the entity types in as a list of comma sepparated of strings.",
        "detail": "graphrag.prompt_tune.prompt.entity_types",
        "documentation": {}
    },
    {
        "label": "ENTITY_TYPE_GENERATION_JSON_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.entity_types",
        "description": "graphrag.prompt_tune.prompt.entity_types",
        "peekOfCode": "ENTITY_TYPE_GENERATION_JSON_PROMPT = \"\"\"\nThe goal is to study the connections and relations between the entity types and their features in order to understand all available information from the text.\nThe user's task is to {task}.\nAs part of the analysis, you want to identify the entity types present in the following text.\nThe entity types must be relevant to the user task.\nAvoid general entity types such as \"other\" or \"unknown\".\nThis is VERY IMPORTANT: Do not generate redundant or overlapping entity types. For example, if the text contains \"company\" and \"organization\" entity types, you should return only one of them.\nDon't worry about quantity, always choose quality over quantity. And make sure EVERYTHING in your answer is relevant to the context of entity extraction.\nReturn the entity types in JSON format with \"entities\" as the key and the entity types as an array of strings.\n=====================================================================",
        "detail": "graphrag.prompt_tune.prompt.entity_types",
        "documentation": {}
    },
    {
        "label": "DETECT_LANGUAGE_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.language",
        "description": "graphrag.prompt_tune.prompt.language",
        "peekOfCode": "DETECT_LANGUAGE_PROMPT = \"\"\"\nYou are an intelligent assistant that helps a human to analyze the information in a text document.\nGiven a sample text, help the user by determining what's the primary language of the provided texts.\nExamples are: \"English\", \"Spanish\", \"Japanese\", \"Portuguese\" among others.\nText: {input_text}\nLanguage:\"\"\"",
        "detail": "graphrag.prompt_tune.prompt.language",
        "documentation": {}
    },
    {
        "label": "GENERATE_PERSONA_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.prompt.persona",
        "description": "graphrag.prompt_tune.prompt.persona",
        "peekOfCode": "GENERATE_PERSONA_PROMPT = \"\"\"\nYou are an intelligent assistant that helps a human to analyze the information in a text document.\nGiven a specific type of task and sample text, help the user by generating a 3 to 4 sentence description of an expert who could help solve the problem.\nUse a format similar to the following:\nYou are an expert {{role}}. You are skilled at {{relevant skills}}. You are adept at helping people with {{specific task}}.\ntask: {sample_task}\npersona description:\"\"\"",
        "detail": "graphrag.prompt_tune.prompt.persona",
        "documentation": {}
    },
    {
        "label": "COMMUNITY_REPORT_SUMMARIZATION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.template.community_report_summarization",
        "description": "graphrag.prompt_tune.template.community_report_summarization",
        "peekOfCode": "COMMUNITY_REPORT_SUMMARIZATION_PROMPT = \"\"\"\n{persona}\n# Goal\nWrite a comprehensive assessment report of a community taking on the role of a {role}. The content of this report includes an overview of the community's key entities and relationships.\n# Report Structure\nThe report should include the following sections:\n- TITLE: community's name that represents its key entities - title should be short but specific. When possible, include representative named entities in the title.\n- SUMMARY: An executive summary of the community's overall structure, how its entities are related to each other, and significant points associated with its entities.\n- REPORT RATING: {report_rating_description}\n- RATING EXPLANATION: Give a single sentence explanation of the rating.",
        "detail": "graphrag.prompt_tune.template.community_report_summarization",
        "documentation": {}
    },
    {
        "label": "GRAPH_EXTRACTION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.template.entity_extraction",
        "description": "graphrag.prompt_tune.template.entity_extraction",
        "peekOfCode": "GRAPH_EXTRACTION_PROMPT = \"\"\"\n-Goal-\nGiven a text document that is potentially relevant to this activity and a list of entity types, identify all entities of those types from the text and all relationships among the identified entities.\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: One of the following types: [{entity_types}]\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity as (\"entity\"{{tuple_delimiter}}<entity_name>{{tuple_delimiter}}<entity_type>{{tuple_delimiter}}<entity_description>)\n2. From the entities identified in step 1, identify all pairs of (source_entity, target_entity) that are *clearly related* to each other.",
        "detail": "graphrag.prompt_tune.template.entity_extraction",
        "documentation": {}
    },
    {
        "label": "GRAPH_EXTRACTION_JSON_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.template.entity_extraction",
        "description": "graphrag.prompt_tune.template.entity_extraction",
        "peekOfCode": "GRAPH_EXTRACTION_JSON_PROMPT = \"\"\"\n-Goal-\nGiven a text document that is potentially relevant to this activity and a list of entity types, identify all entities of those types from the text and all relationships among the identified entities.\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: One of the following types: [{entity_types}]\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity output as a JSON entry with the following format:\n{{\"name\": <entity name>, \"type\": <type>, \"description\": <entity description>}}",
        "detail": "graphrag.prompt_tune.template.entity_extraction",
        "documentation": {}
    },
    {
        "label": "EXAMPLE_EXTRACTION_TEMPLATE",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.template.entity_extraction",
        "description": "graphrag.prompt_tune.template.entity_extraction",
        "peekOfCode": "EXAMPLE_EXTRACTION_TEMPLATE = \"\"\"\nExample {n}:\nentity_types: [{entity_types}]\ntext:\n{input_text}\n------------------------\noutput:\n{output}\n#############################\n\"\"\"",
        "detail": "graphrag.prompt_tune.template.entity_extraction",
        "documentation": {}
    },
    {
        "label": "UNTYPED_EXAMPLE_EXTRACTION_TEMPLATE",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.template.entity_extraction",
        "description": "graphrag.prompt_tune.template.entity_extraction",
        "peekOfCode": "UNTYPED_EXAMPLE_EXTRACTION_TEMPLATE = \"\"\"\nExample {n}:\ntext:\n{input_text}\n------------------------\noutput:\n{output}\n#############################\n\"\"\"\nUNTYPED_GRAPH_EXTRACTION_PROMPT = \"\"\"",
        "detail": "graphrag.prompt_tune.template.entity_extraction",
        "documentation": {}
    },
    {
        "label": "UNTYPED_GRAPH_EXTRACTION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.template.entity_extraction",
        "description": "graphrag.prompt_tune.template.entity_extraction",
        "peekOfCode": "UNTYPED_GRAPH_EXTRACTION_PROMPT = \"\"\"\n-Goal-\nGiven a text document that is potentially relevant to this activity, first identify all entities needed from the text in order to capture the information and ideas in the text.\nNext, report all relationships among the identified entities.\n-Steps-\n1. Identify all entities. For each identified entity, extract the following information:\n- entity_name: Name of the entity, capitalized\n- entity_type: Suggest several labels or categories for the entity. The categories should not be specific, but should be as general as possible.\n- entity_description: Comprehensive description of the entity's attributes and activities\nFormat each entity as (\"entity\"{{tuple_delimiter}}<entity_name>{{tuple_delimiter}}<entity_type>{{tuple_delimiter}}<entity_description>)",
        "detail": "graphrag.prompt_tune.template.entity_extraction",
        "documentation": {}
    },
    {
        "label": "ENTITY_SUMMARIZATION_PROMPT",
        "kind": 5,
        "importPath": "graphrag.prompt_tune.template.entity_summarization",
        "description": "graphrag.prompt_tune.template.entity_summarization",
        "peekOfCode": "ENTITY_SUMMARIZATION_PROMPT = \"\"\"\n{persona}\nUsing your expertise, you're asked to generate a comprehensive summary of the data provided below.\nGiven one or two entities, and a list of descriptions, all related to the same entity or group of entities.\nPlease concatenate all of these into a single, concise description in {language}. Make sure to include information collected from all the descriptions.\nIf the provided descriptions are contradictory, please resolve the contradictions and provide a single, coherent summary.\nMake sure it is written in third person, and include the entity names so we have the full context.\nEnrich it as much as you can with relevant information from the nearby text, this is very important.\nIf no answer is possible, or the description is empty, only convey information that is provided within the text.\n#######",
        "detail": "graphrag.prompt_tune.template.entity_summarization",
        "documentation": {}
    },
    {
        "label": "DocSelectionType",
        "kind": 6,
        "importPath": "graphrag.prompt_tune.types",
        "description": "graphrag.prompt_tune.types",
        "peekOfCode": "class DocSelectionType(Enum):\n    \"\"\"The type of document selection to use.\"\"\"\n    ALL = \"all\"\n    RANDOM = \"random\"\n    TOP = \"top\"\n    AUTO = \"auto\"\n    def __str__(self):\n        \"\"\"Return the string representation of the enum value.\"\"\"\n        return self.value",
        "detail": "graphrag.prompt_tune.types",
        "documentation": {}
    },
    {
        "label": "GlobalContextBuilder",
        "kind": 6,
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "peekOfCode": "class GlobalContextBuilder(ABC):\n    \"\"\"Base class for global-search context builders.\"\"\"\n    @abstractmethod\n    def build_context(\n        self, conversation_history: ConversationHistory | None = None, **kwargs\n    ) -> tuple[str | list[str], dict[str, pd.DataFrame]]:\n        \"\"\"Build the context for the global search mode.\"\"\"\nclass LocalContextBuilder(ABC):\n    \"\"\"Base class for local-search context builders.\"\"\"\n    @abstractmethod",
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "LocalContextBuilder",
        "kind": 6,
        "importPath": "graphrag.query.context_builder.builders",
        "description": "graphrag.query.context_builder.builders",
        "peekOfCode": "class LocalContextBuilder(ABC):\n    \"\"\"Base class for local-search context builders.\"\"\"\n    @abstractmethod\n    def build_context(\n        self,\n        query: str,\n        conversation_history: ConversationHistory | None = None,\n        **kwargs,\n    ) -> tuple[str | list[str], dict[str, pd.DataFrame]]:\n        \"\"\"Build the context for the local search mode.\"\"\"",
        "detail": "graphrag.query.context_builder.builders",
        "documentation": {}
    },
    {
        "label": "build_community_context",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.community_context",
        "description": "graphrag.query.context_builder.community_context",
        "peekOfCode": "def build_community_context(\n    community_reports: list[CommunityReport],\n    entities: list[Entity] | None = None,\n    token_encoder: tiktoken.Encoding | None = None,\n    use_community_summary: bool = True,\n    column_delimiter: str = \"|\",\n    shuffle_data: bool = True,\n    include_community_rank: bool = False,\n    min_community_rank: int = 0,\n    community_rank_name: str = \"rank\",",
        "detail": "graphrag.query.context_builder.community_context",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.query.context_builder.community_context",
        "description": "graphrag.query.context_builder.community_context",
        "peekOfCode": "log = logging.getLogger(__name__)\nNO_COMMUNITY_RECORDS_WARNING: str = (\n    \"Warning: No community records added when building community context.\"\n)\ndef build_community_context(\n    community_reports: list[CommunityReport],\n    entities: list[Entity] | None = None,\n    token_encoder: tiktoken.Encoding | None = None,\n    use_community_summary: bool = True,\n    column_delimiter: str = \"|\",",
        "detail": "graphrag.query.context_builder.community_context",
        "documentation": {}
    },
    {
        "label": "ConversationRole",
        "kind": 6,
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "peekOfCode": "class ConversationRole(str, Enum):\n    \"\"\"Enum for conversation roles.\"\"\"\n    SYSTEM = \"system\"\n    USER = \"user\"\n    ASSISTANT = \"assistant\"\n    @staticmethod\n    def from_string(value: str) -> \"ConversationRole\":\n        \"\"\"Convert string to ConversationRole.\"\"\"\n        if value == \"system\":\n            return ConversationRole.SYSTEM",
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "ConversationTurn",
        "kind": 6,
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "peekOfCode": "class ConversationTurn:\n    \"\"\"Data class for storing a single conversation turn.\"\"\"\n    role: ConversationRole\n    content: str\n    def __str__(self) -> str:\n        \"\"\"Return string representation of the conversation turn.\"\"\"\n        return f\"{self.role}: {self.content}\"\n@dataclass\nclass QATurn:\n    \"\"\"",
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "QATurn",
        "kind": 6,
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "peekOfCode": "class QATurn:\n    \"\"\"\n    Data class for storing a QA turn.\n    A QA turn contains a user question and one more multiple assistant answers.\n    \"\"\"\n    user_query: ConversationTurn\n    assistant_answers: list[ConversationTurn] | None = None\n    def get_answer_text(self) -> str | None:\n        \"\"\"Get the text of the assistant answers.\"\"\"\n        return (",
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "ConversationHistory",
        "kind": 6,
        "importPath": "graphrag.query.context_builder.conversation_history",
        "description": "graphrag.query.context_builder.conversation_history",
        "peekOfCode": "class ConversationHistory:\n    \"\"\"Class for storing a conversation history.\"\"\"\n    turns: list[ConversationTurn]\n    def __init__(self):\n        self.turns = []\n    @classmethod\n    def from_list(\n        cls, conversation_turns: list[dict[str, str]]\n    ) -> \"ConversationHistory\":\n        \"\"\"",
        "detail": "graphrag.query.context_builder.conversation_history",
        "documentation": {}
    },
    {
        "label": "EntityVectorStoreKey",
        "kind": 6,
        "importPath": "graphrag.query.context_builder.entity_extraction",
        "description": "graphrag.query.context_builder.entity_extraction",
        "peekOfCode": "class EntityVectorStoreKey(str, Enum):\n    \"\"\"Keys used as ids in the entity embedding vectorstores.\"\"\"\n    ID = \"id\"\n    TITLE = \"title\"\n    @staticmethod\n    def from_string(value: str) -> \"EntityVectorStoreKey\":\n        \"\"\"Convert string to EntityVectorStoreKey.\"\"\"\n        if value == \"id\":\n            return EntityVectorStoreKey.ID\n        if value == \"title\":",
        "detail": "graphrag.query.context_builder.entity_extraction",
        "documentation": {}
    },
    {
        "label": "map_query_to_entities",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.entity_extraction",
        "description": "graphrag.query.context_builder.entity_extraction",
        "peekOfCode": "def map_query_to_entities(\n    query: str,\n    text_embedding_vectorstore: BaseVectorStore,\n    text_embedder: BaseTextEmbedding,\n    all_entities: list[Entity],\n    embedding_vectorstore_key: str = EntityVectorStoreKey.ID,\n    include_entity_names: list[str] | None = None,\n    exclude_entity_names: list[str] | None = None,\n    k: int = 10,\n    oversample_scaler: int = 2,",
        "detail": "graphrag.query.context_builder.entity_extraction",
        "documentation": {}
    },
    {
        "label": "find_nearest_neighbors_by_graph_embeddings",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.entity_extraction",
        "description": "graphrag.query.context_builder.entity_extraction",
        "peekOfCode": "def find_nearest_neighbors_by_graph_embeddings(\n    entity_id: str,\n    graph_embedding_vectorstore: BaseVectorStore,\n    all_entities: list[Entity],\n    exclude_entity_names: list[str] | None = None,\n    embedding_vectorstore_key: str = EntityVectorStoreKey.ID,\n    k: int = 10,\n    oversample_scaler: int = 2,\n) -> list[Entity]:\n    \"\"\"Retrieve related entities by graph embeddings.\"\"\"",
        "detail": "graphrag.query.context_builder.entity_extraction",
        "documentation": {}
    },
    {
        "label": "find_nearest_neighbors_by_entity_rank",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.entity_extraction",
        "description": "graphrag.query.context_builder.entity_extraction",
        "peekOfCode": "def find_nearest_neighbors_by_entity_rank(\n    entity_name: str,\n    all_entities: list[Entity],\n    all_relationships: list[Relationship],\n    exclude_entity_names: list[str] | None = None,\n    k: int | None = 10,\n) -> list[Entity]:\n    \"\"\"Retrieve entities that have direct connections with the target entity, sorted by entity rank.\"\"\"\n    if exclude_entity_names is None:\n        exclude_entity_names = []",
        "detail": "graphrag.query.context_builder.entity_extraction",
        "documentation": {}
    },
    {
        "label": "build_entity_context",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.local_context",
        "description": "graphrag.query.context_builder.local_context",
        "peekOfCode": "def build_entity_context(\n    selected_entities: list[Entity],\n    token_encoder: tiktoken.Encoding | None = None,\n    max_tokens: int = 8000,\n    include_entity_rank: bool = True,\n    rank_description: str = \"number of relationships\",\n    column_delimiter: str = \"|\",\n    context_name=\"Entities\",\n) -> tuple[str, pd.DataFrame]:\n    \"\"\"Prepare entity data table as context data for system prompt.\"\"\"",
        "detail": "graphrag.query.context_builder.local_context",
        "documentation": {}
    },
    {
        "label": "build_covariates_context",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.local_context",
        "description": "graphrag.query.context_builder.local_context",
        "peekOfCode": "def build_covariates_context(\n    selected_entities: list[Entity],\n    covariates: list[Covariate],\n    token_encoder: tiktoken.Encoding | None = None,\n    max_tokens: int = 8000,\n    column_delimiter: str = \"|\",\n    context_name: str = \"Covariates\",\n) -> tuple[str, pd.DataFrame]:\n    \"\"\"Prepare covariate data tables as context data for system prompt.\"\"\"\n    # create an empty list of covariates",
        "detail": "graphrag.query.context_builder.local_context",
        "documentation": {}
    },
    {
        "label": "build_relationship_context",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.local_context",
        "description": "graphrag.query.context_builder.local_context",
        "peekOfCode": "def build_relationship_context(\n    selected_entities: list[Entity],\n    relationships: list[Relationship],\n    token_encoder: tiktoken.Encoding | None = None,\n    include_relationship_weight: bool = False,\n    max_tokens: int = 8000,\n    top_k_relationships: int = 10,\n    relationship_ranking_attribute: str = \"rank\",\n    column_delimiter: str = \"|\",\n    context_name: str = \"Relationships\",",
        "detail": "graphrag.query.context_builder.local_context",
        "documentation": {}
    },
    {
        "label": "get_candidate_context",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.local_context",
        "description": "graphrag.query.context_builder.local_context",
        "peekOfCode": "def get_candidate_context(\n    selected_entities: list[Entity],\n    entities: list[Entity],\n    relationships: list[Relationship],\n    covariates: dict[str, list[Covariate]],\n    include_entity_rank: bool = True,\n    entity_rank_description: str = \"number of relationships\",\n    include_relationship_weight: bool = False,\n) -> dict[str, pd.DataFrame]:\n    \"\"\"Prepare entity, relationship, and covariate data tables as context data for system prompt.\"\"\"",
        "detail": "graphrag.query.context_builder.local_context",
        "documentation": {}
    },
    {
        "label": "build_text_unit_context",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.source_context",
        "description": "graphrag.query.context_builder.source_context",
        "peekOfCode": "def build_text_unit_context(\n    text_units: list[TextUnit],\n    token_encoder: tiktoken.Encoding | None = None,\n    column_delimiter: str = \"|\",\n    shuffle_data: bool = True,\n    max_tokens: int = 8000,\n    context_name: str = \"Sources\",\n    random_state: int = 86,\n) -> tuple[str, dict[str, pd.DataFrame]]:\n    \"\"\"Prepare text-unit data table as context data for system prompt.\"\"\"",
        "detail": "graphrag.query.context_builder.source_context",
        "documentation": {}
    },
    {
        "label": "count_relationships",
        "kind": 2,
        "importPath": "graphrag.query.context_builder.source_context",
        "description": "graphrag.query.context_builder.source_context",
        "peekOfCode": "def count_relationships(\n    text_unit: TextUnit, entity: Entity, relationships: dict[str, Relationship]\n) -> int:\n    \"\"\"Count the number of relationships of the selected entity that are associated with the text unit.\"\"\"\n    matching_relationships = list[Relationship]()\n    if text_unit.relationship_ids is None:\n        entity_relationships = [\n            rel\n            for rel in relationships.values()\n            if rel.source == entity.title or rel.target == entity.title",
        "detail": "graphrag.query.context_builder.source_context",
        "documentation": {}
    },
    {
        "label": "read_entities",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def read_entities(\n    df: pd.DataFrame,\n    id_col: str = \"id\",\n    short_id_col: str | None = \"short_id\",\n    title_col: str = \"title\",\n    type_col: str | None = \"type\",\n    description_col: str | None = \"description\",\n    name_embedding_col: str | None = \"name_embedding\",\n    description_embedding_col: str | None = \"description_embedding\",\n    graph_embedding_col: str | None = \"graph_embedding\",",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "store_entity_semantic_embeddings",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def store_entity_semantic_embeddings(\n    entities: list[Entity],\n    vectorstore: BaseVectorStore,\n) -> BaseVectorStore:\n    \"\"\"Store entity semantic embeddings in a vectorstore.\"\"\"\n    documents = [\n        VectorStoreDocument(\n            id=entity.id,\n            text=entity.description,\n            vector=entity.description_embedding,",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "store_entity_behavior_embeddings",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def store_entity_behavior_embeddings(\n    entities: list[Entity],\n    vectorstore: BaseVectorStore,\n) -> BaseVectorStore:\n    \"\"\"Store entity behavior embeddings in a vectorstore.\"\"\"\n    documents = [\n        VectorStoreDocument(\n            id=entity.id,\n            text=entity.description,\n            vector=entity.graph_embedding,",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_relationships",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def read_relationships(\n    df: pd.DataFrame,\n    id_col: str = \"id\",\n    short_id_col: str | None = \"short_id\",\n    source_col: str = \"source\",\n    target_col: str = \"target\",\n    description_col: str | None = \"description\",\n    description_embedding_col: str | None = \"description_embedding\",\n    weight_col: str | None = \"weight\",\n    text_unit_ids_col: str | None = \"text_unit_ids\",",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_covariates",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def read_covariates(\n    df: pd.DataFrame,\n    id_col: str = \"id\",\n    short_id_col: str | None = \"short_id\",\n    subject_col: str = \"subject_id\",\n    covariate_type_col: str | None = \"type\",\n    text_unit_ids_col: str | None = \"text_unit_ids\",\n    document_ids_col: str | None = \"document_ids\",\n    attributes_cols: list[str] | None = None,\n) -> list[Covariate]:",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_communities",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def read_communities(\n    df: pd.DataFrame,\n    id_col: str = \"id\",\n    short_id_col: str | None = \"short_id\",\n    title_col: str = \"title\",\n    level_col: str = \"level\",\n    entities_col: str | None = \"entity_ids\",\n    relationships_col: str | None = \"relationship_ids\",\n    covariates_col: str | None = \"covariate_ids\",\n    attributes_cols: list[str] | None = None,",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_community_reports",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def read_community_reports(\n    df: pd.DataFrame,\n    id_col: str = \"id\",\n    short_id_col: str | None = \"short_id\",\n    title_col: str = \"title\",\n    community_col: str = \"community\",\n    summary_col: str = \"summary\",\n    content_col: str = \"full_content\",\n    rank_col: str | None = \"rank\",\n    summary_embedding_col: str | None = \"summary_embedding\",",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_text_units",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def read_text_units(\n    df: pd.DataFrame,\n    id_col: str = \"id\",\n    short_id_col: str | None = \"short_id\",\n    text_col: str = \"text\",\n    entities_col: str | None = \"entity_ids\",\n    relationships_col: str | None = \"relationship_ids\",\n    covariates_col: str | None = \"covariate_ids\",\n    tokens_col: str | None = \"n_tokens\",\n    document_ids_col: str | None = \"document_ids\",",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "read_documents",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.dfs",
        "description": "graphrag.query.input.loaders.dfs",
        "peekOfCode": "def read_documents(\n    df: pd.DataFrame,\n    id_col: str = \"id\",\n    short_id_col: str = \"short_id\",\n    title_col: str = \"title\",\n    type_col: str = \"type\",\n    summary_col: str | None = \"entities\",\n    raw_content_col: str | None = \"relationships\",\n    summary_embedding_col: str | None = \"summary_embedding\",\n    content_embedding_col: str | None = \"raw_content_embedding\",",
        "detail": "graphrag.query.input.loaders.dfs",
        "documentation": {}
    },
    {
        "label": "to_str",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_str(data: pd.Series, column_name: str | None) -> str:\n    \"\"\"Convert and validate a value to a string.\"\"\"\n    if column_name is None:\n        msg = \"Column name is None\"\n        raise ValueError(msg)\n    if column_name in data:\n        return str(data[column_name])\n    msg = f\"Column {column_name} not found in data\"\n    raise ValueError(msg)\ndef to_optional_str(data: pd.Series, column_name: str | None) -> str | None:",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_str",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_optional_str(data: pd.Series, column_name: str | None) -> str | None:\n    \"\"\"Convert and validate a value to an optional string.\"\"\"\n    if column_name is None:\n        msg = \"Column name is None\"\n        raise ValueError(msg)\n    if column_name in data:\n        value = data[column_name]\n        if value is None:\n            return None\n        return str(data[column_name])",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_list",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_list(\n    data: pd.Series, column_name: str | None, item_type: type | None = None\n) -> list:\n    \"\"\"Convert and validate a value to a list.\"\"\"\n    if column_name is None:\n        msg = \"Column name is None\"\n        raise ValueError(msg)\n    if column_name in data:\n        value = data[column_name]\n        if isinstance(value, np.ndarray):",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_list",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_optional_list(\n    data: pd.Series, column_name: str | None, item_type: type | None = None\n) -> list | None:\n    \"\"\"Convert and validate a value to an optional list.\"\"\"\n    if column_name is None:\n        return None\n    if column_name in data:\n        value = data[column_name]  # type: ignore\n        if value is None:\n            return None",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_int",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_int(data: pd.Series, column_name: str | None) -> int:\n    \"\"\"Convert and validate a value to an int.\"\"\"\n    if column_name is None:\n        msg = \"Column name is None\"\n        raise ValueError(msg)\n    if column_name in data:\n        value = data[column_name]\n        if isinstance(value, float):\n            value = int(value)\n        if not isinstance(value, int):",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_int",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_optional_int(data: pd.Series, column_name: str | None) -> int | None:\n    \"\"\"Convert and validate a value to an optional int.\"\"\"\n    if column_name is None:\n        return None\n    if column_name in data:\n        value = data[column_name]\n        if value is None:\n            return None\n        if isinstance(value, float):\n            value = int(value)",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_float",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_float(data: pd.Series, column_name: str | None) -> float:\n    \"\"\"Convert and validate a value to a float.\"\"\"\n    if column_name is None:\n        msg = \"Column name is None\"\n        raise ValueError(msg)\n    if column_name in data:\n        value = data[column_name]\n        if not isinstance(value, float):\n            msg = f\"value is not a float: {value} ({type(value)})\"\n            raise ValueError(msg)",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_float",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_optional_float(data: pd.Series, column_name: str | None) -> float | None:\n    \"\"\"Convert and validate a value to an optional float.\"\"\"\n    if column_name is None:\n        return None\n    if column_name in data:\n        value = data[column_name]\n        if value is None:\n            return None\n        if not isinstance(value, float):\n            msg = f\"value is not a float: {value} ({type(value)})\"",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_dict",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_dict(\n    data: pd.Series,\n    column_name: str | None,\n    key_type: type | None = None,\n    value_type: type | None = None,\n) -> dict:\n    \"\"\"Convert and validate a value to a dict.\"\"\"\n    if column_name is None:\n        msg = \"Column name is None\"\n        raise ValueError(msg)",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "to_optional_dict",
        "kind": 2,
        "importPath": "graphrag.query.input.loaders.utils",
        "description": "graphrag.query.input.loaders.utils",
        "peekOfCode": "def to_optional_dict(\n    data: pd.Series,\n    column_name: str | None,\n    key_type: type | None = None,\n    value_type: type | None = None,\n) -> dict | None:\n    \"\"\"Convert and validate a value to an optional dict.\"\"\"\n    if column_name is None:\n        return None\n    if column_name in data:",
        "detail": "graphrag.query.input.loaders.utils",
        "documentation": {}
    },
    {
        "label": "get_candidate_communities",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.community_reports",
        "description": "graphrag.query.input.retrieval.community_reports",
        "peekOfCode": "def get_candidate_communities(\n    selected_entities: list[Entity],\n    community_reports: list[CommunityReport],\n    include_community_rank: bool = False,\n    use_community_summary: bool = False,\n) -> pd.DataFrame:\n    \"\"\"Get all communities that are related to selected entities.\"\"\"\n    selected_community_ids = [\n        entity.community_ids for entity in selected_entities if entity.community_ids\n    ]",
        "detail": "graphrag.query.input.retrieval.community_reports",
        "documentation": {}
    },
    {
        "label": "to_community_report_dataframe",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.community_reports",
        "description": "graphrag.query.input.retrieval.community_reports",
        "peekOfCode": "def to_community_report_dataframe(\n    reports: list[CommunityReport],\n    include_community_rank: bool = False,\n    use_community_summary: bool = False,\n) -> pd.DataFrame:\n    \"\"\"Convert a list of communities to a pandas dataframe.\"\"\"\n    if len(reports) == 0:\n        return pd.DataFrame()\n    # add header\n    header = [\"id\", \"title\"]",
        "detail": "graphrag.query.input.retrieval.community_reports",
        "documentation": {}
    },
    {
        "label": "get_candidate_covariates",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.covariates",
        "description": "graphrag.query.input.retrieval.covariates",
        "peekOfCode": "def get_candidate_covariates(\n    selected_entities: list[Entity],\n    covariates: list[Covariate],\n) -> list[Covariate]:\n    \"\"\"Get all covariates that are related to selected entities.\"\"\"\n    selected_entity_names = [entity.title for entity in selected_entities]\n    return [\n        covariate\n        for covariate in covariates\n        if covariate.subject_id in selected_entity_names",
        "detail": "graphrag.query.input.retrieval.covariates",
        "documentation": {}
    },
    {
        "label": "to_covariate_dataframe",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.covariates",
        "description": "graphrag.query.input.retrieval.covariates",
        "peekOfCode": "def to_covariate_dataframe(covariates: list[Covariate]) -> pd.DataFrame:\n    \"\"\"Convert a list of covariates to a pandas dataframe.\"\"\"\n    if len(covariates) == 0:\n        return pd.DataFrame()\n    # add header\n    header = [\"id\", \"entity\"]\n    attributes = covariates[0].attributes or {} if len(covariates) > 0 else {}\n    attribute_cols = list(attributes.keys()) if len(covariates) > 0 else []\n    attribute_cols = [col for col in attribute_cols if col not in header]\n    header.extend(attribute_cols)",
        "detail": "graphrag.query.input.retrieval.covariates",
        "documentation": {}
    },
    {
        "label": "get_entity_by_key",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.entities",
        "description": "graphrag.query.input.retrieval.entities",
        "peekOfCode": "def get_entity_by_key(\n    entities: Iterable[Entity], key: str, value: str | int\n) -> Entity | None:\n    \"\"\"Get entity by key.\"\"\"\n    for entity in entities:\n        if isinstance(value, str) and is_valid_uuid(value):\n            if getattr(entity, key) == value or getattr(entity, key) == value.replace(\n                \"-\", \"\"\n            ):\n                return entity",
        "detail": "graphrag.query.input.retrieval.entities",
        "documentation": {}
    },
    {
        "label": "get_entity_by_name",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.entities",
        "description": "graphrag.query.input.retrieval.entities",
        "peekOfCode": "def get_entity_by_name(entities: Iterable[Entity], entity_name: str) -> list[Entity]:\n    \"\"\"Get entities by name.\"\"\"\n    return [entity for entity in entities if entity.title == entity_name]\ndef get_entity_by_attribute(\n    entities: Iterable[Entity], attribute_name: str, attribute_value: Any\n) -> list[Entity]:\n    \"\"\"Get entities by attribute.\"\"\"\n    return [\n        entity\n        for entity in entities",
        "detail": "graphrag.query.input.retrieval.entities",
        "documentation": {}
    },
    {
        "label": "get_entity_by_attribute",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.entities",
        "description": "graphrag.query.input.retrieval.entities",
        "peekOfCode": "def get_entity_by_attribute(\n    entities: Iterable[Entity], attribute_name: str, attribute_value: Any\n) -> list[Entity]:\n    \"\"\"Get entities by attribute.\"\"\"\n    return [\n        entity\n        for entity in entities\n        if entity.attributes\n        and entity.attributes.get(attribute_name) == attribute_value\n    ]",
        "detail": "graphrag.query.input.retrieval.entities",
        "documentation": {}
    },
    {
        "label": "to_entity_dataframe",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.entities",
        "description": "graphrag.query.input.retrieval.entities",
        "peekOfCode": "def to_entity_dataframe(\n    entities: list[Entity],\n    include_entity_rank: bool = True,\n    rank_description: str = \"number of relationships\",\n) -> pd.DataFrame:\n    \"\"\"Convert a list of entities to a pandas dataframe.\"\"\"\n    if len(entities) == 0:\n        return pd.DataFrame()\n    header = [\"id\", \"entity\", \"description\"]\n    if include_entity_rank:",
        "detail": "graphrag.query.input.retrieval.entities",
        "documentation": {}
    },
    {
        "label": "is_valid_uuid",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.entities",
        "description": "graphrag.query.input.retrieval.entities",
        "peekOfCode": "def is_valid_uuid(value: str) -> bool:\n    \"\"\"Determine if a string is a valid UUID.\"\"\"\n    try:\n        uuid.UUID(str(value))\n    except ValueError:\n        return False\n    else:\n        return True",
        "detail": "graphrag.query.input.retrieval.entities",
        "documentation": {}
    },
    {
        "label": "get_in_network_relationships",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "peekOfCode": "def get_in_network_relationships(\n    selected_entities: list[Entity],\n    relationships: list[Relationship],\n    ranking_attribute: str = \"rank\",\n) -> list[Relationship]:\n    \"\"\"Get all directed relationships between selected entities, sorted by ranking_attribute.\"\"\"\n    selected_entity_names = [entity.title for entity in selected_entities]\n    selected_relationships = [\n        relationship\n        for relationship in relationships",
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "get_out_network_relationships",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "peekOfCode": "def get_out_network_relationships(\n    selected_entities: list[Entity],\n    relationships: list[Relationship],\n    ranking_attribute: str = \"rank\",\n) -> list[Relationship]:\n    \"\"\"Get relationships from selected entities to other entities that are not within the selected entities, sorted by ranking_attribute.\"\"\"\n    selected_entity_names = [entity.title for entity in selected_entities]\n    source_relationships = [\n        relationship\n        for relationship in relationships",
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "get_candidate_relationships",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "peekOfCode": "def get_candidate_relationships(\n    selected_entities: list[Entity],\n    relationships: list[Relationship],\n) -> list[Relationship]:\n    \"\"\"Get all relationships that are associated with the selected entities.\"\"\"\n    selected_entity_names = [entity.title for entity in selected_entities]\n    return [\n        relationship\n        for relationship in relationships\n        if relationship.source in selected_entity_names",
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "get_entities_from_relationships",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "peekOfCode": "def get_entities_from_relationships(\n    relationships: list[Relationship], entities: list[Entity]\n) -> list[Entity]:\n    \"\"\"Get all entities that are associated with the selected relationships.\"\"\"\n    selected_entity_names = [relationship.source for relationship in relationships] + [\n        relationship.target for relationship in relationships\n    ]\n    return [entity for entity in entities if entity.title in selected_entity_names]\ndef calculate_relationship_combined_rank(\n    relationships: list[Relationship],",
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "calculate_relationship_combined_rank",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "peekOfCode": "def calculate_relationship_combined_rank(\n    relationships: list[Relationship],\n    entities: list[Entity],\n    ranking_attribute: str = \"rank\",\n) -> list[Relationship]:\n    \"\"\"Calculate default rank for a relationship based on the combined rank of source and target entities.\"\"\"\n    entity_mappings = {entity.title: entity for entity in entities}\n    for relationship in relationships:\n        if relationship.attributes is None:\n            relationship.attributes = {}",
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "sort_relationships_by_ranking_attribute",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "peekOfCode": "def sort_relationships_by_ranking_attribute(\n    relationships: list[Relationship],\n    entities: list[Entity],\n    ranking_attribute: str = \"rank\",\n) -> list[Relationship]:\n    \"\"\"\n    Sort relationships by a ranking_attribute.\n    If no ranking attribute exists, sort by combined rank of source and target entities.\n    \"\"\"\n    if len(relationships) == 0:",
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "to_relationship_dataframe",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.relationships",
        "description": "graphrag.query.input.retrieval.relationships",
        "peekOfCode": "def to_relationship_dataframe(\n    relationships: list[Relationship], include_relationship_weight: bool = True\n) -> pd.DataFrame:\n    \"\"\"Convert a list of relationships to a pandas dataframe.\"\"\"\n    if len(relationships) == 0:\n        return pd.DataFrame()\n    header = [\"id\", \"source\", \"target\", \"description\"]\n    if include_relationship_weight:\n        header.append(\"weight\")\n    attribute_cols = (",
        "detail": "graphrag.query.input.retrieval.relationships",
        "documentation": {}
    },
    {
        "label": "get_candidate_text_units",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.text_units",
        "description": "graphrag.query.input.retrieval.text_units",
        "peekOfCode": "def get_candidate_text_units(\n    selected_entities: list[Entity],\n    text_units: list[TextUnit],\n) -> pd.DataFrame:\n    \"\"\"Get all text units that are associated to selected entities.\"\"\"\n    selected_text_ids = [\n        entity.text_unit_ids for entity in selected_entities if entity.text_unit_ids\n    ]\n    selected_text_ids = [item for sublist in selected_text_ids for item in sublist]\n    selected_text_units = [unit for unit in text_units if unit.id in selected_text_ids]",
        "detail": "graphrag.query.input.retrieval.text_units",
        "documentation": {}
    },
    {
        "label": "to_text_unit_dataframe",
        "kind": 2,
        "importPath": "graphrag.query.input.retrieval.text_units",
        "description": "graphrag.query.input.retrieval.text_units",
        "peekOfCode": "def to_text_unit_dataframe(text_units: list[TextUnit]) -> pd.DataFrame:\n    \"\"\"Convert a list of text units to a pandas dataframe.\"\"\"\n    if len(text_units) == 0:\n        return pd.DataFrame()\n    # add header\n    header = [\"id\", \"text\"]\n    attribute_cols = (\n        list(text_units[0].attributes.keys()) if text_units[0].attributes else []\n    )\n    attribute_cols = [col for col in attribute_cols if col not in header]",
        "detail": "graphrag.query.input.retrieval.text_units",
        "documentation": {}
    },
    {
        "label": "BaseOpenAILLM",
        "kind": 6,
        "importPath": "graphrag.query.llm.oai.base",
        "description": "graphrag.query.llm.oai.base",
        "peekOfCode": "class BaseOpenAILLM(ABC):\n    \"\"\"The Base OpenAI LLM implementation.\"\"\"\n    _async_client: AsyncOpenAI | AsyncAzureOpenAI\n    _sync_client: OpenAI | AzureOpenAI\n    def __init__(self):\n        self._create_openai_client()\n    @abstractmethod\n    def _create_openai_client(self):\n        \"\"\"Create a new synchronous and asynchronous OpenAI client instance.\"\"\"\n    def set_clients(",
        "detail": "graphrag.query.llm.oai.base",
        "documentation": {}
    },
    {
        "label": "OpenAILLMImpl",
        "kind": 6,
        "importPath": "graphrag.query.llm.oai.base",
        "description": "graphrag.query.llm.oai.base",
        "peekOfCode": "class OpenAILLMImpl(BaseOpenAILLM):\n    \"\"\"Orchestration OpenAI LLM Implementation.\"\"\"\n    _reporter: StatusLogger = ConsoleReporter()\n    def __init__(\n        self,\n        api_key: str | None = None,\n        azure_ad_token_provider: Callable | None = None,\n        deployment_name: str | None = None,\n        api_base: str | None = None,\n        api_version: str | None = None,",
        "detail": "graphrag.query.llm.oai.base",
        "documentation": {}
    },
    {
        "label": "OpenAITextEmbeddingImpl",
        "kind": 6,
        "importPath": "graphrag.query.llm.oai.base",
        "description": "graphrag.query.llm.oai.base",
        "peekOfCode": "class OpenAITextEmbeddingImpl(BaseTextEmbedding):\n    \"\"\"Orchestration OpenAI Text Embedding Implementation.\"\"\"\n    _reporter: StatusLogger | None = None\n    def _create_openai_client(self, api_type: OpenaiApiType):\n        \"\"\"Create a new synchronous and asynchronous OpenAI client instance.\"\"\"",
        "detail": "graphrag.query.llm.oai.base",
        "documentation": {}
    },
    {
        "label": "ChatOpenAI",
        "kind": 6,
        "importPath": "graphrag.query.llm.oai.chat_openai",
        "description": "graphrag.query.llm.oai.chat_openai",
        "peekOfCode": "class ChatOpenAI(BaseLLM, OpenAILLMImpl):\n    \"\"\"Wrapper for OpenAI ChatCompletion models.\"\"\"\n    def __init__(\n        self,\n        api_key: str | None = None,\n        model: str | None = None,\n        azure_ad_token_provider: Callable | None = None,\n        deployment_name: str | None = None,\n        api_base: str | None = None,\n        api_version: str | None = None,",
        "detail": "graphrag.query.llm.oai.chat_openai",
        "documentation": {}
    },
    {
        "label": "_MODEL_REQUIRED_MSG",
        "kind": 5,
        "importPath": "graphrag.query.llm.oai.chat_openai",
        "description": "graphrag.query.llm.oai.chat_openai",
        "peekOfCode": "_MODEL_REQUIRED_MSG = \"model is required\"\nclass ChatOpenAI(BaseLLM, OpenAILLMImpl):\n    \"\"\"Wrapper for OpenAI ChatCompletion models.\"\"\"\n    def __init__(\n        self,\n        api_key: str | None = None,\n        model: str | None = None,\n        azure_ad_token_provider: Callable | None = None,\n        deployment_name: str | None = None,\n        api_base: str | None = None,",
        "detail": "graphrag.query.llm.oai.chat_openai",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbedding",
        "kind": 6,
        "importPath": "graphrag.query.llm.oai.embedding",
        "description": "graphrag.query.llm.oai.embedding",
        "peekOfCode": "class OpenAIEmbedding(BaseTextEmbedding, OpenAILLMImpl):\n    \"\"\"Wrapper for OpenAI Embedding models.\"\"\"\n    def __init__(\n        self,\n        api_key: str | None = None,\n        azure_ad_token_provider: Callable | None = None,\n        model: str = \"text-embedding-3-small\",\n        deployment_name: str | None = None,\n        api_base: str | None = None,\n        api_version: str | None = None,",
        "detail": "graphrag.query.llm.oai.embedding",
        "documentation": {}
    },
    {
        "label": "OpenAI",
        "kind": 6,
        "importPath": "graphrag.query.llm.oai.openai",
        "description": "graphrag.query.llm.oai.openai",
        "peekOfCode": "class OpenAI(OpenAILLMImpl):\n    \"\"\"Wrapper for OpenAI Completion models.\"\"\"\n    def __init__(\n        self,\n        api_key: str,\n        model: str,\n        deployment_name: str | None = None,\n        api_base: str | None = None,\n        api_version: str | None = None,\n        api_type: OpenaiApiType = OpenaiApiType.OpenAI,",
        "detail": "graphrag.query.llm.oai.openai",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.query.llm.oai.openai",
        "description": "graphrag.query.llm.oai.openai",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass OpenAI(OpenAILLMImpl):\n    \"\"\"Wrapper for OpenAI Completion models.\"\"\"\n    def __init__(\n        self,\n        api_key: str,\n        model: str,\n        deployment_name: str | None = None,\n        api_base: str | None = None,\n        api_version: str | None = None,",
        "detail": "graphrag.query.llm.oai.openai",
        "documentation": {}
    },
    {
        "label": "OpenaiApiType",
        "kind": 6,
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "peekOfCode": "class OpenaiApiType(str, Enum):\n    \"\"\"The OpenAI Flavor.\"\"\"\n    OpenAI = \"openai\"\n    AzureOpenAI = \"azure\"",
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "OPENAI_RETRY_ERROR_TYPES",
        "kind": 5,
        "importPath": "graphrag.query.llm.oai.typing",
        "description": "graphrag.query.llm.oai.typing",
        "peekOfCode": "OPENAI_RETRY_ERROR_TYPES = (\n    # TODO: update these when we update to OpenAI 1+ library\n    cast(Any, openai).RateLimitError,\n    cast(Any, openai).APIConnectionError,\n    # TODO: replace with comparable OpenAI 1+ error\n)\nclass OpenaiApiType(str, Enum):\n    \"\"\"The OpenAI Flavor.\"\"\"\n    OpenAI = \"openai\"\n    AzureOpenAI = \"azure\"",
        "detail": "graphrag.query.llm.oai.typing",
        "documentation": {}
    },
    {
        "label": "BaseLLM",
        "kind": 6,
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "peekOfCode": "class BaseLLM(ABC):\n    \"\"\"The Base LLM implementation.\"\"\"\n    @abstractmethod\n    def generate(\n        self,\n        messages: str | list[Any],\n        streaming: bool = True,\n        callbacks: list[BaseLLMCallback] | None = None,\n        **kwargs: Any,\n    ) -> str:",
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "BaseTextEmbedding",
        "kind": 6,
        "importPath": "graphrag.query.llm.base",
        "description": "graphrag.query.llm.base",
        "peekOfCode": "class BaseTextEmbedding(ABC):\n    \"\"\"The text embedding interface.\"\"\"\n    @abstractmethod\n    def embed(self, text: str, **kwargs: Any) -> list[float]:\n        \"\"\"Embed a text string.\"\"\"\n    @abstractmethod\n    async def aembed(self, text: str, **kwargs: Any) -> list[float]:\n        \"\"\"Embed a text string asynchronously.\"\"\"",
        "detail": "graphrag.query.llm.base",
        "documentation": {}
    },
    {
        "label": "num_tokens",
        "kind": 2,
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "peekOfCode": "def num_tokens(text: str, token_encoder: tiktoken.Encoding | None = None) -> int:\n    \"\"\"Return the number of tokens in the given text.\"\"\"\n    if token_encoder is None:\n        token_encoder = tiktoken.get_encoding(\"cl100k_base\")\n    return len(token_encoder.encode(text))  # type: ignore\ndef batched(iterable: Iterator, n: int):\n    \"\"\"\n    Batch data into tuples of length n. The last batch may be shorter.\n    Taken from Python's cookbook: https://docs.python.org/3/library/itertools.html#itertools.batched\n    \"\"\"",
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "batched",
        "kind": 2,
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "peekOfCode": "def batched(iterable: Iterator, n: int):\n    \"\"\"\n    Batch data into tuples of length n. The last batch may be shorter.\n    Taken from Python's cookbook: https://docs.python.org/3/library/itertools.html#itertools.batched\n    \"\"\"\n    # batched('ABCDEFG', 3) --> ABC DEF G\n    if n < 1:\n        value_error = \"n must be at least one\"\n        raise ValueError(value_error)\n    it = iter(iterable)",
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "chunk_text",
        "kind": 2,
        "importPath": "graphrag.query.llm.text_utils",
        "description": "graphrag.query.llm.text_utils",
        "peekOfCode": "def chunk_text(\n    text: str, max_tokens: int, token_encoder: tiktoken.Encoding | None = None\n):\n    \"\"\"Chunk text by token length.\"\"\"\n    if token_encoder is None:\n        token_encoder = tiktoken.get_encoding(\"cl100k_base\")\n    tokens = token_encoder.encode(text)  # type: ignore\n    chunk_iterator = batched(iter(tokens), max_tokens)\n    yield from (token_encoder.decode(list(chunk)) for chunk in chunk_iterator)",
        "detail": "graphrag.query.llm.text_utils",
        "documentation": {}
    },
    {
        "label": "QuestionResult",
        "kind": 6,
        "importPath": "graphrag.query.question_gen.base",
        "description": "graphrag.query.question_gen.base",
        "peekOfCode": "class QuestionResult:\n    \"\"\"A Structured Question Result.\"\"\"\n    response: list[str]\n    context_data: str | dict[str, Any]\n    completion_time: float\n    llm_calls: int\n    prompt_tokens: int\nclass BaseQuestionGen(ABC):\n    \"\"\"The Base Question Gen implementation.\"\"\"\n    def __init__(",
        "detail": "graphrag.query.question_gen.base",
        "documentation": {}
    },
    {
        "label": "BaseQuestionGen",
        "kind": 6,
        "importPath": "graphrag.query.question_gen.base",
        "description": "graphrag.query.question_gen.base",
        "peekOfCode": "class BaseQuestionGen(ABC):\n    \"\"\"The Base Question Gen implementation.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,\n        context_builder: GlobalContextBuilder | LocalContextBuilder,\n        token_encoder: tiktoken.Encoding | None = None,\n        llm_params: dict[str, Any] | None = None,\n        context_builder_params: dict[str, Any] | None = None,\n    ):",
        "detail": "graphrag.query.question_gen.base",
        "documentation": {}
    },
    {
        "label": "LocalQuestionGen",
        "kind": 6,
        "importPath": "graphrag.query.question_gen.local_gen",
        "description": "graphrag.query.question_gen.local_gen",
        "peekOfCode": "class LocalQuestionGen(BaseQuestionGen):\n    \"\"\"Search orchestration for global search mode.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,\n        context_builder: LocalContextBuilder,\n        token_encoder: tiktoken.Encoding | None = None,\n        system_prompt: str = QUESTION_SYSTEM_PROMPT,\n        callbacks: list[BaseLLMCallback] | None = None,\n        llm_params: dict[str, Any] | None = None,",
        "detail": "graphrag.query.question_gen.local_gen",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.query.question_gen.local_gen",
        "description": "graphrag.query.question_gen.local_gen",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass LocalQuestionGen(BaseQuestionGen):\n    \"\"\"Search orchestration for global search mode.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,\n        context_builder: LocalContextBuilder,\n        token_encoder: tiktoken.Encoding | None = None,\n        system_prompt: str = QUESTION_SYSTEM_PROMPT,\n        callbacks: list[BaseLLMCallback] | None = None,",
        "detail": "graphrag.query.question_gen.local_gen",
        "documentation": {}
    },
    {
        "label": "QUESTION_SYSTEM_PROMPT",
        "kind": 5,
        "importPath": "graphrag.query.question_gen.system_prompt",
        "description": "graphrag.query.question_gen.system_prompt",
        "peekOfCode": "QUESTION_SYSTEM_PROMPT = \"\"\"\n---Role---\nYou are a helpful assistant generating a bulleted list of {question_count} questions about data in the tables provided.\n---Data tables---\n{context_data}\n---Goal---\nGiven a series of example questions provided by the user, generate a bulleted list of {question_count} candidates for the next question. Use - marks as bullet points.\nThese candidate questions should represent the most important or urgent information content or themes in the data tables.\nThe candidate questions should be answerable using the data tables provided, but should not mention any specific data fields or data tables in the question text.\nIf the user's questions reference several named entities, then each candidate question should reference all named entities.",
        "detail": "graphrag.query.question_gen.system_prompt",
        "documentation": {}
    },
    {
        "label": "GlobalCommunityContext",
        "kind": 6,
        "importPath": "graphrag.query.structured_search.global_search.community_context",
        "description": "graphrag.query.structured_search.global_search.community_context",
        "peekOfCode": "class GlobalCommunityContext(GlobalContextBuilder):\n    \"\"\"GlobalSearch community context builder.\"\"\"\n    def __init__(\n        self,\n        community_reports: list[CommunityReport],\n        entities: list[Entity] | None = None,\n        token_encoder: tiktoken.Encoding | None = None,\n        random_state: int = 86,\n    ):\n        self.community_reports = community_reports",
        "detail": "graphrag.query.structured_search.global_search.community_context",
        "documentation": {}
    },
    {
        "label": "MAP_SYSTEM_PROMPT",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.global_search.map_system_prompt",
        "description": "graphrag.query.structured_search.global_search.map_system_prompt",
        "peekOfCode": "MAP_SYSTEM_PROMPT = \"\"\"\n---Role---\nYou are a helpful assistant responding to questions about data in the tables provided.\n---Goal---\nGenerate a response consisting of a list of key points that responds to the user's question, summarizing all relevant information in the input data tables.\nYou should use the data provided in the data tables below as the primary context for generating the response.\nIf you don't know the answer or if the input data tables do not contain sufficient information to provide an answer, just say so. Do not make anything up.\nEach key point in the response should have the following element:\n- Description: A comprehensive description of the point.\n- Importance Score: An integer score between 0-100 that indicates how important the point is in answering the user's question. An 'I don't know' type of response should have a score of 0.",
        "detail": "graphrag.query.structured_search.global_search.map_system_prompt",
        "documentation": {}
    },
    {
        "label": "REDUCE_SYSTEM_PROMPT",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "description": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "peekOfCode": "REDUCE_SYSTEM_PROMPT = \"\"\"\n---Role---\nYou are a helpful assistant responding to questions about a dataset by synthesizing perspectives from multiple analysts.\n---Goal---\nGenerate a response of the target length and format that responds to the user's question, summarize all the reports from multiple analysts who focused on different parts of the dataset.\nNote that the analysts' reports provided below are ranked in the **descending order of importance**.\nIf you don't know the answer or if the provided reports do not contain sufficient information to provide an answer, just say so. Do not make anything up.\nThe final response should remove all irrelevant information from the analysts' reports and merge the cleaned information into a comprehensive answer that provides explanations of all the key points and implications appropriate for the response length and format.\nAdd sections and commentary to the response as appropriate for the length and format. Style the response in markdown.\nThe response shall preserve the original meaning and use of modal verbs such as \"shall\", \"may\" or \"will\".",
        "detail": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "documentation": {}
    },
    {
        "label": "NO_DATA_ANSWER",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "description": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "peekOfCode": "NO_DATA_ANSWER = (\n    \"I am sorry but I am unable to answer this question given the provided data.\"\n)\nGENERAL_KNOWLEDGE_INSTRUCTION = \"\"\"\nThe response may also include relevant real-world knowledge outside the dataset, but it must be explicitly annotated with a verification tag [LLM: verify]. For example:\n\"This is an example sentence supported by real-world knowledge [LLM: verify].\"\n\"\"\"",
        "detail": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "documentation": {}
    },
    {
        "label": "GENERAL_KNOWLEDGE_INSTRUCTION",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "description": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "peekOfCode": "GENERAL_KNOWLEDGE_INSTRUCTION = \"\"\"\nThe response may also include relevant real-world knowledge outside the dataset, but it must be explicitly annotated with a verification tag [LLM: verify]. For example:\n\"This is an example sentence supported by real-world knowledge [LLM: verify].\"\n\"\"\"",
        "detail": "graphrag.query.structured_search.global_search.reduce_system_prompt",
        "documentation": {}
    },
    {
        "label": "GlobalSearchResult",
        "kind": 6,
        "importPath": "graphrag.query.structured_search.global_search.search",
        "description": "graphrag.query.structured_search.global_search.search",
        "peekOfCode": "class GlobalSearchResult(SearchResult):\n    \"\"\"A GlobalSearch result.\"\"\"\n    map_responses: list[SearchResult]\n    reduce_context_data: str | list[pd.DataFrame] | dict[str, pd.DataFrame]\n    reduce_context_text: str | list[str] | dict[str, str]\nclass GlobalSearch(BaseSearch):\n    \"\"\"Search orchestration for global search mode.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,",
        "detail": "graphrag.query.structured_search.global_search.search",
        "documentation": {}
    },
    {
        "label": "GlobalSearch",
        "kind": 6,
        "importPath": "graphrag.query.structured_search.global_search.search",
        "description": "graphrag.query.structured_search.global_search.search",
        "peekOfCode": "class GlobalSearch(BaseSearch):\n    \"\"\"Search orchestration for global search mode.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,\n        context_builder: GlobalContextBuilder,\n        token_encoder: tiktoken.Encoding | None = None,\n        map_system_prompt: str = MAP_SYSTEM_PROMPT,\n        reduce_system_prompt: str = REDUCE_SYSTEM_PROMPT,\n        response_type: str = \"multiple paragraphs\",",
        "detail": "graphrag.query.structured_search.global_search.search",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MAP_LLM_PARAMS",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.global_search.search",
        "description": "graphrag.query.structured_search.global_search.search",
        "peekOfCode": "DEFAULT_MAP_LLM_PARAMS = {\n    \"max_tokens\": 1000,\n    \"temperature\": 0.0,\n}\nDEFAULT_REDUCE_LLM_PARAMS = {\n    \"max_tokens\": 2000,\n    \"temperature\": 0.0,\n}\nlog = logging.getLogger(__name__)\n@dataclass",
        "detail": "graphrag.query.structured_search.global_search.search",
        "documentation": {}
    },
    {
        "label": "DEFAULT_REDUCE_LLM_PARAMS",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.global_search.search",
        "description": "graphrag.query.structured_search.global_search.search",
        "peekOfCode": "DEFAULT_REDUCE_LLM_PARAMS = {\n    \"max_tokens\": 2000,\n    \"temperature\": 0.0,\n}\nlog = logging.getLogger(__name__)\n@dataclass\nclass GlobalSearchResult(SearchResult):\n    \"\"\"A GlobalSearch result.\"\"\"\n    map_responses: list[SearchResult]\n    reduce_context_data: str | list[pd.DataFrame] | dict[str, pd.DataFrame]",
        "detail": "graphrag.query.structured_search.global_search.search",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.global_search.search",
        "description": "graphrag.query.structured_search.global_search.search",
        "peekOfCode": "log = logging.getLogger(__name__)\n@dataclass\nclass GlobalSearchResult(SearchResult):\n    \"\"\"A GlobalSearch result.\"\"\"\n    map_responses: list[SearchResult]\n    reduce_context_data: str | list[pd.DataFrame] | dict[str, pd.DataFrame]\n    reduce_context_text: str | list[str] | dict[str, str]\nclass GlobalSearch(BaseSearch):\n    \"\"\"Search orchestration for global search mode.\"\"\"\n    def __init__(",
        "detail": "graphrag.query.structured_search.global_search.search",
        "documentation": {}
    },
    {
        "label": "LocalSearchMixedContext",
        "kind": 6,
        "importPath": "graphrag.query.structured_search.local_search.mixed_context",
        "description": "graphrag.query.structured_search.local_search.mixed_context",
        "peekOfCode": "class LocalSearchMixedContext(LocalContextBuilder):\n    \"\"\"Build data context for local search prompt combining community reports and entity/relationship/covariate tables.\"\"\"\n    def __init__(\n        self,\n        entities: list[Entity],\n        entity_text_embeddings: BaseVectorStore,\n        text_embedder: BaseTextEmbedding,\n        text_units: list[TextUnit] | None = None,\n        community_reports: list[CommunityReport] | None = None,\n        relationships: list[Relationship] | None = None,",
        "detail": "graphrag.query.structured_search.local_search.mixed_context",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.local_search.mixed_context",
        "description": "graphrag.query.structured_search.local_search.mixed_context",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass LocalSearchMixedContext(LocalContextBuilder):\n    \"\"\"Build data context for local search prompt combining community reports and entity/relationship/covariate tables.\"\"\"\n    def __init__(\n        self,\n        entities: list[Entity],\n        entity_text_embeddings: BaseVectorStore,\n        text_embedder: BaseTextEmbedding,\n        text_units: list[TextUnit] | None = None,\n        community_reports: list[CommunityReport] | None = None,",
        "detail": "graphrag.query.structured_search.local_search.mixed_context",
        "documentation": {}
    },
    {
        "label": "LocalSearch",
        "kind": 6,
        "importPath": "graphrag.query.structured_search.local_search.search",
        "description": "graphrag.query.structured_search.local_search.search",
        "peekOfCode": "class LocalSearch(BaseSearch):\n    \"\"\"Search orchestration for local search mode.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,\n        context_builder: LocalContextBuilder,\n        token_encoder: tiktoken.Encoding | None = None,\n        system_prompt: str = LOCAL_SEARCH_SYSTEM_PROMPT,\n        response_type: str = \"multiple paragraphs\",\n        callbacks: list[BaseLLMCallback] | None = None,",
        "detail": "graphrag.query.structured_search.local_search.search",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LLM_PARAMS",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.local_search.search",
        "description": "graphrag.query.structured_search.local_search.search",
        "peekOfCode": "DEFAULT_LLM_PARAMS = {\n    \"max_tokens\": 1500,\n    \"temperature\": 0.0,\n}\nlog = logging.getLogger(__name__)\nclass LocalSearch(BaseSearch):\n    \"\"\"Search orchestration for local search mode.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,",
        "detail": "graphrag.query.structured_search.local_search.search",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.local_search.search",
        "description": "graphrag.query.structured_search.local_search.search",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass LocalSearch(BaseSearch):\n    \"\"\"Search orchestration for local search mode.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,\n        context_builder: LocalContextBuilder,\n        token_encoder: tiktoken.Encoding | None = None,\n        system_prompt: str = LOCAL_SEARCH_SYSTEM_PROMPT,\n        response_type: str = \"multiple paragraphs\",",
        "detail": "graphrag.query.structured_search.local_search.search",
        "documentation": {}
    },
    {
        "label": "LOCAL_SEARCH_SYSTEM_PROMPT",
        "kind": 5,
        "importPath": "graphrag.query.structured_search.local_search.system_prompt",
        "description": "graphrag.query.structured_search.local_search.system_prompt",
        "peekOfCode": "LOCAL_SEARCH_SYSTEM_PROMPT = \"\"\"\n---Role---\nYou are a helpful assistant responding to questions about data in the tables provided.\n---Goal---\nGenerate a response of the target length and format that responds to the user's question, summarizing all information in the input data tables appropriate for the response length and format, and incorporating any relevant general knowledge.\nIf you don't know the answer, just say so. Do not make anything up.\nPoints supported by data should list their data references as follows:\n\"This is an example sentence supported by multiple data references [Data: <dataset name> (record ids); <dataset name> (record ids)].\"\nDo not list more than 5 record ids in a single reference. Instead, list the top 5 most relevant record ids and add \"+more\" to indicate that there are more.\nFor example:",
        "detail": "graphrag.query.structured_search.local_search.system_prompt",
        "documentation": {}
    },
    {
        "label": "SearchResult",
        "kind": 6,
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "peekOfCode": "class SearchResult:\n    \"\"\"A Structured Search Result.\"\"\"\n    response: str | dict[str, Any] | list[dict[str, Any]]\n    context_data: str | list[pd.DataFrame] | dict[str, pd.DataFrame]\n    # actual text strings that are in the context window, built from context_data\n    context_text: str | list[str] | dict[str, str]\n    completion_time: float\n    llm_calls: int\n    prompt_tokens: int\nclass BaseSearch(ABC):",
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "BaseSearch",
        "kind": 6,
        "importPath": "graphrag.query.structured_search.base",
        "description": "graphrag.query.structured_search.base",
        "peekOfCode": "class BaseSearch(ABC):\n    \"\"\"The Base Search implementation.\"\"\"\n    def __init__(\n        self,\n        llm: BaseLLM,\n        context_builder: GlobalContextBuilder | LocalContextBuilder,\n        token_encoder: tiktoken.Encoding | None = None,\n        llm_params: dict[str, Any] | None = None,\n        context_builder_params: dict[str, Any] | None = None,\n    ):",
        "detail": "graphrag.query.structured_search.base",
        "documentation": {}
    },
    {
        "label": "run_global_search",
        "kind": 2,
        "importPath": "graphrag.query.cli",
        "description": "graphrag.query.cli",
        "peekOfCode": "def run_global_search(\n    config_filepath: str | None,\n    data_dir: str | None,\n    root_dir: str,\n    community_level: int,\n    response_type: str,\n    streaming: bool,\n    query: str,\n):\n    \"\"\"Perform a global search with a given query.",
        "detail": "graphrag.query.cli",
        "documentation": {}
    },
    {
        "label": "run_local_search",
        "kind": 2,
        "importPath": "graphrag.query.cli",
        "description": "graphrag.query.cli",
        "peekOfCode": "def run_local_search(\n    config_filepath: str | None,\n    data_dir: str | None,\n    root_dir: str,\n    community_level: int,\n    response_type: str,\n    streaming: bool,\n    query: str,\n):\n    \"\"\"Perform a local search with a given query.",
        "detail": "graphrag.query.cli",
        "documentation": {}
    },
    {
        "label": "reporter",
        "kind": 5,
        "importPath": "graphrag.query.cli",
        "description": "graphrag.query.cli",
        "peekOfCode": "reporter = PrintProgressReporter(\"\")\ndef run_global_search(\n    config_filepath: str | None,\n    data_dir: str | None,\n    root_dir: str,\n    community_level: int,\n    response_type: str,\n    streaming: bool,\n    query: str,\n):",
        "detail": "graphrag.query.cli",
        "documentation": {}
    },
    {
        "label": "get_llm",
        "kind": 2,
        "importPath": "graphrag.query.factories",
        "description": "graphrag.query.factories",
        "peekOfCode": "def get_llm(config: GraphRagConfig) -> ChatOpenAI:\n    \"\"\"Get the LLM client.\"\"\"\n    is_azure_client = (\n        config.llm.type == LLMType.AzureOpenAIChat\n        or config.llm.type == LLMType.AzureOpenAI\n    )\n    debug_llm_key = config.llm.api_key or \"\"\n    llm_debug_info = {\n        **config.llm.model_dump(),\n        \"api_key\": f\"REDACTED,len={len(debug_llm_key)}\",",
        "detail": "graphrag.query.factories",
        "documentation": {}
    },
    {
        "label": "get_text_embedder",
        "kind": 2,
        "importPath": "graphrag.query.factories",
        "description": "graphrag.query.factories",
        "peekOfCode": "def get_text_embedder(config: GraphRagConfig) -> OpenAIEmbedding:\n    \"\"\"Get the LLM client for embeddings.\"\"\"\n    is_azure_client = config.embeddings.llm.type == LLMType.AzureOpenAIEmbedding\n    debug_embedding_api_key = config.embeddings.llm.api_key or \"\"\n    llm_debug_info = {\n        **config.embeddings.llm.model_dump(),\n        \"api_key\": f\"REDACTED,len={len(debug_embedding_api_key)}\",\n    }\n    if config.embeddings.llm.cognitive_services_endpoint is None:\n        cognitive_services_endpoint = \"https://cognitiveservices.azure.com/.default\"",
        "detail": "graphrag.query.factories",
        "documentation": {}
    },
    {
        "label": "get_local_search_engine",
        "kind": 2,
        "importPath": "graphrag.query.factories",
        "description": "graphrag.query.factories",
        "peekOfCode": "def get_local_search_engine(\n    config: GraphRagConfig,\n    reports: list[CommunityReport],\n    text_units: list[TextUnit],\n    entities: list[Entity],\n    relationships: list[Relationship],\n    covariates: dict[str, list[Covariate]],\n    response_type: str,\n    description_embedding_store: BaseVectorStore,\n) -> BaseSearch:",
        "detail": "graphrag.query.factories",
        "documentation": {}
    },
    {
        "label": "get_global_search_engine",
        "kind": 2,
        "importPath": "graphrag.query.factories",
        "description": "graphrag.query.factories",
        "peekOfCode": "def get_global_search_engine(\n    config: GraphRagConfig,\n    reports: list[CommunityReport],\n    entities: list[Entity],\n    response_type: str,\n) -> BaseSearch:\n    \"\"\"Create a global search engine based on data + configuration.\"\"\"\n    token_encoder = tiktoken.get_encoding(config.encoding_model)\n    gs_config = config.global_search\n    return GlobalSearch(",
        "detail": "graphrag.query.factories",
        "documentation": {}
    },
    {
        "label": "read_indexer_text_units",
        "kind": 2,
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "peekOfCode": "def read_indexer_text_units(final_text_units: pd.DataFrame) -> list[TextUnit]:\n    \"\"\"Read in the Text Units from the raw indexing outputs.\"\"\"\n    return read_text_units(\n        df=final_text_units,\n        short_id_col=None,\n        # expects a covariate map of type -> ids\n        covariates_col=None,\n    )\ndef read_indexer_covariates(final_covariates: pd.DataFrame) -> list[Covariate]:\n    \"\"\"Read in the Claims from the raw indexing outputs.\"\"\"",
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "read_indexer_covariates",
        "kind": 2,
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "peekOfCode": "def read_indexer_covariates(final_covariates: pd.DataFrame) -> list[Covariate]:\n    \"\"\"Read in the Claims from the raw indexing outputs.\"\"\"\n    covariate_df = final_covariates\n    covariate_df[\"id\"] = covariate_df[\"id\"].astype(str)\n    return read_covariates(\n        df=covariate_df,\n        short_id_col=\"human_readable_id\",\n        attributes_cols=[\n            \"object_id\",\n            \"status\",",
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "read_indexer_relationships",
        "kind": 2,
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "peekOfCode": "def read_indexer_relationships(final_relationships: pd.DataFrame) -> list[Relationship]:\n    \"\"\"Read in the Relationships from the raw indexing outputs.\"\"\"\n    return read_relationships(\n        df=final_relationships,\n        short_id_col=\"human_readable_id\",\n        description_embedding_col=None,\n        document_ids_col=None,\n        attributes_cols=[\"rank\"],\n    )\ndef read_indexer_reports(",
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "read_indexer_reports",
        "kind": 2,
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "peekOfCode": "def read_indexer_reports(\n    final_community_reports: pd.DataFrame,\n    final_nodes: pd.DataFrame,\n    community_level: int,\n) -> list[CommunityReport]:\n    \"\"\"Read in the Community Reports from the raw indexing outputs.\"\"\"\n    report_df = final_community_reports\n    entity_df = final_nodes\n    entity_df = _filter_under_community_level(entity_df, community_level)\n    entity_df.loc[:, \"community\"] = entity_df[\"community\"].fillna(-1)",
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "read_indexer_entities",
        "kind": 2,
        "importPath": "graphrag.query.indexer_adapters",
        "description": "graphrag.query.indexer_adapters",
        "peekOfCode": "def read_indexer_entities(\n    final_nodes: pd.DataFrame,\n    final_entities: pd.DataFrame,\n    community_level: int,\n) -> list[Entity]:\n    \"\"\"Read in the Entities from the raw indexing outputs.\"\"\"\n    entity_df = final_nodes\n    entity_embedding_df = final_entities\n    entity_df = _filter_under_community_level(entity_df, community_level)\n    entity_df = cast(pd.DataFrame, entity_df[[\"title\", \"degree\", \"community\"]]).rename(",
        "detail": "graphrag.query.indexer_adapters",
        "documentation": {}
    },
    {
        "label": "file_exist",
        "kind": 2,
        "importPath": "graphrag.utils.cli",
        "description": "graphrag.utils.cli",
        "peekOfCode": "def file_exist(path):\n    \"\"\"Check for file existence.\"\"\"\n    if not Path(path).is_file():\n        msg = f\"File not found: {path}\"\n        raise argparse.ArgumentTypeError(msg)\n    return path\ndef dir_exist(path):\n    \"\"\"Check for directory existence.\"\"\"\n    if not Path(path).is_dir():\n        msg = f\"Directory not found: {path}\"",
        "detail": "graphrag.utils.cli",
        "documentation": {}
    },
    {
        "label": "dir_exist",
        "kind": 2,
        "importPath": "graphrag.utils.cli",
        "description": "graphrag.utils.cli",
        "peekOfCode": "def dir_exist(path):\n    \"\"\"Check for directory existence.\"\"\"\n    if not Path(path).is_dir():\n        msg = f\"Directory not found: {path}\"\n        raise argparse.ArgumentTypeError(msg)\n    return path",
        "detail": "graphrag.utils.cli",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "graphrag.utils.storage",
        "description": "graphrag.utils.storage",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef _create_storage(\n    config: PipelineStorageConfigTypes | None, root_dir: str\n) -> PipelineStorage:\n    \"\"\"Create the storage for the pipeline.\n    Parameters\n    ----------\n    config : PipelineStorageConfigTypes\n        The storage configuration.\n    root_dir : str",
        "detail": "graphrag.utils.storage",
        "documentation": {}
    },
    {
        "label": "AzureAISearch",
        "kind": 6,
        "importPath": "graphrag.vector_stores.azure_ai_search",
        "description": "graphrag.vector_stores.azure_ai_search",
        "peekOfCode": "class AzureAISearch(BaseVectorStore):\n    \"\"\"The Azure AI Search vector storage implementation.\"\"\"\n    index_client: SearchIndexClient\n    def connect(self, **kwargs: Any) -> Any:\n        \"\"\"Connect to the AzureAI vector store.\"\"\"\n        url = kwargs.get(\"url\", None)\n        api_key = kwargs.get(\"api_key\", None)\n        audience = kwargs.get(\"audience\", None)\n        self.vector_size = kwargs.get(\"vector_size\", DEFAULT_VECTOR_SIZE)\n        self.vector_search_profile_name = kwargs.get(",
        "detail": "graphrag.vector_stores.azure_ai_search",
        "documentation": {}
    },
    {
        "label": "VectorStoreDocument",
        "kind": 6,
        "importPath": "graphrag.vector_stores.base",
        "description": "graphrag.vector_stores.base",
        "peekOfCode": "class VectorStoreDocument:\n    \"\"\"A document that is stored in vector storage.\"\"\"\n    id: str | int\n    \"\"\"unique id for the document\"\"\"\n    text: str | None\n    vector: list[float] | None\n    attributes: dict[str, Any] = field(default_factory=dict)\n    \"\"\"store any additional metadata, e.g. title, date ranges, etc\"\"\"\n@dataclass\nclass VectorStoreSearchResult:",
        "detail": "graphrag.vector_stores.base",
        "documentation": {}
    },
    {
        "label": "VectorStoreSearchResult",
        "kind": 6,
        "importPath": "graphrag.vector_stores.base",
        "description": "graphrag.vector_stores.base",
        "peekOfCode": "class VectorStoreSearchResult:\n    \"\"\"A vector storage search result.\"\"\"\n    document: VectorStoreDocument\n    \"\"\"Document that was found.\"\"\"\n    score: float\n    \"\"\"Similarity score between -1 and 1. Higher is more similar.\"\"\"\nclass BaseVectorStore(ABC):\n    \"\"\"The base class for vector storage data-access classes.\"\"\"\n    def __init__(\n        self,",
        "detail": "graphrag.vector_stores.base",
        "documentation": {}
    },
    {
        "label": "BaseVectorStore",
        "kind": 6,
        "importPath": "graphrag.vector_stores.base",
        "description": "graphrag.vector_stores.base",
        "peekOfCode": "class BaseVectorStore(ABC):\n    \"\"\"The base class for vector storage data-access classes.\"\"\"\n    def __init__(\n        self,\n        collection_name: str,\n        db_connection: Any | None = None,\n        document_collection: Any | None = None,\n        query_filter: Any | None = None,\n        **kwargs: Any,\n    ):",
        "detail": "graphrag.vector_stores.base",
        "documentation": {}
    },
    {
        "label": "LanceDBVectorStore",
        "kind": 6,
        "importPath": "graphrag.vector_stores.lancedb",
        "description": "graphrag.vector_stores.lancedb",
        "peekOfCode": "class LanceDBVectorStore(BaseVectorStore):\n    \"\"\"The LanceDB vector storage implementation.\"\"\"\n    def connect(self, **kwargs: Any) -> Any:\n        \"\"\"Connect to the vector storage.\"\"\"\n        db_uri = kwargs.get(\"db_uri\", \"./lancedb\")\n        self.db_connection = lancedb.connect(db_uri)  # type: ignore\n    def load_documents(\n        self, documents: list[VectorStoreDocument], overwrite: bool = True\n    ) -> None:\n        \"\"\"Load documents into vector storage.\"\"\"",
        "detail": "graphrag.vector_stores.lancedb",
        "documentation": {}
    },
    {
        "label": "VectorStoreType",
        "kind": 6,
        "importPath": "graphrag.vector_stores.typing",
        "description": "graphrag.vector_stores.typing",
        "peekOfCode": "class VectorStoreType(str, Enum):\n    \"\"\"The supported vector store types.\"\"\"\n    LanceDB = \"lancedb\"\n    AzureAISearch = \"azure_ai_search\"\nclass VectorStoreFactory:\n    \"\"\"A factory class for creating vector stores.\"\"\"\n    vector_store_types: ClassVar[dict[str, type]] = {}\n    @classmethod\n    def register(cls, vector_store_type: str, vector_store: type):\n        \"\"\"Register a vector store type.\"\"\"",
        "detail": "graphrag.vector_stores.typing",
        "documentation": {}
    },
    {
        "label": "VectorStoreFactory",
        "kind": 6,
        "importPath": "graphrag.vector_stores.typing",
        "description": "graphrag.vector_stores.typing",
        "peekOfCode": "class VectorStoreFactory:\n    \"\"\"A factory class for creating vector stores.\"\"\"\n    vector_store_types: ClassVar[dict[str, type]] = {}\n    @classmethod\n    def register(cls, vector_store_type: str, vector_store: type):\n        \"\"\"Register a vector store type.\"\"\"\n        cls.vector_store_types[vector_store_type] = vector_store\n    @classmethod\n    def get_vector_store(\n        cls, vector_store_type: VectorStoreType | str, kwargs: dict",
        "detail": "graphrag.vector_stores.typing",
        "documentation": {}
    },
    {
        "label": "TestRun",
        "kind": 6,
        "importPath": "tests.integration._pipeline.test_run",
        "description": "tests.integration._pipeline.test_run",
        "peekOfCode": "class TestRun(unittest.IsolatedAsyncioTestCase):\n    async def test_megapipeline(self):\n        pipeline_path = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)),\n            \"./megapipeline.yml\",\n        )\n        pipeline_result = [gen async for gen in run_pipeline_with_config(pipeline_path)]\n        errors = []\n        for result in pipeline_result:\n            if result.errors is not None and len(result.errors) > 0:",
        "detail": "tests.integration._pipeline.test_run",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "tests.integration._pipeline.test_run",
        "description": "tests.integration._pipeline.test_run",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestRun(unittest.IsolatedAsyncioTestCase):\n    async def test_megapipeline(self):\n        pipeline_path = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)),\n            \"./megapipeline.yml\",\n        )\n        pipeline_result = [gen async for gen in run_pipeline_with_config(pipeline_path)]\n        errors = []\n        for result in pipeline_result:",
        "detail": "tests.integration._pipeline.test_run",
        "documentation": {}
    },
    {
        "label": "WELL_KNOWN_BLOB_STORAGE_KEY",
        "kind": 5,
        "importPath": "tests.integration.storage.test_blob_pipeline_storage",
        "description": "tests.integration.storage.test_blob_pipeline_storage",
        "peekOfCode": "WELL_KNOWN_BLOB_STORAGE_KEY = \"DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;\"\nasync def test_find():\n    storage = BlobPipelineStorage(\n        connection_string=WELL_KNOWN_BLOB_STORAGE_KEY,\n        container_name=\"testfind\",\n    )\n    try:\n        try:\n            items = list(\n                storage.find(base_dir=\"input\", file_pattern=re.compile(r\".*\\.txt$\"))",
        "detail": "tests.integration.storage.test_blob_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "__dirname__",
        "kind": 5,
        "importPath": "tests.integration.storage.test_file_pipeline_storage",
        "description": "tests.integration.storage.test_file_pipeline_storage",
        "peekOfCode": "__dirname__ = os.path.dirname(__file__)\nasync def test_find():\n    storage = FilePipelineStorage()\n    items = list(\n        storage.find(\n            base_dir=\"tests/fixtures/text/input\",\n            file_pattern=re.compile(r\".*\\.txt$\"),\n            progress=None,\n            file_filter=None,\n        )",
        "detail": "tests.integration.storage.test_file_pipeline_storage",
        "documentation": {}
    },
    {
        "label": "test_notebook",
        "kind": 2,
        "importPath": "tests.notebook.test_notebooks",
        "description": "tests.notebook.test_notebooks",
        "peekOfCode": "def test_notebook(notebook_path: Path):\n    assert _notebook_run(notebook_path) == []",
        "detail": "tests.notebook.test_notebooks",
        "documentation": {}
    },
    {
        "label": "NOTEBOOKS_PATH",
        "kind": 5,
        "importPath": "tests.notebook.test_notebooks",
        "description": "tests.notebook.test_notebooks",
        "peekOfCode": "NOTEBOOKS_PATH = Path(\"examples_notebooks\")\nEXCLUDED_PATH = NOTEBOOKS_PATH / \"community_contrib\"\nnotebooks_list = [\n    notebook\n    for notebook in NOTEBOOKS_PATH.rglob(\"*.ipynb\")\n    if EXCLUDED_PATH not in notebook.parents\n]\ndef _notebook_run(filepath: Path):\n    \"\"\"Execute a notebook via nbconvert and collect output.\n    :returns execution errors",
        "detail": "tests.notebook.test_notebooks",
        "documentation": {}
    },
    {
        "label": "EXCLUDED_PATH",
        "kind": 5,
        "importPath": "tests.notebook.test_notebooks",
        "description": "tests.notebook.test_notebooks",
        "peekOfCode": "EXCLUDED_PATH = NOTEBOOKS_PATH / \"community_contrib\"\nnotebooks_list = [\n    notebook\n    for notebook in NOTEBOOKS_PATH.rglob(\"*.ipynb\")\n    if EXCLUDED_PATH not in notebook.parents\n]\ndef _notebook_run(filepath: Path):\n    \"\"\"Execute a notebook via nbconvert and collect output.\n    :returns execution errors\n    \"\"\"",
        "detail": "tests.notebook.test_notebooks",
        "documentation": {}
    },
    {
        "label": "notebooks_list",
        "kind": 5,
        "importPath": "tests.notebook.test_notebooks",
        "description": "tests.notebook.test_notebooks",
        "peekOfCode": "notebooks_list = [\n    notebook\n    for notebook in NOTEBOOKS_PATH.rglob(\"*.ipynb\")\n    if EXCLUDED_PATH not in notebook.parents\n]\ndef _notebook_run(filepath: Path):\n    \"\"\"Execute a notebook via nbconvert and collect output.\n    :returns execution errors\n    \"\"\"\n    args = [",
        "detail": "tests.notebook.test_notebooks",
        "documentation": {}
    },
    {
        "label": "TestIndexer",
        "kind": 6,
        "importPath": "tests.smoke.test_fixtures",
        "description": "tests.smoke.test_fixtures",
        "peekOfCode": "class TestIndexer:\n    params: ClassVar[dict[str, list[tuple[str, dict[str, Any]]]]] = {\n        \"test_fixture\": _load_fixtures()\n    }\n    def __run_indexer(\n        self,\n        root: Path,\n        input_file_type: str,\n    ):\n        command = [",
        "detail": "tests.smoke.test_fixtures",
        "documentation": {}
    },
    {
        "label": "pytest_generate_tests",
        "kind": 2,
        "importPath": "tests.smoke.test_fixtures",
        "description": "tests.smoke.test_fixtures",
        "peekOfCode": "def pytest_generate_tests(metafunc):\n    \"\"\"Generate tests for all test functions in this module.\"\"\"\n    run_slow = metafunc.config.getoption(\"run_slow\")\n    configs = metafunc.cls.params[metafunc.function.__name__]\n    if not run_slow:\n        # Only run tests that are not marked as slow\n        configs = [config for config in configs if not config[1].get(\"slow\", False)]\n    funcarglist = [params[1] for params in configs]\n    id_list = [params[0] for params in configs]\n    argnames = sorted(arg for arg in funcarglist[0] if arg != \"slow\")",
        "detail": "tests.smoke.test_fixtures",
        "documentation": {}
    },
    {
        "label": "cleanup",
        "kind": 2,
        "importPath": "tests.smoke.test_fixtures",
        "description": "tests.smoke.test_fixtures",
        "peekOfCode": "def cleanup(skip: bool = False):\n    \"\"\"Decorator to cleanup the output and cache folders after each test.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except AssertionError:\n                raise\n            finally:",
        "detail": "tests.smoke.test_fixtures",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "tests.smoke.test_fixtures",
        "description": "tests.smoke.test_fixtures",
        "peekOfCode": "log = logging.getLogger(__name__)\ndebug = os.environ.get(\"DEBUG\") is not None\ngh_pages = os.environ.get(\"GH_PAGES\") is not None\n# cspell:disable-next-line well-known-key\nWELL_KNOWN_AZURITE_CONNECTION_STRING = \"DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1\"\nKNOWN_WARNINGS = [NO_COMMUNITY_RECORDS_WARNING]\ndef _load_fixtures():\n    \"\"\"Load all fixtures from the tests/data folder.\"\"\"\n    params = []\n    fixtures_path = Path(\"./tests/fixtures/\")",
        "detail": "tests.smoke.test_fixtures",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 5,
        "importPath": "tests.smoke.test_fixtures",
        "description": "tests.smoke.test_fixtures",
        "peekOfCode": "debug = os.environ.get(\"DEBUG\") is not None\ngh_pages = os.environ.get(\"GH_PAGES\") is not None\n# cspell:disable-next-line well-known-key\nWELL_KNOWN_AZURITE_CONNECTION_STRING = \"DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1\"\nKNOWN_WARNINGS = [NO_COMMUNITY_RECORDS_WARNING]\ndef _load_fixtures():\n    \"\"\"Load all fixtures from the tests/data folder.\"\"\"\n    params = []\n    fixtures_path = Path(\"./tests/fixtures/\")\n    # use the min-csv smoke test to hydrate the docsite parquet artifacts (see gh-pages.yml)",
        "detail": "tests.smoke.test_fixtures",
        "documentation": {}
    },
    {
        "label": "gh_pages",
        "kind": 5,
        "importPath": "tests.smoke.test_fixtures",
        "description": "tests.smoke.test_fixtures",
        "peekOfCode": "gh_pages = os.environ.get(\"GH_PAGES\") is not None\n# cspell:disable-next-line well-known-key\nWELL_KNOWN_AZURITE_CONNECTION_STRING = \"DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1\"\nKNOWN_WARNINGS = [NO_COMMUNITY_RECORDS_WARNING]\ndef _load_fixtures():\n    \"\"\"Load all fixtures from the tests/data folder.\"\"\"\n    params = []\n    fixtures_path = Path(\"./tests/fixtures/\")\n    # use the min-csv smoke test to hydrate the docsite parquet artifacts (see gh-pages.yml)\n    subfolders = [\"min-csv\"] if gh_pages else sorted(os.listdir(fixtures_path))",
        "detail": "tests.smoke.test_fixtures",
        "documentation": {}
    },
    {
        "label": "WELL_KNOWN_AZURITE_CONNECTION_STRING",
        "kind": 5,
        "importPath": "tests.smoke.test_fixtures",
        "description": "tests.smoke.test_fixtures",
        "peekOfCode": "WELL_KNOWN_AZURITE_CONNECTION_STRING = \"DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1\"\nKNOWN_WARNINGS = [NO_COMMUNITY_RECORDS_WARNING]\ndef _load_fixtures():\n    \"\"\"Load all fixtures from the tests/data folder.\"\"\"\n    params = []\n    fixtures_path = Path(\"./tests/fixtures/\")\n    # use the min-csv smoke test to hydrate the docsite parquet artifacts (see gh-pages.yml)\n    subfolders = [\"min-csv\"] if gh_pages else sorted(os.listdir(fixtures_path))\n    for subfolder in subfolders:\n        if not os.path.isdir(fixtures_path / subfolder):",
        "detail": "tests.smoke.test_fixtures",
        "documentation": {}
    },
    {
        "label": "KNOWN_WARNINGS",
        "kind": 5,
        "importPath": "tests.smoke.test_fixtures",
        "description": "tests.smoke.test_fixtures",
        "peekOfCode": "KNOWN_WARNINGS = [NO_COMMUNITY_RECORDS_WARNING]\ndef _load_fixtures():\n    \"\"\"Load all fixtures from the tests/data folder.\"\"\"\n    params = []\n    fixtures_path = Path(\"./tests/fixtures/\")\n    # use the min-csv smoke test to hydrate the docsite parquet artifacts (see gh-pages.yml)\n    subfolders = [\"min-csv\"] if gh_pages else sorted(os.listdir(fixtures_path))\n    for subfolder in subfolders:\n        if not os.path.isdir(fixtures_path / subfolder):\n            continue",
        "detail": "tests.smoke.test_fixtures",
        "documentation": {}
    },
    {
        "label": "TestDefaultConfig",
        "kind": 6,
        "importPath": "tests.unit.config.test_default_config",
        "description": "tests.unit.config.test_default_config",
        "peekOfCode": "class TestDefaultConfig(unittest.TestCase):\n    def test_clear_warnings(self):\n        \"\"\"Just clearing unused import warnings\"\"\"\n        assert CacheConfig is not None\n        assert ChunkingConfig is not None\n        assert ClaimExtractionConfig is not None\n        assert ClusterGraphConfig is not None\n        assert CommunityReportsConfig is not None\n        assert EmbedGraphConfig is not None\n        assert EntityExtractionConfig is not None",
        "detail": "tests.unit.config.test_default_config",
        "documentation": {}
    },
    {
        "label": "test_yaml_load_e2e",
        "kind": 2,
        "importPath": "tests.unit.config.test_default_config",
        "description": "tests.unit.config.test_default_config",
        "peekOfCode": "def test_yaml_load_e2e():\n    config_dict = yaml.safe_load(\n        \"\"\"\ninput:\n  file_type: text\nllm:\n  type: azure_openai_chat\n  api_key: ${PIPELINE_LLM_API_KEY}\n  api_base: ${PIPELINE_LLM_API_BASE}\n  api_version: ${PIPELINE_LLM_API_VERSION}",
        "detail": "tests.unit.config.test_default_config",
        "documentation": {}
    },
    {
        "label": "current_dir",
        "kind": 5,
        "importPath": "tests.unit.config.test_default_config",
        "description": "tests.unit.config.test_default_config",
        "peekOfCode": "current_dir = os.path.dirname(__file__)\nALL_ENV_VARS = {\n    \"GRAPHRAG_API_BASE\": \"http://some/base\",\n    \"GRAPHRAG_API_KEY\": \"test\",\n    \"GRAPHRAG_API_ORGANIZATION\": \"test_org\",\n    \"GRAPHRAG_API_PROXY\": \"http://some/proxy\",\n    \"GRAPHRAG_API_VERSION\": \"v1234\",\n    \"GRAPHRAG_ASYNC_MODE\": \"asyncio\",\n    \"GRAPHRAG_CACHE_STORAGE_ACCOUNT_BLOB_URL\": \"cache_account_blob_url\",\n    \"GRAPHRAG_CACHE_BASE_DIR\": \"/some/cache/dir\",",
        "detail": "tests.unit.config.test_default_config",
        "documentation": {}
    },
    {
        "label": "ALL_ENV_VARS",
        "kind": 5,
        "importPath": "tests.unit.config.test_default_config",
        "description": "tests.unit.config.test_default_config",
        "peekOfCode": "ALL_ENV_VARS = {\n    \"GRAPHRAG_API_BASE\": \"http://some/base\",\n    \"GRAPHRAG_API_KEY\": \"test\",\n    \"GRAPHRAG_API_ORGANIZATION\": \"test_org\",\n    \"GRAPHRAG_API_PROXY\": \"http://some/proxy\",\n    \"GRAPHRAG_API_VERSION\": \"v1234\",\n    \"GRAPHRAG_ASYNC_MODE\": \"asyncio\",\n    \"GRAPHRAG_CACHE_STORAGE_ACCOUNT_BLOB_URL\": \"cache_account_blob_url\",\n    \"GRAPHRAG_CACHE_BASE_DIR\": \"/some/cache/dir\",\n    \"GRAPHRAG_CACHE_CONNECTION_STRING\": \"test_cs1\",",
        "detail": "tests.unit.config.test_default_config",
        "documentation": {}
    },
    {
        "label": "test_resolve_path_no_timestamp_with_run_id",
        "kind": 2,
        "importPath": "tests.unit.config.test_resolve_path",
        "description": "tests.unit.config.test_resolve_path",
        "peekOfCode": "def test_resolve_path_no_timestamp_with_run_id():\n    path = Path(\"path/to/data\")\n    result = resolve_path(path, pattern_or_timestamp_value=\"20240812-121000\")\n    assert result == path\ndef test_resolve_path_no_timestamp_without_run_id():\n    path = Path(\"path/to/data\")\n    result = resolve_path(path)\n    assert result == path\ndef test_resolve_path_with_timestamp_and_run_id():\n    path = Path(\"some/path/${timestamp}/data\")",
        "detail": "tests.unit.config.test_resolve_path",
        "documentation": {}
    },
    {
        "label": "test_resolve_path_no_timestamp_without_run_id",
        "kind": 2,
        "importPath": "tests.unit.config.test_resolve_path",
        "description": "tests.unit.config.test_resolve_path",
        "peekOfCode": "def test_resolve_path_no_timestamp_without_run_id():\n    path = Path(\"path/to/data\")\n    result = resolve_path(path)\n    assert result == path\ndef test_resolve_path_with_timestamp_and_run_id():\n    path = Path(\"some/path/${timestamp}/data\")\n    expected = Path(\"some/path/20240812/data\")\n    result = resolve_path(path, pattern_or_timestamp_value=\"20240812\")\n    assert result == expected\ndef test_resolve_path_with_timestamp_and_inferred_directory():",
        "detail": "tests.unit.config.test_resolve_path",
        "documentation": {}
    },
    {
        "label": "test_resolve_path_with_timestamp_and_run_id",
        "kind": 2,
        "importPath": "tests.unit.config.test_resolve_path",
        "description": "tests.unit.config.test_resolve_path",
        "peekOfCode": "def test_resolve_path_with_timestamp_and_run_id():\n    path = Path(\"some/path/${timestamp}/data\")\n    expected = Path(\"some/path/20240812/data\")\n    result = resolve_path(path, pattern_or_timestamp_value=\"20240812\")\n    assert result == expected\ndef test_resolve_path_with_timestamp_and_inferred_directory():\n    cwd = Path(__file__).parent\n    path = cwd / \"fixtures/timestamp_dirs/${timestamp}/data\"\n    expected = cwd / \"fixtures/timestamp_dirs/20240812-120000/data\"\n    result = resolve_path(path)",
        "detail": "tests.unit.config.test_resolve_path",
        "documentation": {}
    },
    {
        "label": "test_resolve_path_with_timestamp_and_inferred_directory",
        "kind": 2,
        "importPath": "tests.unit.config.test_resolve_path",
        "description": "tests.unit.config.test_resolve_path",
        "peekOfCode": "def test_resolve_path_with_timestamp_and_inferred_directory():\n    cwd = Path(__file__).parent\n    path = cwd / \"fixtures/timestamp_dirs/${timestamp}/data\"\n    expected = cwd / \"fixtures/timestamp_dirs/20240812-120000/data\"\n    result = resolve_path(path)\n    assert result == expected\ndef test_resolve_path_absolute():\n    cwd = Path(__file__).parent\n    path = \"fixtures/timestamp_dirs/${timestamp}/data\"\n    expected = cwd / \"fixtures/timestamp_dirs/20240812-120000/data\"",
        "detail": "tests.unit.config.test_resolve_path",
        "documentation": {}
    },
    {
        "label": "test_resolve_path_absolute",
        "kind": 2,
        "importPath": "tests.unit.config.test_resolve_path",
        "description": "tests.unit.config.test_resolve_path",
        "peekOfCode": "def test_resolve_path_absolute():\n    cwd = Path(__file__).parent\n    path = \"fixtures/timestamp_dirs/${timestamp}/data\"\n    expected = cwd / \"fixtures/timestamp_dirs/20240812-120000/data\"\n    result = resolve_path(path, cwd)\n    assert result == expected\n    assert result.is_absolute()",
        "detail": "tests.unit.config.test_resolve_path",
        "documentation": {}
    },
    {
        "label": "TestFilePipelineCache",
        "kind": 6,
        "importPath": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "description": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "peekOfCode": "class TestFilePipelineCache(unittest.IsolatedAsyncioTestCase):\n    def setUp(self):\n        self.cache = create_cache()\n    def tearDown(self):\n        asyncio.run(self.cache.clear())\n    async def test_cache_clear(self):\n        # Create a cache directory\n        if not os.path.exists(TEMP_DIR):\n            os.mkdir(TEMP_DIR)\n        with open(f\"{TEMP_DIR}/test1\", \"w\") as f:",
        "detail": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "create_cache",
        "kind": 2,
        "importPath": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "description": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "peekOfCode": "def create_cache():\n    storage = FilePipelineStorage(os.path.join(os.getcwd(), \".tmp\"))\n    return JsonPipelineCache(storage)\nclass TestFilePipelineCache(unittest.IsolatedAsyncioTestCase):\n    def setUp(self):\n        self.cache = create_cache()\n    def tearDown(self):\n        asyncio.run(self.cache.clear())\n    async def test_cache_clear(self):\n        # Create a cache directory",
        "detail": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "TEMP_DIR",
        "kind": 5,
        "importPath": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "description": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "peekOfCode": "TEMP_DIR = \"./.tmp\"\ndef create_cache():\n    storage = FilePipelineStorage(os.path.join(os.getcwd(), \".tmp\"))\n    return JsonPipelineCache(storage)\nclass TestFilePipelineCache(unittest.IsolatedAsyncioTestCase):\n    def setUp(self):\n        self.cache = create_cache()\n    def tearDown(self):\n        asyncio.run(self.cache.clear())\n    async def test_cache_clear(self):",
        "detail": "tests.unit.indexing.cache.test_file_pipeline_cache",
        "documentation": {}
    },
    {
        "label": "assert_contains_default_config",
        "kind": 2,
        "importPath": "tests.unit.indexing.config.helpers",
        "description": "tests.unit.indexing.config.helpers",
        "peekOfCode": "def assert_contains_default_config(\n    test_case: unittest.TestCase,\n    config: Any,\n    check_input=True,\n    check_storage=True,\n    check_reporting=True,\n    check_cache=True,\n    check_workflows=True,\n):\n    \"\"\"Asserts that the config contains the default config.\"\"\"",
        "detail": "tests.unit.indexing.config.helpers",
        "documentation": {}
    },
    {
        "label": "TestLoadPipelineConfig",
        "kind": 6,
        "importPath": "tests.unit.indexing.config.test_load",
        "description": "tests.unit.indexing.config.test_load",
        "peekOfCode": "class TestLoadPipelineConfig(unittest.TestCase):\n    @mock.patch.dict(os.environ, {\"GRAPHRAG_API_KEY\": \"test\"}, clear=True)\n    def test_config_passed_in_returns_config(self):\n        config = PipelineConfig()\n        result = load_pipeline_config(config)\n        assert result == config\n    @mock.patch.dict(os.environ, {\"GRAPHRAG_API_KEY\": \"test\"}, clear=True)\n    def test_loading_default_config_returns_config(self):\n        result = load_pipeline_config(\"default\")\n        self.assert_is_default_config(result)",
        "detail": "tests.unit.indexing.config.test_load",
        "documentation": {}
    },
    {
        "label": "current_dir",
        "kind": 5,
        "importPath": "tests.unit.indexing.config.test_load",
        "description": "tests.unit.indexing.config.test_load",
        "peekOfCode": "current_dir = os.path.dirname(__file__)\nclass TestLoadPipelineConfig(unittest.TestCase):\n    @mock.patch.dict(os.environ, {\"GRAPHRAG_API_KEY\": \"test\"}, clear=True)\n    def test_config_passed_in_returns_config(self):\n        config = PipelineConfig()\n        result = load_pipeline_config(config)\n        assert result == config\n    @mock.patch.dict(os.environ, {\"GRAPHRAG_API_KEY\": \"test\"}, clear=True)\n    def test_loading_default_config_returns_config(self):\n        result = load_pipeline_config(\"default\")",
        "detail": "tests.unit.indexing.config.test_load",
        "documentation": {}
    },
    {
        "label": "test_sort_context",
        "kind": 2,
        "importPath": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "description": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "peekOfCode": "def test_sort_context():\n    ctx = sort_context(context)\n    assert num_tokens(ctx) == 827 if platform.system() == \"Windows\" else 826\n    assert ctx is not None\ndef test_sort_context_max_tokens():\n    ctx = sort_context(context, max_tokens=800)\n    assert ctx is not None\n    assert num_tokens(ctx) <= 800",
        "detail": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "documentation": {}
    },
    {
        "label": "test_sort_context_max_tokens",
        "kind": 2,
        "importPath": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "description": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "peekOfCode": "def test_sort_context_max_tokens():\n    ctx = sort_context(context, max_tokens=800)\n    assert ctx is not None\n    assert num_tokens(ctx) <= 800",
        "detail": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "documentation": {}
    },
    {
        "label": "nan",
        "kind": 5,
        "importPath": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "description": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "peekOfCode": "nan = math.nan\ncontext: list[dict] = [\n    {\n        \"title\": \"ALI BABA\",\n        \"degree\": 1,\n        \"node_details\": {\n            \"human_readable_id\": 26,\n            \"title\": \"ALI BABA\",\n            \"description\": \"A character from Scrooge's reading, representing a memory of his childhood imagination\",\n            \"degree\": 1,",
        "detail": "tests.unit.indexing.graph.extractors.community_reports.test_sort_context",
        "documentation": {}
    },
    {
        "label": "TestStableLCC",
        "kind": 6,
        "importPath": "tests.unit.indexing.graph.utils.test_stable_lcc",
        "description": "tests.unit.indexing.graph.utils.test_stable_lcc",
        "peekOfCode": "class TestStableLCC(unittest.TestCase):\n    def test_undirected_graph_run_twice_produces_same_graph(self):\n        graph_in_1 = self._create_strongly_connected_graph()\n        graph_out_1 = stable_largest_connected_component(graph_in_1)\n        graph_in_2 = self._create_strongly_connected_graph_with_edges_flipped()\n        graph_out_2 = stable_largest_connected_component(graph_in_2)\n        # Make sure they're the same\n        assert \"\".join(nx.generate_graphml(graph_out_1)) == \"\".join(\n            nx.generate_graphml(graph_out_2)\n        )",
        "detail": "tests.unit.indexing.graph.utils.test_stable_lcc",
        "documentation": {}
    },
    {
        "label": "TestRunChain",
        "kind": 6,
        "importPath": "tests.unit.indexing.verbs.entities.extraction.strategies.graph_intelligence.test_gi_entity_extraction",
        "description": "tests.unit.indexing.verbs.entities.extraction.strategies.graph_intelligence.test_gi_entity_extraction",
        "peekOfCode": "class TestRunChain(unittest.IsolatedAsyncioTestCase):\n    async def test_run_extract_entities_single_document_correct_entities_returned(self):\n        results = await run_extract_entities(\n            docs=[Document(\"test_text\", \"1\")],\n            entity_types=[\"person\"],\n            callbacks=None,\n            args={\n                \"prechunked\": True,\n                \"max_gleanings\": 0,\n                \"summarize_descriptions\": False,",
        "detail": "tests.unit.indexing.verbs.entities.extraction.strategies.graph_intelligence.test_gi_entity_extraction",
        "documentation": {}
    },
    {
        "label": "create_mock_llm",
        "kind": 2,
        "importPath": "tests.unit.indexing.verbs.helpers.mock_llm",
        "description": "tests.unit.indexing.verbs.helpers.mock_llm",
        "peekOfCode": "def create_mock_llm(\n    responses: list[str],\n) -> CompletionLLM:\n    \"\"\"Creates a mock LLM that returns the given responses.\"\"\"\n    return MockChatLLM(responses)",
        "detail": "tests.unit.indexing.verbs.helpers.mock_llm",
        "documentation": {}
    },
    {
        "label": "TestTextSplit",
        "kind": 6,
        "importPath": "tests.unit.indexing.verbs.text.test_split",
        "description": "tests.unit.indexing.verbs.text.test_split",
        "peekOfCode": "class TestTextSplit(unittest.TestCase):\n    def test_empty_string(self):\n        input = pd.DataFrame([{\"in\": \"\"}])\n        result = split_text(input, \"in\", \"out\", \",\").to_dict(orient=\"records\")\n        assert len(result) == 1\n        assert result[0][\"out\"] == []\n    def test_string_without_seperator(self):\n        input = pd.DataFrame([{\"in\": \"test_string_without_seperator\"}])\n        result = split_text(input, \"in\", \"out\", \",\").to_dict(orient=\"records\")\n        assert len(result) == 1",
        "detail": "tests.unit.indexing.verbs.text.test_split",
        "documentation": {}
    },
    {
        "label": "mock_verbs",
        "kind": 5,
        "importPath": "tests.unit.indexing.workflows.helpers",
        "description": "tests.unit.indexing.workflows.helpers",
        "peekOfCode": "mock_verbs = {\n    \"mock_verb\": lambda x: x,\n    \"mock_verb_2\": lambda x: x,\n}\nmock_workflows = {\n    \"mock_workflow\": lambda _x: [\n        {\n            \"verb\": \"mock_verb\",\n            \"args\": {\n                \"column\": \"test\",",
        "detail": "tests.unit.indexing.workflows.helpers",
        "documentation": {}
    },
    {
        "label": "mock_workflows",
        "kind": 5,
        "importPath": "tests.unit.indexing.workflows.helpers",
        "description": "tests.unit.indexing.workflows.helpers",
        "peekOfCode": "mock_workflows = {\n    \"mock_workflow\": lambda _x: [\n        {\n            \"verb\": \"mock_verb\",\n            \"args\": {\n                \"column\": \"test\",\n            },\n        }\n    ],\n    \"mock_workflow_2\": lambda _x: [",
        "detail": "tests.unit.indexing.workflows.helpers",
        "documentation": {}
    },
    {
        "label": "TestCreateWorkflow",
        "kind": 6,
        "importPath": "tests.unit.indexing.workflows.test_load",
        "description": "tests.unit.indexing.workflows.test_load",
        "peekOfCode": "class TestCreateWorkflow(unittest.TestCase):\n    def test_workflow_with_steps_should_not_fail(self):\n        create_workflow(\n            \"workflow_with_steps\",\n            [\n                {\n                    \"verb\": \"mock_verb\",\n                    \"args\": {\n                        \"column\": \"test\",\n                    },",
        "detail": "tests.unit.indexing.workflows.test_load",
        "documentation": {}
    },
    {
        "label": "TestLoadWorkflows",
        "kind": 6,
        "importPath": "tests.unit.indexing.workflows.test_load",
        "description": "tests.unit.indexing.workflows.test_load",
        "peekOfCode": "class TestLoadWorkflows(unittest.TestCase):\n    def test_non_existent_workflow_should_crash(self):\n        with pytest.raises(UnknownWorkflowError):\n            load_workflows(\n                [\n                    PipelineWorkflowReference(\n                        name=\"some_workflow_that_does_not_exist\",\n                        config=None,\n                    )\n                ],",
        "detail": "tests.unit.indexing.workflows.test_load",
        "documentation": {}
    },
    {
        "label": "test_exported_functions",
        "kind": 2,
        "importPath": "tests.unit.indexing.test_exports",
        "description": "tests.unit.indexing.test_exports",
        "peekOfCode": "def test_exported_functions():\n    assert callable(create_pipeline_config)\n    assert callable(run_pipeline_with_config)\n    assert callable(run_pipeline)",
        "detail": "tests.unit.indexing.test_exports",
        "documentation": {}
    },
    {
        "label": "test_init_yaml",
        "kind": 2,
        "importPath": "tests.unit.indexing.test_init_content",
        "description": "tests.unit.indexing.test_init_content",
        "peekOfCode": "def test_init_yaml():\n    data = yaml.load(INIT_YAML, Loader=yaml.FullLoader)\n    config = create_graphrag_config(data)\n    GraphRagConfig.model_validate(config, strict=True)\ndef test_init_yaml_uncommented():\n    lines = INIT_YAML.splitlines()\n    lines = [line for line in lines if \"##\" not in line]\n    def uncomment_line(line: str) -> str:\n        leading_whitespace = cast(Any, re.search(r\"^(\\s*)\", line)).group(1)\n        return re.sub(r\"^\\s*# \", leading_whitespace, line, count=1)",
        "detail": "tests.unit.indexing.test_init_content",
        "documentation": {}
    },
    {
        "label": "test_init_yaml_uncommented",
        "kind": 2,
        "importPath": "tests.unit.indexing.test_init_content",
        "description": "tests.unit.indexing.test_init_content",
        "peekOfCode": "def test_init_yaml_uncommented():\n    lines = INIT_YAML.splitlines()\n    lines = [line for line in lines if \"##\" not in line]\n    def uncomment_line(line: str) -> str:\n        leading_whitespace = cast(Any, re.search(r\"^(\\s*)\", line)).group(1)\n        return re.sub(r\"^\\s*# \", leading_whitespace, line, count=1)\n    content = \"\\n\".join([uncomment_line(line) for line in lines])\n    data = yaml.load(content, Loader=yaml.FullLoader)\n    config = create_graphrag_config(data)\n    GraphRagConfig.model_validate(config, strict=True)",
        "detail": "tests.unit.indexing.test_init_content",
        "documentation": {}
    },
    {
        "label": "TestCache",
        "kind": 6,
        "importPath": "tests.unit.llm.base.test_caching_llm",
        "description": "tests.unit.llm.base.test_caching_llm",
        "peekOfCode": "class TestCache(LLMCache):\n    def __init__(self):\n        self.cache = {}\n    async def has(self, key: str) -> bool:\n        return key in self.cache\n    async def get(self, key: str) -> dict | None:\n        entry = self.cache.get(key)\n        return entry[\"result\"] if entry else None\n    async def set(\n        self, key: str, value: str, debug_data: dict[str, Any] | None = None",
        "detail": "tests.unit.llm.base.test_caching_llm",
        "documentation": {}
    },
    {
        "label": "throwing_responder",
        "kind": 2,
        "importPath": "tests.unit.llm.base.test_caching_llm",
        "description": "tests.unit.llm.base.test_caching_llm",
        "peekOfCode": "def throwing_responder(input: str, **kwargs: dict) -> LLMOutput:\n    raise ValueError\nmock_responder_llm = cast(CompletionLLM, mock_responder)\nthrowing_llm = cast(CompletionLLM, throwing_responder)\nasync def test_caching_llm() -> None:\n    \"\"\"Test a composite LLM.\"\"\"\n    llm = CachingLLM(\n        mock_responder_llm, llm_parameters={}, operation=\"test\", cache=TestCache()\n    )\n    response = await llm(\"input 1\")",
        "detail": "tests.unit.llm.base.test_caching_llm",
        "documentation": {}
    },
    {
        "label": "mock_responder_llm",
        "kind": 5,
        "importPath": "tests.unit.llm.base.test_caching_llm",
        "description": "tests.unit.llm.base.test_caching_llm",
        "peekOfCode": "mock_responder_llm = cast(CompletionLLM, mock_responder)\nthrowing_llm = cast(CompletionLLM, throwing_responder)\nasync def test_caching_llm() -> None:\n    \"\"\"Test a composite LLM.\"\"\"\n    llm = CachingLLM(\n        mock_responder_llm, llm_parameters={}, operation=\"test\", cache=TestCache()\n    )\n    response = await llm(\"input 1\")\n    assert response.output == \"response to [input 1]\"\n    llm.set_delegate(throwing_llm)",
        "detail": "tests.unit.llm.base.test_caching_llm",
        "documentation": {}
    },
    {
        "label": "throwing_llm",
        "kind": 5,
        "importPath": "tests.unit.llm.base.test_caching_llm",
        "description": "tests.unit.llm.base.test_caching_llm",
        "peekOfCode": "throwing_llm = cast(CompletionLLM, throwing_responder)\nasync def test_caching_llm() -> None:\n    \"\"\"Test a composite LLM.\"\"\"\n    llm = CachingLLM(\n        mock_responder_llm, llm_parameters={}, operation=\"test\", cache=TestCache()\n    )\n    response = await llm(\"input 1\")\n    assert response.output == \"response to [input 1]\"\n    llm.set_delegate(throwing_llm)\n    response = await llm(\"input 1\")",
        "detail": "tests.unit.llm.base.test_caching_llm",
        "documentation": {}
    },
    {
        "label": "MOCK_LLM_RESPONSES",
        "kind": 5,
        "importPath": "tests.verbs.test_create_base_extracted_entities",
        "description": "tests.verbs.test_create_base_extracted_entities",
        "peekOfCode": "MOCK_LLM_RESPONSES = [\n    \"\"\"\n    (\"entity\"<|>COMPANY_A<|>COMPANY<|>Company_A is a test company)\n    ##\n    (\"entity\"<|>COMPANY_B<|>COMPANY<|>Company_B owns Company_A and also shares an address with Company_A)\n    ##\n    (\"entity\"<|>PERSON_C<|>PERSON<|>Person_C is director of Company_A)\n    ##\n    (\"relationship\"<|>COMPANY_A<|>COMPANY_B<|>Company_A and Company_B are related because Company_A is 100% owned by Company_B and the two companies also share the same address)<|>2)\n    ##",
        "detail": "tests.verbs.test_create_base_extracted_entities",
        "documentation": {}
    },
    {
        "label": "MOCK_LLM_CONFIG",
        "kind": 5,
        "importPath": "tests.verbs.test_create_base_extracted_entities",
        "description": "tests.verbs.test_create_base_extracted_entities",
        "peekOfCode": "MOCK_LLM_CONFIG = {\n    \"type\": LLMType.StaticResponse,\n    \"responses\": MOCK_LLM_RESPONSES,\n}\nasync def test_create_base_extracted_entities():\n    input_tables = load_input_tables([\"workflow:create_base_text_units\"])\n    expected = load_expected(workflow_name)\n    storage = MemoryPipelineStorage()\n    config = get_config_for_workflow(workflow_name)\n    config[\"entity_extract\"][\"strategy\"][\"llm\"] = MOCK_LLM_CONFIG",
        "detail": "tests.verbs.test_create_base_extracted_entities",
        "documentation": {}
    },
    {
        "label": "MOCK_RESPONSES",
        "kind": 5,
        "importPath": "tests.verbs.test_create_final_community_reports",
        "description": "tests.verbs.test_create_final_community_reports",
        "peekOfCode": "MOCK_RESPONSES = [\n    json.dumps({\n        \"title\": \"<report_title>\",\n        \"summary\": \"<executive_summary>\",\n        \"rating\": 2,\n        \"rating_explanation\": \"<rating_explanation>\",\n        \"findings\": [\n            {\n                \"summary\": \"<insight_1_summary>\",\n                \"explanation\": \"<insight_1_explanation\",",
        "detail": "tests.verbs.test_create_final_community_reports",
        "documentation": {}
    },
    {
        "label": "MOCK_LLM_CONFIG",
        "kind": 5,
        "importPath": "tests.verbs.test_create_final_community_reports",
        "description": "tests.verbs.test_create_final_community_reports",
        "peekOfCode": "MOCK_LLM_CONFIG = {\"type\": LLMType.StaticResponse, \"responses\": MOCK_RESPONSES}\nasync def test_create_final_community_reports():\n    input_tables = load_input_tables([\n        \"workflow:create_final_nodes\",\n        \"workflow:create_final_covariates\",\n        \"workflow:create_final_relationships\",\n    ])\n    expected = load_expected(workflow_name)\n    config = get_config_for_workflow(workflow_name)\n    config[\"create_community_reports\"][\"strategy\"][\"llm\"] = MOCK_LLM_CONFIG",
        "detail": "tests.verbs.test_create_final_community_reports",
        "documentation": {}
    },
    {
        "label": "MOCK_LLM_RESPONSES",
        "kind": 5,
        "importPath": "tests.verbs.test_create_final_covariates",
        "description": "tests.verbs.test_create_final_covariates",
        "peekOfCode": "MOCK_LLM_RESPONSES = [\n    \"\"\"\n(COMPANY A<|>GOVERNMENT AGENCY B<|>ANTI-COMPETITIVE PRACTICES<|>TRUE<|>2022-01-10T00:00:00<|>2022-01-10T00:00:00<|>Company A was found to engage in anti-competitive practices because it was fined for bid rigging in multiple public tenders published by Government Agency B according to an article published on 2022/01/10<|>According to an article published on 2022/01/10, Company A was fined for bid rigging while participating in multiple public tenders published by Government Agency B.)\n    \"\"\".strip()\n]\nMOCK_LLM_CONFIG = {\"type\": LLMType.StaticResponse, \"responses\": MOCK_LLM_RESPONSES}\nasync def test_create_final_covariates():\n    input_tables = load_input_tables([\"workflow:create_base_text_units\"])\n    expected = load_expected(workflow_name)\n    config = get_config_for_workflow(workflow_name)",
        "detail": "tests.verbs.test_create_final_covariates",
        "documentation": {}
    },
    {
        "label": "MOCK_LLM_CONFIG",
        "kind": 5,
        "importPath": "tests.verbs.test_create_final_covariates",
        "description": "tests.verbs.test_create_final_covariates",
        "peekOfCode": "MOCK_LLM_CONFIG = {\"type\": LLMType.StaticResponse, \"responses\": MOCK_LLM_RESPONSES}\nasync def test_create_final_covariates():\n    input_tables = load_input_tables([\"workflow:create_base_text_units\"])\n    expected = load_expected(workflow_name)\n    config = get_config_for_workflow(workflow_name)\n    config[\"claim_extract\"][\"strategy\"][\"llm\"] = MOCK_LLM_CONFIG\n    steps = build_steps(config)\n    actual = await get_workflow_output(\n        input_tables,\n        {",
        "detail": "tests.verbs.test_create_final_covariates",
        "documentation": {}
    },
    {
        "label": "MOCK_LLM_RESPONSES",
        "kind": 5,
        "importPath": "tests.verbs.test_create_summarized_entities",
        "description": "tests.verbs.test_create_summarized_entities",
        "peekOfCode": "MOCK_LLM_RESPONSES = [\n    \"\"\"\n    This is a MOCK response for the LLM. It is summarized!\n    \"\"\".strip()\n]\nMOCK_LLM_CONFIG = {\n    \"type\": LLMType.StaticResponse,\n    \"responses\": MOCK_LLM_RESPONSES,\n}\nasync def test_create_summarized_entities():",
        "detail": "tests.verbs.test_create_summarized_entities",
        "documentation": {}
    },
    {
        "label": "MOCK_LLM_CONFIG",
        "kind": 5,
        "importPath": "tests.verbs.test_create_summarized_entities",
        "description": "tests.verbs.test_create_summarized_entities",
        "peekOfCode": "MOCK_LLM_CONFIG = {\n    \"type\": LLMType.StaticResponse,\n    \"responses\": MOCK_LLM_RESPONSES,\n}\nasync def test_create_summarized_entities():\n    input_tables = load_input_tables([\n        \"workflow:create_base_extracted_entities\",\n    ])\n    expected = load_expected(workflow_name)\n    storage = MemoryPipelineStorage()",
        "detail": "tests.verbs.test_create_summarized_entities",
        "documentation": {}
    },
    {
        "label": "load_input_tables",
        "kind": 2,
        "importPath": "tests.verbs.util",
        "description": "tests.verbs.util",
        "peekOfCode": "def load_input_tables(inputs: list[str]) -> dict[str, pd.DataFrame]:\n    \"\"\"Harvest all the referenced input IDs from the workflow being tested and pass them here.\"\"\"\n    # stick all the inputs in a map - Workflow looks them up by name\n    input_tables: dict[str, pd.DataFrame] = {}\n    # all workflows implicitly receive the `input` source, which is formatted as a dataframe after loading from storage\n    # we'll simulate that by just loading one of our output parquets and converting back to equivalent dataframe\n    # so we aren't dealing with storage vagaries (which would become an integration test)\n    source = pd.read_parquet(\"tests/verbs/data/create_base_documents.parquet\")\n    source.rename(columns={\"raw_content\": \"text\"}, inplace=True)\n    input_tables[\"source\"] = cast(pd.DataFrame, source[[\"id\", \"text\", \"title\"]])",
        "detail": "tests.verbs.util",
        "documentation": {}
    },
    {
        "label": "load_expected",
        "kind": 2,
        "importPath": "tests.verbs.util",
        "description": "tests.verbs.util",
        "peekOfCode": "def load_expected(output: str) -> pd.DataFrame:\n    \"\"\"Pass in the workflow output (generally the workflow name)\"\"\"\n    return pd.read_parquet(f\"tests/verbs/data/{output}.parquet\")\ndef get_config_for_workflow(name: str) -> PipelineWorkflowConfig:\n    \"\"\"Instantiates the bare minimum config to get a default workflow config for testing.\"\"\"\n    config = create_graphrag_config()\n    # this flag needs to be set before creating the pipeline config, or the entire covariate workflow will be excluded\n    config.claim_extraction.enabled = True\n    pipeline_config = create_pipeline_config(config)\n    result = next(conf for conf in pipeline_config.workflows if conf.name == name)",
        "detail": "tests.verbs.util",
        "documentation": {}
    },
    {
        "label": "get_config_for_workflow",
        "kind": 2,
        "importPath": "tests.verbs.util",
        "description": "tests.verbs.util",
        "peekOfCode": "def get_config_for_workflow(name: str) -> PipelineWorkflowConfig:\n    \"\"\"Instantiates the bare minimum config to get a default workflow config for testing.\"\"\"\n    config = create_graphrag_config()\n    # this flag needs to be set before creating the pipeline config, or the entire covariate workflow will be excluded\n    config.claim_extraction.enabled = True\n    pipeline_config = create_pipeline_config(config)\n    result = next(conf for conf in pipeline_config.workflows if conf.name == name)\n    return cast(PipelineWorkflowConfig, result.config)\nasync def get_workflow_output(\n    input_tables: dict[str, pd.DataFrame],",
        "detail": "tests.verbs.util",
        "documentation": {}
    },
    {
        "label": "compare_outputs",
        "kind": 2,
        "importPath": "tests.verbs.util",
        "description": "tests.verbs.util",
        "peekOfCode": "def compare_outputs(\n    actual: pd.DataFrame, expected: pd.DataFrame, columns: list[str] | None = None\n) -> None:\n    \"\"\"Compare the actual and expected dataframes, optionally specifying columns to compare.\n    This uses assert_series_equal since we are sometimes intentionally omitting columns from the actual output.\"\"\"\n    cols = expected.columns if columns is None else columns\n    assert len(actual) == len(\n        expected\n    ), f\"Expected: {len(expected)} rows, Actual: {len(actual)} rows\"\n    for column in cols:",
        "detail": "tests.verbs.util",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def pytest_addoption(parser):\n    parser.addoption(\n        \"--run_slow\", action=\"store_true\", default=False, help=\"run slow tests\"\n    )",
        "detail": "tests.conftest",
        "documentation": {}
    }
]